Mai jos ai documentul “cap-coadă” pe care îl dai echipei IT. E scris ca un caiet de sarcini tehnic + arhitectură, cu pași “ca la grădiniță”, și include:
•	✅ OTP (diagramă + pseudo-cod) pentru login + semnare
•	✅ PDF mandat auto-generat cu hash + timestamp + audit trail
•	✅ Integrare CertSign: ce să le ceri + cum să o implementeze
•	✅ Integrare ANAF (SPV / OAuth / API): cum să construiască pipeline-ul (în funcție de ce endpoint-uri sunt disponibile) (ANAF)
•	✅ Azure-only: SQL + Cosmos + Blob + KeyVault + Service Bus + Functions
•	✅ KYC: selfie/documente șterse automat după 30 zile
•	✅ CNP mascat + pseudonym ID stabil 5 ani
•	✅ Motor de reguli pentru eligibilitate (configurabil, versionat)
•	✅ UX “super simplu” (18 ani vs 70 ani) + calculatoare: guest vs account
Important legal/operational: ANAF are un cadru de înregistrare aplicații pentru API și documentație OAuth pentru acces la API-uri expuse (api.anaf.ro). Unele servicii ANAF sunt pentru registre publice, altele pentru SPV / e-Factura / e-Transport etc. De aceea proiectăm modulul ANAF ca connector pluggable: folosești exact endpoint-urile la care primești acces, fără să schimbi restul platformei. (ANAF)
________________________________________
1) Blueprint Azure (arhitectură “beton”, extensibilă)
1.1 Componente (obligatoriu)
1.	Frontend Web (React/Next)
2.	Apps iOS/Android (Flutter/React Native sau native)
3.	API Gateway + Backend (App Service sau AKS)
4.	Auth Service (OTP + sessions)
5.	Consent & Mandate Service (consimțământ dual + mandate)
6.	Document Service (PDF generator + hashing + storage)
7.	Signature Service (CertSign PAdES)
8.	ANAF Connector Service (SPV/OAuth/API)
9.	BC Connector Service (când ai contract / canal legal)
10.	Rules Engine Service (eligibilitate, grad îndatorare, praguri)
11.	Broker Directory Service (ANPC list + KYC broker)
12.	Event/Audit Service (Cosmos, hash-chain)
1.2 Azure services (mapare)
•	Azure Front Door + WAF (edge + protecție)
•	App Service / AKS (microservicii)
•	Azure SQL (core data)
•	Azure Cosmos DB (audit/event stream, TTL)
•	Azure Blob Storage (ADLS Gen2) (PDF, KYC, exports)
•	Azure Key Vault (chei, secrete, CMK)
•	Azure Service Bus (queue pentru joburi)
•	Azure Functions (cron: ștergeri KYC, expirări mandate)
•	Azure Monitor + Log Analytics (observabilitate)
•	Defender for Cloud (hardening)
________________________________________
2) Identitate, KYC, Pseudonimizare (CNP “blurat”, ID stabil 5 ani)
2.1 Principiu
•	NU stoca CNP în clar în DB operational.
•	Stochezi HMAC hash + SubjectID stabil.
Algoritm recomandat
•	cnp_hash = HMAC_SHA256(pepper1, CNP)
•	subject_id = "MS-" + BASE32(HMAC_SHA256(pepper2, CNP))[0:16]
•	În UI/PDF: CNP mascat ******5579
Pepper-urile stau în Key Vault (rotire anuală, păstrezi versiuni).
2.2 Retenții
•	KYC images/docs: 30 zile (Blob lifecycle delete)
•	KYC metadata (fără imagini): 5 ani (pentru audit minimal)
•	Consents + mandates + doc hashes: 5 ani (audit)
________________________________________
3) Flow OTP complet (Login + Semnare) + Email/SMS
3.1 Scopuri OTP (purpose)
•	LOGIN_SMS
•	SIGN_SMS
•	EMAIL_VERIFY
•	STEP_UP_SECURITY (risk-based)
3.2 Diagramă (end-to-end)
[Web/App]
  |--(1) request OTP SMS: /otp/request {phone, purpose}
  v
[Auth Service]
  |-- rate limit + device check + create otp_id
  |-- store OTP_HASH + expiry + attempts
  |-- send SMS via provider
  v
[User receives SMS]
  |
  |--(2) verify OTP: /otp/verify {otp_id, code}
  v
[Auth Service]
  |-- verify hash, mark used, issue JWT session
  v
[Logged in]

--- Email verification (optional / parallel) ---
[Web/App] -> /email/sendVerify -> token -> email link -> /email/verify

--- Signing step (mandate) ---
[Web/App]
  |--(3) /sign/requestOtp {docType=MANDATE, session}
  v
[Consent+Mandate Service]
  |-- ensure phone_verified + KYC OK
  |-- create consent draft + mandate draft
  |-- generate SIGN_SMS otp_id
  v
[User receives SIGN OTP]
  |
  |--(4) /sign/confirm {otp_id, code, consentFlags}
  v
[Consent+Mandate Service]
  |-- finalize consents (dual)
  |-- create Mandate active (expires +30d)
  |-- emit ConsentEvent (Cosmos)
  |-- enqueue job: GENERATE_PDF_MANDATE
  v
[Service Bus] -> [Document Service] -> Blob
                   |
                   -> enqueue SIGN_PDF_CERTSIGN
                           |
                           -> enqueue SUBMIT_TO_ANAF
3.3 Pseudo-cod OTP (sigur, auditabil)
function otpRequest(phone, purpose, sessionCtx):
  assert validPhone(phone)
  assert rateLimitOK(phone, purpose, sessionCtx.ip, sessionCtx.device)
  otp = randomDigits(6)
  otpId = uuid()
  otpHash = HMAC_SHA256(KeyVault.pepperOtp, otp + "|" + purpose + "|" + phone)
  saveOtp({
    otpId, phone, purpose,
    otpHash,
    expiresAt: now + 5 minutes,
    attempts: 0,
    used: false,
    ip: sessionCtx.ip,
    deviceHash: sessionCtx.deviceHash
  })
  sms.send(phone, "MoneyShop cod: " + otp + " (valabil 5 min)")
  emitEvent("OTP_REQUESTED", otpId, phone, purpose, sessionCtx)
  return otpId

function otpVerify(otpId, phone, purpose, code, sessionCtx):
  rec = loadOtp(otpId)
  assert rec.used == false
  assert rec.expiresAt > now
  assert rec.phone == phone && rec.purpose == purpose
  assert rec.attempts < 5
  if rec.otpHash == HMAC_SHA256(KeyVault.pepperOtp, code + "|" + purpose + "|" + phone):
     markOtpUsed(otpId)
     emitEvent("OTP_VERIFIED", otpId, phone, purpose, sessionCtx)
     return true
  else:
     incrementAttempts(otpId)
     emitEvent("OTP_FAILED", otpId, phone, purpose, sessionCtx)
     return false
3.4 Best practices (obligatoriu)
•	OTP nu se loghează în clar niciodată
•	max attempts = 5, apoi lock 30 min
•	OTP TTL: 5 min login, 3 min semnare
•	“step-up” dacă IP țară diferită sau device nou
________________________________________
4) Consimțământ DUAL (mandat vs transmitere broker) – implementare
4.1 Checkbox-uri separate (UI)
1.	Mandat ANAF/BC (obligatoriu pentru interogare)
2.	Costuri (obligatoriu)
3.	Transmitere către broker (opțional, implicit OFF)
4.2 Cum se persistă (SQL)
•	consents (tip, text snapshot, doc version, timestamp, ip, userAgent)
•	mandates (tip, status, granted_at, expires_at, revoked_at)
4.3 Event log (Cosmos)
•	CONSENT_GRANTED (include hash-chain)
•	MANDATE_CREATED
•	BROKER_SHARE_GRANTED (doar dacă user bifează opțional)
________________________________________
5) PDF mandate auto-generat (hash + timestamp + audit trail)
5.1 Ce se auto-completează
•	mandate_id (ID unic)
•	subject_id (în loc de CNP)
•	nume complet
•	CNP mascat
•	telefon mascat
•	data/ora + timezone
•	IP + user-agent + device
•	text consimțământ (snapshot exact)
•	expirare mandat (+30 zile)
•	footer: SHA-256 (base64) + consent_event_id
5.2 Folder/Storage (Blob)
•	ms-docs/mandates/YYYY/MM/<mandate_id>.pdf
•	ms-docs/signed/YYYY/MM/<mandate_id>_signed.pdf
•	ms-docs/anaf/YYYY/MM/<request_id>/request.pdf
•	ms-docs/anaf/YYYY/MM/<request_id>/response.json|xml|pdf
•	ms-kyc/... (TTL 30 zile)
5.3 Pseudo-cod PDF + hash
function generateMandatePdf(mandateId, userCtx, consentSnapshot):
  user = SQL.users.get(userCtx.userId)
  subjectId = SQL.subject_map.getOrCreate(user.cnp_hash)
  pdf = Render("mandate_template", {
    mandateId,
    subjectId,
    fullName: user.full_name,
    cnpMasked: mask(user.cnp_last4),
    phoneMasked: maskPhone(user.phone),
    grantedAt: userCtx.timestamp,
    expiresAt: userCtx.timestamp + 30 days,
    ip: userCtx.ip,
    userAgent: userCtx.userAgent,
    device: userCtx.device,
    consentText: consentSnapshot.text
  })

  h = SHA256(pdf.bytes)
  pdf2 = addFooter(pdf, {
    hash: base64(h),
    generatedAt: userCtx.timestampISO,
    consentEventId: userCtx.consentEventId
  })

  url = Blob.put("ms-docs", pathFor(mandateId), pdf2.bytes, metadata={
    "sha256": base64(h),
    "subjectId": subjectId,
    "mandateId": mandateId
  })

  SQL.documents.insert({mandateId, url, sha256: base64(h), createdAt: now})
  return url
________________________________________
6) CertSign – integrare (ce le spui + ce au de făcut)
6.1 Ce e relevant din CertSign (factual)
•	CertSign are soluții de semnare la distanță “Paperless / webSIGN” cu autorizare OTP la semnare. (certSIGN)
•	eIDAS spune efectul juridic pentru semnătura calificată; pentru fluxul tău, CertSign e folosit în principal ca semnătură calificată a firmei pe PDF-urile trimise către ANAF. (EUR-Lex)
6.2 Mesaj către CertSign (copy-paste)
Cere explicit de la CertSign:
1.	API/SDK server-side pentru semnare PDF (PAdES), inclusiv:
o	semnare document / semnare hash (digest)
o	profil recomandat: PAdES Baseline B (minim), ideal T/LT/LTA dacă oferă
2.	Modalitate autentificare aplicație:
o	OAuth2 client credentials / mTLS / signed JWT
3.	Cum se gestionează 2FA/OTP la semnarea remote (dacă certificatul e remote)
4.	Cerințe pentru rulare în backend (fără UI uman)
5.	Cum exportă audit logs/transaction id per semnare
Întrebare cheie: „Putem semna automat, server-to-server, PDF-uri generate de noi, cu certificatul Popix, pentru depunere în SPV/ANAF?”
6.3 Implementare la IT (microserviciu)
•	SignatureService (AKS/AppService)
•	Inputs: pdf_url, profile
•	Outputs: signed_pdf_url, signature_tx_id, hash_before, hash_after
Pseudo-cod:
function signWithCertSign(pdfUrl):
  pdf = Blob.get(pdfUrl)
  digest = SHA256(pdf)
  sig = CertSign.signDigest(digest, profile="PAdES-B-LT")
  signed = Pdf.applySignature(pdf, sig)
  outHash = SHA256(signed)
  outUrl = Blob.put("ms-docs", "signed/...pdf", signed, meta={sha256: base64(outHash)})
  SQL.signatures.insert({pdfUrl, outUrl, txId: sig.txId, hashBefore, hashAfter})
  return outUrl
________________________________________
7) ANAF / SPV integrare (pipeline “robot”)
7.1 Ce există oficial relevant
•	ANAF are pagină de înregistrare pentru API-uri și documentație OAuth pentru integrarea serviciilor expuse (api.anaf.ro). (ANAF)
•	ANAF listează “Servicii Web” (unele sunt registre publice; altele sunt pentru integrare). (ANAF)
•	Există și exemplu public (MFP ANAF ClientSPV) pentru apelare servicii SPV. (GitHub)
7.2 Ce construiește IT (fără presupuneri riscante)
Construiești un ANAF Connector cu 2 moduri:
Mod A: OAuth/API (preferred)
•	registrezi aplicația în portal (în funcție de accesul primit) (ANAF)
•	obții token OAuth
•	faci request către endpoint-urile aprobate
•	stochezi response raw + parsed
Mod B: SPV submission (fallback, dacă așa e canalul acceptat)
•	robotul depune documentul semnat (mandat / cerere) în SPV
•	primește răspuns (message id / atașament)
•	descarcă atașament și parsează
IMPORTANT: IT-ul trebuie să implementeze un “job orchestrator” (Service Bus + worker) astfel încât să poți schimba “Mod A / Mod B” fără să schimbi restul aplicației.
7.3 Orchestrare job (Service Bus)
Queues:
•	q_generate_mandate_pdf
•	q_sign_mandate_pdf
•	q_submit_anaf
•	q_poll_anaf_result
•	q_parse_anaf_result
•	q_update_user_profile
State machine (SQL table anaf_jobs):
•	CREATED -> PDF_READY -> SIGNED -> SUBMITTED -> RESULT_READY -> PARSED -> COMPLETED
________________________________________
8) Data model (SQL + Cosmos) – minim “audit & control”
8.1 SQL tables (nucleu)
•	users
•	user_pii_min (fără CNP clar)
•	subject_map (subject_id, cnp_hash, created_at)
•	kyc_sessions (status, expires_at)
•	kyc_files (blob pointers, expires_at)
•	consents (snapshot text, ip, ua, session)
•	mandates (expires_at + 30d)
•	documents (pdf url, sha256)
•	signatures (txId, hashBefore/After)
•	anaf_jobs (state machine)
•	anaf_income_monthly (date normalizate)
•	bc_summary (dacă ai canal legal)
•	ruleset_versions + rules (configurabil)
•	eligibility_results (output calc)
8.2 Cosmos container (audit events, append-only)
•	consent_events partition /subjectId
•	hash-chain fields: prevHash, thisHash
________________________________________
9) KYC (selfie/documente) + ștergere 30 zile
9.1 Proces
1.	user upload selfie + ID doc
2.	verificare (manuală/automată)
3.	KYC status verified/rejected
4.	fișiere stau în ms-kyc/... cu lifecycle delete 30 zile
5.	în SQL rămâne doar:
o	status
o	timestamp
o	provider transaction id (dacă folosești provider)
o	NU rămân imaginile
9.2 Lifecycle rules
•	Storage lifecycle: delete after 30 days (prefix kyc/)
•	Azure Function daily: curăță kyc_files expirate / marchează deleted_at
________________________________________
10) Calculatoare & motor de eligibilitate (guest vs account)
10.1 Guest calculator (fără cont)
Input minim:
•	venit net (manual)
•	tip credit (nevoi personale / ipotecar / refinanțare)
Output:
•	sumă estimativă + rată estimată
•	disclaimere “orientativ”
NU cere CNP, NU cere date sensibile.
10.2 Advanced calculator (cu cont, manual)
Input:
•	vârstă / DoB (minim)
•	venit net, bonuri masă (dacă vrei)
•	tip credit
•	codebitor (da/nu + venit combinat)
Output:
•	pre-eligibility “intern score” (MoneyShop)
10.3 Auto calculator (după ANAF/BC)
•	ANAF populates venituri lunar
•	BC populates (întârzieri, IFN active, hard inquiries etc.) — doar dacă ai canal legal
•	Rule engine calculează:
o	grad îndatorare
o	praguri (FICO etc.) ca reguli configurabile, versionate
Reguli configurabile (nu hardcode)
Creezi un ruleset cu câmpuri:
•	credit_type
•	amount_range
•	min_income
•	min_fico
•	dti_standard
•	dti_exception
•	effective_from, effective_to
Foarte important: pragurile tale (581/601, 40/50/55%, 5.500/6.500/10.001/13.000, trimestrial) le pui ca reguli “MoneyShop internal policy”, nu le declari ca “regulă bancară universală”.
Insight generator (exemplu cerut de tine)
•	calculează Δ venit:
o	income_sep_2025 - income_aug_2025 = +340
•	output în profil:
o	“Septembrie 2025: +340 lei față de August 2025”
________________________________________
11) UI/UX “super simplu” (18–70 ani)
Principii obligatorii:
•	1 ecran = 1 decizie
•	text mare, butoane mari
•	nu arăți “tehnic” (hash, logs) utilizatorului
•	confirmări clare:
o	“Mandatul e activ 30 zile”
o	“Poți revoca oricând”
•	opționalitatea “share to broker” e vizibilă:
o	toggle OFF by default
o	fără dark patterns
________________________________________
12) Checklist de implementare (pas cu pas, cap-coadă)
Faza 0 – Setup Azure (1–3 zile)
•	VNet + Private Endpoints
•	KeyVault + Managed Identity
•	SQL + Cosmos + Blob + Service Bus
•	Monitor + Defender
Faza 1 – Auth + OTP (web + apps)
•	SMS provider
•	OTP request/verify
•	session tokens
•	device fingerprint hash
Faza 2 – KYC
•	upload blob
•	KYC status
•	lifecycle delete 30d
•	audit events
Faza 3 – Dual consent + mandate
•	UI checkboxes
•	consents table + event stream
•	mandates table + expiry + revoke
Faza 4 – PDF generator + hashing
•	mandate template
•	sha256 stamping
•	storage pathing
•	doc registry SQL
Faza 5 – CertSign signing
•	SignatureService
•	KeyVault secrets
•	PAdES signing
•	store signed pdf + txid
Faza 6 – ANAF pipeline
•	OAuth registration / SPV connector (ANAF)
•	job orchestrator
•	parse responses
•	populate income tables
Faza 7 – Eligibility engine
•	ruleset CRUD (admin backoffice)
•	compute service
•	profile insights
•	calculator guest + advanced
Faza 8 – Broker directory + optional share
•	import list ANPC (public)
•	broker KYC
•	share flow (consent separate)
•	audit logs
Faza 9 – Security hardening
•	WAF rules
•	RLS
•	CMK (optional)
•	pen-test checklist
________________________________________
Ce îți mai trebuie de la tine (pentru IT, fără întrebări inutile)
•	ce stack aleg (Node/.NET), ce mobile (Flutter/RN)
•	provider SMS (Twilio/Vonage/RO)
•	format exact raport ANAF pe care îl primești (PDF/XML/JSON) ca să știe parserul
•	modul legal de acces la date BC (contract/canal)
________________________________________
•  ERD complet (SQL) + colecții Cosmos (tabele + chei + indici)
•  API spec (OpenAPI) pentru toate endpoint-urile: /otp/*, /consent/*, /mandate/*, /docs/*, /anaf/*, /rules/*, /broker/*

Mai jos ai (1) ERD complet pentru Azure SQL + Cosmos collections și (2) OpenAPI spec (YAML) pentru endpoint-urile cerute.
E scris ca să poată echipa ta să înceapă implementarea imediat (tabele, chei, indici, partition keys, TTL, payload-uri).
________________________________________
1) ERD complet – Azure SQL (tabele + chei + indici)
1.1 Convenții
•	Chei primare: UNIQUEIDENTIFIER (UUID)
•	Timestamps: DATETIME2 în UTC
•	CNP: nu se stochează în clar; se stochează:
o	cnp_hash VARBINARY(32) (HMAC-SHA256)
o	subject_id CHAR(19) (ex: MS-ABCDEFGH12345678)
o	cnp_last4 CHAR(4) (opțional)
•	Documente: doar pointers către Blob + hash SHA-256
________________________________________
1.2 ERD (text diagram)
users (1) ──── (1) user_profile
  │
  ├── (1) subject_map
  │
  ├── (1..n) sessions
  │
  ├── (1..n) otp_challenges
  │
  ├── (1..n) consents ──── (n..1) legal_docs
  │
  ├── (1..n) mandates ──── (1..n) documents ──── (0..n) signatures
  │                         │
  │                         └── (0..n) doc_audit_refs
  │
  ├── (0..n) kyc_sessions ──── (0..n) kyc_files
  │
  ├── (0..n) anaf_jobs ──── (0..n) anaf_raw_payloads
  │                         └── (0..n) anaf_income_monthly
  │
  ├── (0..n) bc_jobs  ──── (0..n) bc_raw_payloads
  │                       └── (0..n) bc_summary
  │
  ├── (0..n) eligibility_runs ──── (n..1) ruleset_versions ──── (1..n) rules
  │
  └── (0..n) broker_shares ──── (n..1) brokers ──── (1..1) broker_kyc
________________________________________
1.3 DDL – tabele (cu indici esențiali)
users
CREATE TABLE dbo.users (
  user_id UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID() PRIMARY KEY,
  created_at DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
  status NVARCHAR(20) NOT NULL, -- active/suspended/deleted
  email NVARCHAR(320) NULL,
  phone NVARCHAR(30) NULL,
  email_verified BIT NOT NULL DEFAULT 0,
  phone_verified BIT NOT NULL DEFAULT 0,
  last_login_at DATETIME2 NULL
);

CREATE UNIQUE INDEX ux_users_email ON dbo.users(email) WHERE email IS NOT NULL;
CREATE UNIQUE INDEX ux_users_phone ON dbo.users(phone) WHERE phone IS NOT NULL;
user_profile (PII minim)
CREATE TABLE dbo.user_profile (
  user_id UNIQUEIDENTIFIER NOT NULL PRIMARY KEY,
  full_name NVARCHAR(200) NULL,
  dob DATE NULL,
  address NVARCHAR(400) NULL,
  updated_at DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
  CONSTRAINT fk_profile_user FOREIGN KEY (user_id) REFERENCES dbo.users(user_id)
);
subject_map (pseudonim stabil 5 ani)
CREATE TABLE dbo.subject_map (
  subject_id CHAR(19) NOT NULL PRIMARY KEY, -- "MS-" + 16 chars
  user_id UNIQUEIDENTIFIER NOT NULL UNIQUE,
  cnp_hash VARBINARY(32) NOT NULL,
  cnp_last4 CHAR(4) NULL,
  created_at DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
  CONSTRAINT fk_subject_user FOREIGN KEY (user_id) REFERENCES dbo.users(user_id)
);

CREATE UNIQUE INDEX ux_subject_cnp_hash ON dbo.subject_map(cnp_hash);
sessions
CREATE TABLE dbo.sessions (
  session_id UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID() PRIMARY KEY,
  user_id UNIQUEIDENTIFIER NOT NULL,
  created_at DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
  expires_at DATETIME2 NOT NULL,
  revoked_at DATETIME2 NULL,
  ip NVARCHAR(64) NULL,
  user_agent NVARCHAR(1000) NULL,
  device_hash VARBINARY(32) NULL,
  source_channel NVARCHAR(20) NOT NULL, -- web/ios/android
  CONSTRAINT fk_session_user FOREIGN KEY (user_id) REFERENCES dbo.users(user_id)
);

CREATE INDEX ix_sessions_user ON dbo.sessions(user_id, created_at DESC);
CREATE INDEX ix_sessions_expires ON dbo.sessions(expires_at);
otp_challenges
CREATE TABLE dbo.otp_challenges (
  otp_id UNIQUEIDENTIFIER NOT NULL PRIMARY KEY,
  user_id UNIQUEIDENTIFIER NULL,
  phone NVARCHAR(30) NOT NULL,
  email NVARCHAR(320) NULL,
  purpose NVARCHAR(30) NOT NULL, -- LOGIN_SMS, SIGN_SMS, EMAIL_VERIFY
  otp_hash VARBINARY(32) NOT NULL,
  created_at DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
  expires_at DATETIME2 NOT NULL,
  attempts INT NOT NULL DEFAULT 0,
  used_at DATETIME2 NULL,
  ip NVARCHAR(64) NULL,
  device_hash VARBINARY(32) NULL,
  CONSTRAINT fk_otp_user FOREIGN KEY (user_id) REFERENCES dbo.users(user_id)
);

CREATE INDEX ix_otp_phone_purpose ON dbo.otp_challenges(phone, purpose, created_at DESC);
CREATE INDEX ix_otp_expires ON dbo.otp_challenges(expires_at);
legal_docs (versiuni T&C/GDPR/etc)
CREATE TABLE dbo.legal_docs (
  doc_id UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID() PRIMARY KEY,
  doc_type NVARCHAR(30) NOT NULL, -- TC, GDPR, COOKIES, MANDATE, BROKER_TRANSFER
  version NVARCHAR(20) NOT NULL,
  published_at DATETIME2 NOT NULL,
  content_hash VARBINARY(32) NOT NULL,
  is_active BIT NOT NULL DEFAULT 1
);

CREATE UNIQUE INDEX ux_legal_doc_type_version ON dbo.legal_docs(doc_type, version);
CREATE INDEX ix_legal_doc_active ON dbo.legal_docs(doc_type, is_active);
consents (snapshot text)
CREATE TABLE dbo.consents (
  consent_id UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID() PRIMARY KEY,
  user_id UNIQUEIDENTIFIER NOT NULL,
  consent_type NVARCHAR(60) NOT NULL, -- TC_ACCEPT, GDPR_ACCEPT, MANDATE_ANAF_BC, COSTS_ACCEPT, SHARE_TO_BROKER
  status NVARCHAR(20) NOT NULL DEFAULT 'granted', -- granted/revoked
  granted_at DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
  revoked_at DATETIME2 NULL,
  doc_id UNIQUEIDENTIFIER NULL,
  consent_text_snapshot NVARCHAR(MAX) NOT NULL,
  session_id UNIQUEIDENTIFIER NULL,
  ip NVARCHAR(64) NULL,
  user_agent NVARCHAR(1000) NULL,
  device_hash VARBINARY(32) NULL,
  source_channel NVARCHAR(20) NOT NULL,
  CONSTRAINT fk_consent_user FOREIGN KEY (user_id) REFERENCES dbo.users(user_id),
  CONSTRAINT fk_consent_doc FOREIGN KEY (doc_id) REFERENCES dbo.legal_docs(doc_id),
  CONSTRAINT fk_consent_session FOREIGN KEY (session_id) REFERENCES dbo.sessions(session_id)
);

CREATE INDEX ix_consents_user_type ON dbo.consents(user_id, consent_type, granted_at DESC);
mandates (30 zile)
CREATE TABLE dbo.mandates (
  mandate_id UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID() PRIMARY KEY,
  user_id UNIQUEIDENTIFIER NOT NULL,
  mandate_type NVARCHAR(30) NOT NULL, -- ANAF, BC, ANAF_BC
  scope NVARCHAR(100) NOT NULL DEFAULT 'credit_eligibility_only',
  status NVARCHAR(20) NOT NULL, -- active/expired/revoked
  granted_at DATETIME2 NOT NULL,
  expires_at DATETIME2 NOT NULL,
  revoked_at DATETIME2 NULL,
  revoked_reason NVARCHAR(200) NULL,
  consent_event_id NVARCHAR(64) NULL, -- reference to Cosmos event id
  CONSTRAINT fk_mandate_user FOREIGN KEY (user_id) REFERENCES dbo.users(user_id)
);

CREATE INDEX ix_mandates_user_status ON dbo.mandates(user_id, status, granted_at DESC);
CREATE INDEX ix_mandates_expires ON dbo.mandates(expires_at);
documents (PDF pointers)
CREATE TABLE dbo.documents (
  document_id UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID() PRIMARY KEY,
  user_id UNIQUEIDENTIFIER NOT NULL,
  mandate_id UNIQUEIDENTIFIER NULL,
  doc_kind NVARCHAR(40) NOT NULL, -- MANDATE_PDF, SIGNED_MANDATE_PDF, ANAF_REQUEST, ANAF_RESPONSE, ANALYSIS_PDF
  blob_url NVARCHAR(1000) NOT NULL,
  sha256 VARBINARY(32) NOT NULL,
  created_at DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
  metadata_json NVARCHAR(MAX) NULL,
  CONSTRAINT fk_doc_user FOREIGN KEY (user_id) REFERENCES dbo.users(user_id),
  CONSTRAINT fk_doc_mandate FOREIGN KEY (mandate_id) REFERENCES dbo.mandates(mandate_id)
);

CREATE INDEX ix_docs_user_kind ON dbo.documents(user_id, doc_kind, created_at DESC);
CREATE INDEX ix_docs_mandate ON dbo.documents(mandate_id);
signatures (CertSign tx)
CREATE TABLE dbo.signatures (
  signature_id UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID() PRIMARY KEY,
  document_id UNIQUEIDENTIFIER NOT NULL,
  provider NVARCHAR(40) NOT NULL DEFAULT 'CertSign',
  provider_tx_id NVARCHAR(200) NULL,
  signed_blob_url NVARCHAR(1000) NOT NULL,
  hash_before VARBINARY(32) NOT NULL,
  hash_after VARBINARY(32) NOT NULL,
  signed_at DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
  CONSTRAINT fk_sig_doc FOREIGN KEY (document_id) REFERENCES dbo.documents(document_id)
);

CREATE INDEX ix_sig_doc ON dbo.signatures(document_id);
kyc_sessions, kyc_files (30 zile)
CREATE TABLE dbo.kyc_sessions (
  kyc_id UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID() PRIMARY KEY,
  user_id UNIQUEIDENTIFIER NOT NULL,
  kyc_type NVARCHAR(30) NOT NULL, -- USER_KYC, BROKER_KYC
  status NVARCHAR(20) NOT NULL, -- pending/verified/rejected
  created_at DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
  expires_at DATETIME2 NOT NULL, -- created_at + 30 days
  verified_at DATETIME2 NULL,
  deleted_at DATETIME2 NULL,
  CONSTRAINT fk_kyc_user FOREIGN KEY (user_id) REFERENCES dbo.users(user_id)
);

CREATE INDEX ix_kyc_expires ON dbo.kyc_sessions(expires_at);
CREATE INDEX ix_kyc_user ON dbo.kyc_sessions(user_id, created_at DESC);

CREATE TABLE dbo.kyc_files (
  file_id UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID() PRIMARY KEY,
  kyc_id UNIQUEIDENTIFIER NOT NULL,
  file_type NVARCHAR(30) NOT NULL, -- selfie,id_front,id_back
  blob_url NVARCHAR(1000) NOT NULL,
  created_at DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
  expires_at DATETIME2 NOT NULL,
  CONSTRAINT fk_kyc_file FOREIGN KEY (kyc_id) REFERENCES dbo.kyc_sessions(kyc_id)
);

CREATE INDEX ix_kyc_files_expires ON dbo.kyc_files(expires_at);
anaf_jobs, anaf_raw_payloads, anaf_income_monthly
CREATE TABLE dbo.anaf_jobs (
  job_id UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID() PRIMARY KEY,
  user_id UNIQUEIDENTIFIER NOT NULL,
  mandate_id UNIQUEIDENTIFIER NOT NULL,
  status NVARCHAR(30) NOT NULL, -- CREATED/PDF_READY/SIGNED/SUBMITTED/RESULT_READY/PARSED/COMPLETED/FAILED
  created_at DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
  updated_at DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
  request_doc_id UNIQUEIDENTIFIER NULL,
  response_doc_id UNIQUEIDENTIFIER NULL,
  error_code NVARCHAR(100) NULL,
  error_message NVARCHAR(500) NULL,
  CONSTRAINT fk_anaf_job_user FOREIGN KEY (user_id) REFERENCES dbo.users(user_id),
  CONSTRAINT fk_anaf_job_mandate FOREIGN KEY (mandate_id) REFERENCES dbo.mandates(mandate_id)
);

CREATE INDEX ix_anaf_jobs_user ON dbo.anaf_jobs(user_id, created_at DESC);
CREATE INDEX ix_anaf_jobs_status ON dbo.anaf_jobs(status, updated_at DESC);

CREATE TABLE dbo.anaf_income_monthly (
  income_id UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID() PRIMARY KEY,
  user_id UNIQUEIDENTIFIER NOT NULL,
  year INT NOT NULL,
  month INT NOT NULL,
  net_salary DECIMAL(18,2) NULL,
  meal_vouchers DECIMAL(18,2) NULL,
  source_job_id UNIQUEIDENTIFIER NOT NULL,
  created_at DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
  CONSTRAINT fk_income_user FOREIGN KEY (user_id) REFERENCES dbo.users(user_id),
  CONSTRAINT fk_income_job FOREIGN KEY (source_job_id) REFERENCES dbo.anaf_jobs(job_id)
);

CREATE UNIQUE INDEX ux_income_user_ym ON dbo.anaf_income_monthly(user_id, year, month);
brokers, broker_kyc, broker_shares
CREATE TABLE dbo.brokers (
  broker_id UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID() PRIMARY KEY,
  anpc_registry_id NVARCHAR(120) NULL,
  full_name NVARCHAR(200) NOT NULL,
  firm_name NVARCHAR(200) NULL,
  firm_cui NVARCHAR(50) NULL,
  firm_type NVARCHAR(30) NULL,
  relation_type NVARCHAR(30) NULL, -- legat/nelegat
  affiliation NVARCHAR(50) NULL, -- franciza/independent
  public_email NVARCHAR(320) NULL,
  public_phone NVARCHAR(30) NULL,
  status NVARCHAR(20) NOT NULL DEFAULT 'pending' -- pending/verified/suspended
);

CREATE INDEX ix_brokers_status ON dbo.brokers(status);

CREATE TABLE dbo.broker_kyc (
  broker_id UNIQUEIDENTIFIER NOT NULL PRIMARY KEY,
  kyc_status NVARCHAR(20) NOT NULL,
  verified_at DATETIME2 NULL,
  proof_email_verified BIT NOT NULL DEFAULT 0,
  proof_phone_verified BIT NOT NULL DEFAULT 0,
  notes NVARCHAR(500) NULL,
  CONSTRAINT fk_broker_kyc FOREIGN KEY (broker_id) REFERENCES dbo.brokers(broker_id)
);

CREATE TABLE dbo.broker_shares (
  share_id UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID() PRIMARY KEY,
  user_id UNIQUEIDENTIFIER NOT NULL,
  broker_id UNIQUEIDENTIFIER NOT NULL,
  consent_id UNIQUEIDENTIFIER NOT NULL, -- SHARE_TO_BROKER
  shared_at DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
  payload_type NVARCHAR(30) NOT NULL, -- ANAF_PDF, BC_PDF, ANALYSIS_PDF
  document_id UNIQUEIDENTIFIER NOT NULL,
  status NVARCHAR(20) NOT NULL DEFAULT 'shared',
  CONSTRAINT fk_share_user FOREIGN KEY (user_id) REFERENCES dbo.users(user_id),
  CONSTRAINT fk_share_broker FOREIGN KEY (broker_id) REFERENCES dbo.brokers(broker_id),
  CONSTRAINT fk_share_consent FOREIGN KEY (consent_id) REFERENCES dbo.consents(consent_id),
  CONSTRAINT fk_share_doc FOREIGN KEY (document_id) REFERENCES dbo.documents(document_id)
);

CREATE INDEX ix_shares_user ON dbo.broker_shares(user_id, shared_at DESC);
CREATE INDEX ix_shares_broker ON dbo.broker_shares(broker_id, shared_at DESC);
ruleset_versions, rules, eligibility_runs
CREATE TABLE dbo.ruleset_versions (
  ruleset_id UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID() PRIMARY KEY,
  name NVARCHAR(80) NOT NULL, -- e.g. "moneyshop_v1"
  version NVARCHAR(20) NOT NULL, -- "2025.12"
  status NVARCHAR(20) NOT NULL, -- draft/active/archived
  effective_from DATE NOT NULL,
  effective_to DATE NULL,
  created_at DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME()
);

CREATE UNIQUE INDEX ux_ruleset_name_version ON dbo.ruleset_versions(name, version);

CREATE TABLE dbo.rules (
  rule_id UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID() PRIMARY KEY,
  ruleset_id UNIQUEIDENTIFIER NOT NULL,
  credit_type NVARCHAR(30) NOT NULL, -- PERSONAL/REFI/MORTGAGE
  amount_min DECIMAL(18,2) NULL,
  amount_max DECIMAL(18,2) NULL,
  min_income DECIMAL(18,2) NULL,
  min_fico INT NULL,
  dti_standard DECIMAL(5,2) NOT NULL, -- 40.00, 50.00, 55.00
  dti_exception DECIMAL(5,2) NULL,
  exception_income_threshold DECIMAL(18,2) NULL,
  notes NVARCHAR(300) NULL,
  CONSTRAINT fk_rule_ruleset FOREIGN KEY (ruleset_id) REFERENCES dbo.ruleset_versions(ruleset_id)
);

CREATE INDEX ix_rules_ruleset_type ON dbo.rules(ruleset_id, credit_type);

CREATE TABLE dbo.eligibility_runs (
  run_id UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID() PRIMARY KEY,
  user_id UNIQUEIDENTIFIER NOT NULL,
  ruleset_id UNIQUEIDENTIFIER NOT NULL,
  input_json NVARCHAR(MAX) NOT NULL,
  output_json NVARCHAR(MAX) NOT NULL,
  created_at DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
  CONSTRAINT fk_run_user FOREIGN KEY (user_id) REFERENCES dbo.users(user_id),
  CONSTRAINT fk_run_ruleset FOREIGN KEY (ruleset_id) REFERENCES dbo.ruleset_versions(ruleset_id)
);

CREATE INDEX ix_runs_user ON dbo.eligibility_runs(user_id, created_at DESC);
________________________________________
2) Cosmos DB – colecții (containers) + partition keys + indici + TTL
2.1 Recomandare generală
•	Cosmos DB pentru audit/event stream (append-only)
•	Partition key by /subjectId (sau /userId dacă vrei)
•	TTL enabled:
o	OTP events: 90 zile (opțional)
o	Consent & mandate events: 5 ani (sau fără TTL, depinde de audit)
2.2 Containers
A) consent_events
•	Partition key: /subjectId
•	TTL: OFF (sau 5 ani dacă vrei)
•	Indexing: default + include eventType, timestampUtc
Document exemplu:
{
  "id": "evt_01J...",
  "subjectId": "MS-ABCDEFGH12345678",
  "userId": "uuid",
  "eventType": "CONSENT_GRANTED",
  "consentType": "MANDATE_ANAF_BC",
  "docType": "MANDATE",
  "docVersion": "1.0.0",
  "timestampUtc": "2025-12-28T10:42:18Z",
  "ip": "89.x.x.x",
  "userAgent": "...",
  "device": {"os":"iOS","appVersion":"2.1.4"},
  "proof": {"checkbox": true, "button":"Confirm"},
  "integrity": {"prevHash":"...", "thisHash":"..."}
}
B) security_events
•	Partition key: /subjectId
•	TTL: 365 zile (suficient pentru security analytics)
•	include: login, device_change, rate_limit_trigger, suspicious_ip
C) anaf_events
•	Partition key: /subjectId
•	TTL: OFF/5 ani
•	include: submit, response_received, parse_ok, parse_fail + jobId
D) broker_events
•	Partition key: /brokerId
•	TTL: OFF/5 ani
•	include: broker_kyc_verified, broker_suspended, share_sent
________________________________________
3) OpenAPI spec (YAML) – endpoint-urile cerute
Spec-ul e “complete skeleton”: are routes, request/response, security, erori standard.
Echipa îl poate importa în Swagger / Postman și genera client SDK.
openapi: 3.0.3
info:
  title: MoneyShop API
  version: 1.0.0
  description: Core API for OTP, Consents, Mandates, Documents, ANAF pipeline, Rules Engine, Brokers.

servers:
  - url: https://api.moneyshop.ro/v1

security:
  - bearerAuth: []

tags:
  - name: otp
  - name: consent
  - name: mandate
  - name: docs
  - name: anaf
  - name: rules
  - name: broker

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

  schemas:
    ErrorResponse:
      type: object
      properties:
        code: { type: string }
        message: { type: string }
        details: { type: object, additionalProperties: true }
      required: [code, message]

    OtpRequest:
      type: object
      properties:
        phone: { type: string, example: "+40712345678" }
        purpose:
          type: string
          enum: [LOGIN_SMS, SIGN_SMS, EMAIL_VERIFY, STEP_UP_SECURITY]
        channel:
          type: string
          enum: [sms, email]
          default: sms
      required: [phone, purpose]

    OtpRequestResponse:
      type: object
      properties:
        otpId: { type: string, format: uuid }
        expiresInSeconds: { type: integer, example: 300 }
      required: [otpId, expiresInSeconds]

    OtpVerify:
      type: object
      properties:
        otpId: { type: string, format: uuid }
        code: { type: string, example: "123456" }
        phone: { type: string, example: "+40712345678" }
        purpose:
          type: string
          enum: [LOGIN_SMS, SIGN_SMS, EMAIL_VERIFY, STEP_UP_SECURITY]
      required: [otpId, code, phone, purpose]

    SessionResponse:
      type: object
      properties:
        accessToken: { type: string }
        refreshToken: { type: string }
        expiresInSeconds: { type: integer, example: 3600 }
      required: [accessToken, expiresInSeconds]

    ConsentGrant:
      type: object
      properties:
        consentType:
          type: string
          enum: [TC_ACCEPT, GDPR_ACCEPT, MANDATE_ANAF_BC, COSTS_ACCEPT, SHARE_TO_BROKER]
        docType:
          type: string
          enum: [TC, GDPR, COOKIES, MANDATE, BROKER_TRANSFER]
        docVersion: { type: string, example: "1.0.0" }
        consentTextSnapshot: { type: string }
        sessionId: { type: string, format: uuid }
        sourceChannel:
          type: string
          enum: [web, ios, android]
      required: [consentType, docType, docVersion, consentTextSnapshot, sourceChannel]

    ConsentResponse:
      type: object
      properties:
        consentId: { type: string, format: uuid }
        status: { type: string, enum: [granted, revoked] }
        grantedAt: { type: string, format: date-time }
      required: [consentId, status, grantedAt]

    MandateCreate:
      type: object
      properties:
        mandateType:
          type: string
          enum: [ANAF, BC, ANAF_BC]
        consentEventId:
          type: string
          description: Cosmos consent event id reference
        expiresInDays:
          type: integer
          example: 30
      required: [mandateType]

    MandateResponse:
      type: object
      properties:
        mandateId: { type: string, format: uuid }
        status: { type: string, enum: [active, expired, revoked] }
        grantedAt: { type: string, format: date-time }
        expiresAt: { type: string, format: date-time }
      required: [mandateId, status, grantedAt, expiresAt]

    DocumentResponse:
      type: object
      properties:
        documentId: { type: string, format: uuid }
        docKind: { type: string }
        blobUrl: { type: string }
        sha256Base64: { type: string }
        createdAt: { type: string, format: date-time }
      required: [documentId, docKind, blobUrl, sha256Base64, createdAt]

    AnafJobCreate:
      type: object
      properties:
        mandateId: { type: string, format: uuid }
        mode:
          type: string
          enum: [OAUTH_API, SPV_SUBMISSION]
        includePdfMandate:
          type: boolean
          default: true
      required: [mandateId, mode]

    AnafJobResponse:
      type: object
      properties:
        jobId: { type: string, format: uuid }
        status:
          type: string
          enum: [CREATED, PDF_READY, SIGNED, SUBMITTED, RESULT_READY, PARSED, COMPLETED, FAILED]
        createdAt: { type: string, format: date-time }
        updatedAt: { type: string, format: date-time }
      required: [jobId, status, createdAt, updatedAt]

    RuleSetCreate:
      type: object
      properties:
        name: { type: string, example: "moneyshop" }
        version: { type: string, example: "2025.12" }
        status: { type: string, enum: [draft, active, archived] }
        effectiveFrom: { type: string, format: date }
        effectiveTo: { type: string, format: date, nullable: true }
      required: [name, version, status, effectiveFrom]

    RuleCreate:
      type: object
      properties:
        creditType: { type: string, enum: [PERSONAL, REFI, MORTGAGE] }
        amountMin: { type: number, nullable: true }
        amountMax: { type: number, nullable: true }
        minIncome: { type: number, nullable: true }
        minFico: { type: integer, nullable: true }
        dtiStandard: { type: number }
        dtiException: { type: number, nullable: true }
        exceptionIncomeThreshold: { type: number, nullable: true }
        notes: { type: string, nullable: true }
      required: [creditType, dtiStandard]

    EligibilityRunRequest:
      type: object
      properties:
        rulesetId: { type: string, format: uuid }
        input:
          type: object
          additionalProperties: true
      required: [rulesetId, input]

    EligibilityRunResponse:
      type: object
      properties:
        runId: { type: string, format: uuid }
        output:
          type: object
          additionalProperties: true
        createdAt: { type: string, format: date-time }
      required: [runId, output, createdAt]

    BrokerSearchResponse:
      type: object
      properties:
        brokers:
          type: array
          items:
            type: object
            properties:
              brokerId: { type: string, format: uuid }
              fullName: { type: string }
              firmName: { type: string, nullable: true }
              status: { type: string }
            required: [brokerId, fullName, status]
      required: [brokers]

paths:
  /otp/request:
    post:
      tags: [otp]
      security: []
      summary: Request OTP (SMS/email)
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/OtpRequest" }
      responses:
        "200":
          description: OTP created
          content:
            application/json:
              schema: { $ref: "#/components/schemas/OtpRequestResponse" }
        "400":
          description: Invalid request
          content:
            application/json:
              schema: { $ref: "#/components/schemas/ErrorResponse" }

  /otp/verify:
    post:
      tags: [otp]
      security: []
      summary: Verify OTP and issue session token (for login flows)
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/OtpVerify" }
      responses:
        "200":
          description: Session issued
          content:
            application/json:
              schema: { $ref: "#/components/schemas/SessionResponse" }
        "401":
          description: OTP invalid/expired
          content:
            application/json:
              schema: { $ref: "#/components/schemas/ErrorResponse" }

  /consent/grant:
    post:
      tags: [consent]
      summary: Grant a consent with snapshot text
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/ConsentGrant" }
      responses:
        "200":
          description: Consent granted
          content:
            application/json:
              schema: { $ref: "#/components/schemas/ConsentResponse" }

  /consent/list:
    get:
      tags: [consent]
      summary: List consents for current user
      responses:
        "200":
          description: List consents
          content:
            application/json:
              schema:
                type: object
                properties:
                  consents:
                    type: array
                    items: { $ref: "#/components/schemas/ConsentResponse" }
                required: [consents]

  /consent/revoke/{consentId}:
    post:
      tags: [consent]
      summary: Revoke a consent (future effect)
      parameters:
        - name: consentId
          in: path
          required: true
          schema: { type: string, format: uuid }
      responses:
        "200":
          description: Revoked
          content:
            application/json:
              schema: { $ref: "#/components/schemas/ConsentResponse" }

  /mandate/create:
    post:
      tags: [mandate]
      summary: Create mandate (expires in 30 days)
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/MandateCreate" }
      responses:
        "200":
          description: Mandate created
          content:
            application/json:
              schema: { $ref: "#/components/schemas/MandateResponse" }

  /mandate/get/{mandateId}:
    get:
      tags: [mandate]
      summary: Get mandate details
      parameters:
        - name: mandateId
          in: path
          required: true
          schema: { type: string, format: uuid }
      responses:
        "200":
          description: Mandate details
          content:
            application/json:
              schema: { $ref: "#/components/schemas/MandateResponse" }

  /mandate/revoke/{mandateId}:
    post:
      tags: [mandate]
      summary: Revoke mandate
      parameters:
        - name: mandateId
          in: path
          required: true
          schema: { type: string, format: uuid }
      requestBody:
        required: false
        content:
          application/json:
            schema:
              type: object
              properties:
                reason: { type: string }
      responses:
        "200":
          description: Mandate revoked
          content:
            application/json:
              schema: { $ref: "#/components/schemas/MandateResponse" }

  /docs/generate/mandate/{mandateId}:
    post:
      tags: [docs]
      summary: Generate mandate PDF and store in Blob
      parameters:
        - name: mandateId
          in: path
          required: true
          schema: { type: string, format: uuid }
      responses:
        "200":
          description: Document created
          content:
            application/json:
              schema: { $ref: "#/components/schemas/DocumentResponse" }

  /docs/sign/{documentId}:
    post:
      tags: [docs]
      summary: Sign a PDF document using CertSign (PAdES)
      parameters:
        - name: documentId
          in: path
          required: true
          schema: { type: string, format: uuid }
      responses:
        "200":
          description: Signed document created
          content:
            application/json:
              schema: { $ref: "#/components/schemas/DocumentResponse" }

  /docs/list:
    get:
      tags: [docs]
      summary: List documents for current user
      parameters:
        - name: kind
          in: query
          required: false
          schema: { type: string }
      responses:
        "200":
          description: Documents list
          content:
            application/json:
              schema:
                type: object
                properties:
                  documents:
                    type: array
                    items: { $ref: "#/components/schemas/DocumentResponse" }
                required: [documents]

  /anaf/job/create:
    post:
      tags: [anaf]
      summary: Create ANAF job (OAUTH_API or SPV_SUBMISSION)
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/AnafJobCreate" }
      responses:
        "200":
          description: Job created
          content:
            application/json:
              schema: { $ref: "#/components/schemas/AnafJobResponse" }

  /anaf/job/{jobId}:
    get:
      tags: [anaf]
      summary: Get ANAF job status
      parameters:
        - name: jobId
          in: path
          required: true
          schema: { type: string, format: uuid }
      responses:
        "200":
          description: Job status
          content:
            application/json:
              schema: { $ref: "#/components/schemas/AnafJobResponse" }

  /anaf/income/monthly:
    get:
      tags: [anaf]
      summary: Get normalized monthly income (from ANAF)
      parameters:
        - name: year
          in: query
          required: false
          schema: { type: integer }
      responses:
        "200":
          description: Monthly incomes
          content:
            application/json:
              schema:
                type: object
                properties:
                  items:
                    type: array
                    items:
                      type: object
                      properties:
                        year: { type: integer }
                        month: { type: integer }
                        netSalary: { type: number }
                        mealVouchers: { type: number, nullable: true }
                  insights:
                    type: object
                    additionalProperties: true
                required: [items]

  /rules/ruleset/create:
    post:
      tags: [rules]
      summary: Create ruleset version
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/RuleSetCreate" }
      responses:
        "200":
          description: Ruleset created
          content:
            application/json:
              schema:
                type: object
                properties:
                  rulesetId: { type: string, format: uuid }
                required: [rulesetId]

  /rules/{rulesetId}/rule/add:
    post:
      tags: [rules]
      summary: Add rule to ruleset
      parameters:
        - name: rulesetId
          in: path
          required: true
          schema: { type: string, format: uuid }
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/RuleCreate" }
      responses:
        "200":
          description: Rule created
          content:
            application/json:
              schema:
                type: object
                properties:
                  ruleId: { type: string, format: uuid }
                required: [ruleId]

  /rules/eligibility/run:
    post:
      tags: [rules]
      summary: Run eligibility analysis using a ruleset
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/EligibilityRunRequest" }
      responses:
        "200":
          description: Eligibility result
          content:
            application/json:
              schema: { $ref: "#/components/schemas/EligibilityRunResponse" }

  /broker/search:
    get:
      tags: [broker]
      summary: Search brokers (ANPC public list + verified)
      parameters:
        - name: q
          in: query
          required: false
          schema: { type: string }
      responses:
        "200":
          description: Brokers
          content:
            application/json:
              schema: { $ref: "#/components/schemas/BrokerSearchResponse" }

  /broker/share:
    post:
      tags: [broker]
      summary: Share documents to a broker (requires SHARE_TO_BROKER consent)
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                brokerId: { type: string, format: uuid }
                payloadTypes:
                  type: array
                  items:
                    type: string
                    enum: [ANAF_PDF, BC_PDF, ANALYSIS_PDF]
              required: [brokerId, payloadTypes]
      responses:
        "200":
          description: Share created
          content:
            application/json:
              schema:
                type: object
                properties:
                  shareIds:
                    type: array
                    items: { type: string, format: uuid }
                required: [shareIds]
________________________________________
Dacă vrei „next-level” (util pentru echipă)
Îți pot livra și:
1.	ERD desenat (diagramă) + export în format draw.io / Lucidchart
2.	SQL migration scripts pe module (auth, consents, mandates, docs, anaf, brokers, rules)
3.	OpenAPI completat cu examples (request/response pentru toate endpoint-urile) + pagination + rate-limit headers
Spune-mi doar ce stack folosiți la backend (.NET sau Node) și ce mobile (Flutter sau React Native), ca să-ți pun și naming conventions + middlewares exacte pentru autentificare și logging.


