PROIECT SBD - MONEYSHOP
Student: Cristea Eduard
Grupa: 505

DOCUMENT COMPLET PROIECT

1. PREZENTAREA PROIECTULUI

MoneyShop este o platforma de brokeraj de credite care permite utilizatorilor sa aplice pentru credite prin intermediul unor brokeri autorizati. Sistemul gestioneaza aplicatiile, documentele, consimtamanturile si mandatele intre utilizatori si brokeri.

2. DIAGRAMA ENTITATE-RELATIE (ERD)

Diagrama ERD completa:

    ROLURI                    UTILIZATORI
    +----------+              +------------------+
    | IdRol PK |              | IdUtilizator PK  |
    | NumeRol  |<----(1:N)----| IdRol FK         |
    | Descriere|              | Nume             |
    | CreatedAt|              | Prenume          |
    +----------+              | Username         |
                              | Email            |
                              | Parola           |
                              | DataNastere      |
                              | ...              |
                              +------------------+
                                      |
                                      | (1:N)
                                      |
                              +------------------+
                              | APLICATII        |
                              | Id PK            |
                              | UserId FK        |
                              | Status           |
                              | TypeCredit       |
                              | Scoring          |
                              | ...              |
                              +------------------+
                                      |
                    +------------------+------------------+
                    | (1:N)            | (N:M)            |
                    |                  |                  |
            +------------------+  +------------------+  +------------------+
            | DOCUMENTE        |  | APPLICATION_BANKS|  | BANCI            |
            | Id PK            |  | Id PK            |  | Id PK            |
            | ApplicationId FK |  | ApplicationId FK |  | Name             |
            | TipDocument      |  | BankId FK        |  | CommissionPercent|
            | ...              |  | Status           |  | Active           |
            +------------------+  +------------------+  +------------------+

    UTILIZATORI (1) ----< (N) CONSENTURI
    +------------------+              +------------------+
    | IdUtilizator PK  |              | Id PK            |
    | ...              |<----(1:N)----| UserId FK        |
    +------------------+              | TipConsent       |
                                      | Status           |
                                      | ...              |
                                      +------------------+

    UTILIZATORI (Client) ----< (N) MANDATE (N) >---- (1) UTILIZATORI (Broker)
    +------------------+              +------------------+              +------------------+
    | IdUtilizator PK  |              | Id PK            |              | IdUtilizator PK  |
    | ...              |<----(1:N)----| UserId FK        |              | ...              |
    +------------------+              | BrokerId FK      |----(N:1)---->| (Broker)         |
                                      | Status           |              +------------------+
                                      | DataMandat       |
                                      | ...              |
                                      +------------------+

    MESAJE
    +------------------+
    | cod_mesaj PK     |
    | mesaj            |
    | tip_mesaj        |
    | creat_de         |
    | creat_la         |
    +------------------+

3. SCHEMA RELATIONALA SI CODUL SQL PENTRU CREAREA TABELELOR

ROLURI (IdRol PK, NumeRol, Descriere, CreatedAt)
UTILIZATORI (IdUtilizator PK, Nume, Prenume, Username, Email, Parola, NumarTelefon, EmailVerified, PhoneVerified, DataNastere, IdRol FK, IsDeleted, CreatedAt, UpdatedAt)
BANCI (Id PK, Name, CommissionPercent, Active, CreatedAt)
APLICATII (Id PK, UserId FK, Status, TypeCredit, TipOperatiune, SalariuNet, Scoring, Dti, SumaAprobata, Comision, CreatedAt, UpdatedAt)
APPLICATION_BANKS (Id PK, ApplicationId FK, BankId FK, Status, CreatedAt)
DOCUMENTE (Id PK, ApplicationId FK, TipDocument, NumeFisier, Path, SizeBytes, MimeType, CreatedAt)
CONSENTURI (Id PK, UserId FK, TipConsent, Status, DataConsent, DataExpirare, IpAddress, CreatedAt)
MANDATE (Id PK, UserId FK, BrokerId FK, Status, DataMandat, DataExpirare, CreatedAt)
MESAJE (cod_mesaj PK, mesaj, tip_mesaj, creat_de, creat_la)

CODUL SQL PENTRU CREAREA TABELELOR:

SET SERVEROUTPUT ON;
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
ALTER SESSION SET NLS_TIMESTAMP_FORMAT = 'YYYY-MM-DD HH24:MI:SS.FF';

CREATE TABLE ROLURI (
IdRol NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
NumeRol VARCHAR2(50) NOT NULL UNIQUE,
Descriere VARCHAR2(500),
CreatedAt TIMESTAMP DEFAULT SYSTIMESTAMP,
CONSTRAINT chk_nume_rol CHECK (NumeRol IN ('CLIENT', 'BROKER', 'ADMIN'))
);

CREATE TABLE UTILIZATORI (
IdUtilizator NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
Nume VARCHAR2(100) NOT NULL,
Prenume VARCHAR2(100) NOT NULL,
Username VARCHAR2(50) NOT NULL UNIQUE,
Email VARCHAR2(255) NOT NULL UNIQUE,
Parola VARCHAR2(255) NOT NULL,
NumarTelefon VARCHAR2(20),
EmailVerified NUMBER(1) DEFAULT 0,
PhoneVerified NUMBER(1) DEFAULT 0,
DataNastere DATE NOT NULL,
IdRol NUMBER NOT NULL,
IsDeleted NUMBER(1) DEFAULT 0,
CreatedAt TIMESTAMP DEFAULT SYSTIMESTAMP,
UpdatedAt TIMESTAMP DEFAULT SYSTIMESTAMP,
CONSTRAINT chk_email_verified CHECK (EmailVerified IN (0, 1)),
CONSTRAINT chk_phone_verified CHECK (PhoneVerified IN (0, 1)),
CONSTRAINT chk_is_deleted CHECK (IsDeleted IN (0, 1)),
CONSTRAINT fk_utilizatori_rol FOREIGN KEY (IdRol) REFERENCES ROLURI(IdRol),
CONSTRAINT chk_email_format CHECK (REGEXP_LIKE(Email, '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$')),
CONSTRAINT chk_telefon_format CHECK (NumarTelefon IS NULL OR REGEXP_LIKE(NumarTelefon, '^[0-9]{10}$'))
);

CREATE TABLE BANCI (
Id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
Name VARCHAR2(200) NOT NULL UNIQUE,
CommissionPercent NUMBER(5,2) NOT NULL,
Active NUMBER(1) DEFAULT 1,
CreatedAt TIMESTAMP DEFAULT SYSTIMESTAMP,
CONSTRAINT chk_commission CHECK (CommissionPercent BETWEEN 0 AND 100),
CONSTRAINT chk_bank_active CHECK (Active IN (0, 1))
);

CREATE TABLE APLICATII (
Id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
UserId NUMBER NOT NULL,
Status VARCHAR2(50) DEFAULT 'INREGISTRAT' NOT NULL,
TypeCredit VARCHAR2(50),
TipOperatiune VARCHAR2(50),
SalariuNet NUMBER(18,2),
BonuriMasa NUMBER(1),
SumaBonuriMasa NUMBER(18,2),
VechimeLuni NUMBER,
NrCrediteBanci NUMBER,
ListaBanciActive CLOB,
NrIfn NUMBER,
Poprire NUMBER(1),
SoldTotal NUMBER(18,2),
Intarzieri NUMBER(1),
IntarzieriNumar NUMBER,
CardCredit CLOB,
Overdraft CLOB,
Codebitori CLOB,
Scoring NUMBER(5,2),
Dti NUMBER(5,2),
RecommendedLevel VARCHAR2(50),
SumaAprobata NUMBER(18,2),
Comision NUMBER(18,2),
DataDisbursare TIMESTAMP,
CreatedAt TIMESTAMP DEFAULT SYSTIMESTAMP,
UpdatedAt TIMESTAMP DEFAULT SYSTIMESTAMP,
CONSTRAINT fk_aplicatii_user FOREIGN KEY (UserId) REFERENCES UTILIZATORI(IdUtilizator),
CONSTRAINT chk_status CHECK (Status IN ('INREGISTRAT', 'IN_PROCESARE', 'APROBAT', 'REFUZAT', 'ANULAT')),
CONSTRAINT chk_type_credit CHECK (TypeCredit IS NULL OR TypeCredit IN ('IPOTECAR', 'NEVOI_PERSONALE', 'REFINANTARE')),
CONSTRAINT chk_tip_operatiune CHECK (TipOperatiune IS NULL OR TipOperatiune IN ('NOU', 'REFINANTARE')),
CONSTRAINT chk_scoring CHECK (Scoring IS NULL OR Scoring BETWEEN 300 AND 850),
CONSTRAINT chk_dti CHECK (Dti IS NULL OR Dti BETWEEN 0 AND 100),
CONSTRAINT chk_salariu CHECK (SalariuNet IS NULL OR SalariuNet >= 0),
CONSTRAINT chk_bonuri_masa CHECK (BonuriMasa IS NULL OR BonuriMasa IN (0, 1)),
CONSTRAINT chk_poprire CHECK (Poprire IS NULL OR Poprire IN (0, 1)),
CONSTRAINT chk_intarzieri CHECK (Intarzieri IS NULL OR Intarzieri IN (0, 1))
);

CREATE TABLE APPLICATION_BANKS (
Id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
ApplicationId NUMBER NOT NULL,
BankId NUMBER NOT NULL,
Status VARCHAR2(50) DEFAULT 'PENDING',
CreatedAt TIMESTAMP DEFAULT SYSTIMESTAMP,
CONSTRAINT fk_app_banks_app FOREIGN KEY (ApplicationId) REFERENCES APLICATII(Id) ON DELETE CASCADE,
CONSTRAINT fk_app_banks_bank FOREIGN KEY (BankId) REFERENCES BANCI(Id),
CONSTRAINT uk_app_bank UNIQUE (ApplicationId, BankId),
CONSTRAINT chk_app_bank_status CHECK (Status IN ('PENDING', 'APPROVED', 'REJECTED', 'CANCELLED'))
);

CREATE TABLE DOCUMENTE (
Id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
ApplicationId NUMBER NOT NULL,
TipDocument VARCHAR2(50) NOT NULL,
NumeFisier VARCHAR2(255) NOT NULL,
Path VARCHAR2(1000) NOT NULL,
SizeBytes NUMBER NOT NULL,
MimeType VARCHAR2(100),
CreatedAt TIMESTAMP DEFAULT SYSTIMESTAMP,
CONSTRAINT fk_documente_app FOREIGN KEY (ApplicationId) REFERENCES APLICATII(Id) ON DELETE CASCADE,
CONSTRAINT chk_tip_document CHECK (TipDocument IN ('CI', 'FLUTURAS', 'EXTRAS_CONT', 'CONTRACT', 'ALTUL')),
CONSTRAINT chk_size_bytes CHECK (SizeBytes > 0)
);

CREATE TABLE CONSENTURI (
Id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
UserId NUMBER NOT NULL,
TipConsent VARCHAR2(50) NOT NULL,
Status VARCHAR2(50) DEFAULT 'ACTIV',
DataConsent TIMESTAMP DEFAULT SYSTIMESTAMP,
DataExpirare TIMESTAMP,
IpAddress VARCHAR2(45),
CreatedAt TIMESTAMP DEFAULT SYSTIMESTAMP,
CONSTRAINT fk_consenturi_user FOREIGN KEY (UserId) REFERENCES UTILIZATORI(IdUtilizator) ON DELETE CASCADE,
CONSTRAINT chk_tip_consent CHECK (TipConsent IN ('PROCESARE_DATE', 'MARKETING', 'COMUNICARE_BANCI')),
CONSTRAINT chk_consent_status CHECK (Status IN ('ACTIV', 'EXPIRAT', 'REVOCAT'))
);

CREATE TABLE MANDATE (
Id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
UserId NUMBER NOT NULL,
BrokerId NUMBER NOT NULL,
Status VARCHAR2(50) DEFAULT 'ACTIV',
DataMandat TIMESTAMP DEFAULT SYSTIMESTAMP,
DataExpirare TIMESTAMP,
CreatedAt TIMESTAMP DEFAULT SYSTIMESTAMP,
CONSTRAINT fk_mandate_user FOREIGN KEY (UserId) REFERENCES UTILIZATORI(IdUtilizator) ON DELETE CASCADE,
CONSTRAINT fk_mandate_broker FOREIGN KEY (BrokerId) REFERENCES UTILIZATORI(IdUtilizator),
CONSTRAINT chk_mandate_status CHECK (Status IN ('ACTIV', 'EXPIRAT', 'REVOCAT')),
CONSTRAINT chk_mandate_expirare CHECK (DataExpirare IS NULL OR DataExpirare > DataMandat)
);

CREATE TABLE MESAJE (
cod_mesaj NUMBER PRIMARY KEY,
mesaj VARCHAR2(255) NOT NULL,
tip_mesaj VARCHAR2(1) NOT NULL,
creat_de VARCHAR2(40) NOT NULL,
creat_la DATE NOT NULL,
CONSTRAINT chk_tip_mesaj CHECK (tip_mesaj IN ('E', 'W', 'I'))
);

CREATE SEQUENCE seq_mesaje
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE INDEX idx_applications_userid ON APLICATII(UserId);
CREATE INDEX idx_applications_status ON APLICATII(Status);
CREATE INDEX idx_applications_created ON APLICATII(CreatedAt);
CREATE INDEX idx_documents_applicationid ON DOCUMENTE(ApplicationId);
CREATE INDEX idx_consenturi_userid ON CONSENTURI(UserId);
CREATE INDEX idx_consenturi_status ON CONSENTURI(Status);
CREATE INDEX idx_mandate_userid ON MANDATE(UserId);
CREATE INDEX idx_mandate_brokerid ON MANDATE(BrokerId);
CREATE INDEX idx_mandate_status ON MANDATE(Status);
CREATE INDEX idx_utilizatori_idrol ON UTILIZATORI(IdRol);

4. NORMALIZARE FN1 -> FN2 -> FN3

4.1 Atribut Repetitiv
Problema: In tabelul APLICATII exista atributul ListaBanciActive de tip CLOB care stocheaza un JSON array.
Solutie: Atributul repetitiv a fost eliminat prin crearea tabelului asociativ APPLICATION_BANKS.

4.2 Exemplu FN1 -> FN2
Tabel APLICATII_TEMP_FN1 contine dependente functionale partiale:
- NumeUtilizator, PrenumeUtilizator, EmailUtilizator depind de UserId, nu de Id
Solutie: Aceste atribute au fost mutate in tabelul UTILIZATORI, iar APLICATII_TEMP_FN2 referentiaza doar UserId.

4.3 Exemplu FN2 -> FN3
Tabel APLICATII_TEMP_FN2_TRANZ contine dependente functionale tranzitive:
- NumeBanca si CommissionPercent depind de IdBanca
- IdBanca depinde de Id (prin relatie)
Solutie: Datele bancii au fost mutate in tabelul BANCI, iar asocierea este in APPLICATION_BANKS_TEMP_FN3.

4.4 Verificare
Toate tabelele existente sunt in FN3:
- ROLURI, UTILIZATORI, BANCI, APLICATII, APPLICATION_BANKS, DOCUMENTE, CONSENTURI, MANDATE, MESAJE

5. INTEROGARI SQL

Au fost implementate 15 interogari SQL complexe care acopera toate cerintele:

INTEROGAREA 1: GROUP BY, HAVING, functii agregat
Enunt: Afisati bancile care au procesat mai mult de 5 aplicatii aprobate, impreuna cu numarul total de aplicatii, suma totala aprobata si comisionul mediu

SELECT 
    b.Name AS Banca,
    COUNT(ab.ApplicationId) AS NumarAplicatii,
    SUM(a.SumaAprobata) AS SumaTotalaAprobata,
    AVG(a.Comision) AS ComisionMediu,
    MAX(a.Scoring) AS ScoringMaxim
FROM BANCI b
INNER JOIN APPLICATION_BANKS ab ON b.Id = ab.BankId
INNER JOIN APLICATII a ON ab.ApplicationId = a.Id
WHERE a.Status = 'APROBAT'
GROUP BY b.Name
HAVING COUNT(ab.ApplicationId) > 5
ORDER BY SumaTotalaAprobata DESC;

INTEROGAREA 2: Functii siruri de caractere (LOWER, UPPER, SUBSTR, INSTR)
Enunt: Afisati utilizatorii cu email-ul formatat (numele domeniului in majuscule, restul in minuscule) si primele 3 caractere din nume

SELECT 
    UPPER(SUBSTR(Email, INSTR(Email, '@') + 1)) AS DomeniuMajuscule,
    LOWER(SUBSTR(Email, 1, INSTR(Email, '@') - 1)) AS PrefixMinuscule,
    SUBSTR(Nume, 1, 3) AS PrimeleTreiCaractere,
    Nume || ' ' || Prenume AS NumeComplet
FROM UTILIZATORI
WHERE Email IS NOT NULL
ORDER BY Nume;

INTEROGAREA 3: Functii date (TO_CHAR, TO_DATE, ADD_MONTHS, MONTHS_BETWEEN)
Enunt: Afisati aplicatiile create in ultimele 6 luni, cu data formata si numarul de luni de la creare

SELECT 
    a.Id AS IdAplicatie,
    TO_CHAR(a.CreatedAt, 'DD-MM-YYYY HH24:MI:SS') AS DataFormatata,
    TO_CHAR(a.CreatedAt, 'MONTH YYYY', 'NLS_DATE_LANGUAGE=ROMANIAN') AS LunaAn,
    MONTHS_BETWEEN(SYSDATE, a.CreatedAt) AS LuniDeLaCreare,
    ADD_MONTHS(a.CreatedAt, 6) AS DataExpirareEstimata,
    u.Nume || ' ' || u.Prenume AS Utilizator
FROM APLICATII a
INNER JOIN UTILIZATORI u ON a.UserId = u.IdUtilizator
WHERE a.CreatedAt >= ADD_MONTHS(SYSDATE, -6)
ORDER BY a.CreatedAt DESC;

INTEROGAREA 4: Functii diverse (DECODE, NVL, NULLIF, CASE)
Enunt: Afisati aplicatiile cu statusul tradus in romana, scoring-ul normalizat si tipul de credit cu DECODE si CASE

SELECT 
    a.Id,
    DECODE(a.Status, 
        'INREGISTRAT', 'Inregistrat',
        'IN_PROCESARE', 'In procesare',
        'APROBAT', 'Aprobat',
        'REFUZAT', 'Refuzat',
        'ANULAT', 'Anulat',
        'Necunoscut') AS StatusRomana,
    CASE 
        WHEN a.Scoring IS NULL THEN 'Fara scoring'
        WHEN a.Scoring >= 700 THEN 'Scoring bun'
        WHEN a.Scoring >= 600 THEN 'Scoring mediu'
        ELSE 'Scoring slab'
    END AS CategorieScoring,
    NVL(TO_CHAR(a.SumaAprobata), 'N/A') AS SumaAprobata,
    NULLIF(a.Dti, 0) AS DtiNonZero,
    a.TypeCredit
FROM APLICATII a
ORDER BY a.Id;

INTEROGAREA 5: INNER JOIN cu subinterogare in WHERE
Enunt: Afisati utilizatorii care au aplicatii cu scoring mai mare decat media tuturor aplicatiilor aprobate

SELECT 
    u.IdUtilizator,
    u.Nume || ' ' || u.Prenume AS NumeComplet,
    u.Email,
    a.Scoring,
    a.SumaAprobata
FROM UTILIZATORI u
INNER JOIN APLICATII a ON u.IdUtilizator = a.UserId
WHERE a.Scoring > (
    SELECT AVG(Scoring)
    FROM APLICATII
    WHERE Status = 'APROBAT' AND Scoring IS NOT NULL
)
AND a.Status = 'APROBAT'
ORDER BY a.Scoring DESC;

INTEROGAREA 6: LEFT JOIN cu functii agregat
Enunt: Afisati toti utilizatorii si numarul de aplicatii pentru fiecare, inclusiv cei fara aplicatii

SELECT 
    u.IdUtilizator,
    u.Nume || ' ' || u.Prenume AS NumeComplet,
    COUNT(a.Id) AS NumarAplicatii,
    SUM(NVL(a.SumaAprobata, 0)) AS SumaTotalaAprobata,
    AVG(a.Scoring) AS ScoringMediu
FROM UTILIZATORI u
LEFT JOIN APLICATII a ON u.IdUtilizator = a.UserId
WHERE u.IsDeleted = 0
GROUP BY u.IdUtilizator, u.Nume, u.Prenume
ORDER BY NumarAplicatii DESC;

INTEROGAREA 7: RIGHT JOIN cu GROUP BY si HAVING
Enunt: Afisati toate bancile si numarul de aplicatii asociate, inclusiv bancile fara aplicatii

SELECT 
    b.Name AS Banca,
    b.CommissionPercent AS ComisionProcent,
    COUNT(ab.ApplicationId) AS NumarAplicatii,
    COUNT(CASE WHEN a.Status = 'APROBAT' THEN 1 END) AS AplicatiiAprobate
FROM APPLICATION_BANKS ab
RIGHT JOIN BANCI b ON ab.BankId = b.Id
LEFT JOIN APLICATII a ON ab.ApplicationId = a.Id
GROUP BY b.Name, b.CommissionPercent
HAVING COUNT(ab.ApplicationId) >= 0
ORDER BY NumarAplicatii DESC;

INTEROGAREA 8: FULL JOIN cu subinterogare in SELECT
Enunt: Afisati toate aplicatiile si documentele asociate, inclusiv aplicatiile fara documente si documentele fara aplicatii

SELECT 
    NVL(a.Id, d.ApplicationId) AS IdAplicatie,
    a.Status,
    COUNT(d.Id) AS NumarDocumente,
    (SELECT COUNT(*) FROM DOCUMENTE WHERE ApplicationId = a.Id) AS TotalDocumente
FROM APLICATII a
FULL JOIN DOCUMENTE d ON a.Id = d.ApplicationId
GROUP BY NVL(a.Id, d.ApplicationId), a.Status
ORDER BY NumarDocumente DESC;

INTEROGAREA 9: UNION - operator pe multimi
Enunt: Afisati toate entitatile (utilizatori si banci) care au fost create in ultimele 3 luni

SELECT 
    'UTILIZATOR' AS TipEntitate,
    Nume || ' ' || Prenume AS Denumire,
    TO_CHAR(CreatedAt, 'YYYY-MM-DD') AS DataCreare
FROM UTILIZATORI
WHERE CreatedAt >= ADD_MONTHS(SYSDATE, -3)
UNION
SELECT 
    'BANCA' AS TipEntitate,
    Name AS Denumire,
    TO_CHAR(CreatedAt, 'YYYY-MM-DD') AS DataCreare
FROM BANCI
WHERE CreatedAt >= ADD_MONTHS(SYSDATE, -3)
ORDER BY DataCreare DESC;

INTEROGAREA 10: INTERSECT - operator pe multimi
Enunt: Afisati utilizatorii care au aplicatii aprobate si mandate active

SELECT u.IdUtilizator, u.Nume || ' ' || u.Prenume AS NumeComplet
FROM UTILIZATORI u
INNER JOIN APLICATII a ON u.IdUtilizator = a.UserId
WHERE a.Status = 'APROBAT'
INTERSECT
SELECT u.IdUtilizator, u.Nume || ' ' || u.Prenume AS NumeComplet
FROM UTILIZATORI u
INNER JOIN MANDATE m ON u.IdUtilizator = m.UserId
WHERE m.Status = 'ACTIV';

INTEROGAREA 11: MINUS - operator pe multimi
Enunt: Afisati utilizatorii care au aplicatii dar nu au mandate

SELECT u.IdUtilizator, u.Nume || ' ' || u.Prenume AS NumeComplet
FROM UTILIZATORI u
INNER JOIN APLICATII a ON u.IdUtilizator = a.UserId
MINUS
SELECT u.IdUtilizator, u.Nume || ' ' || u.Prenume AS NumeComplet
FROM UTILIZATORI u
INNER JOIN MANDATE m ON u.IdUtilizator = m.UserId;

INTEROGAREA 12: Subinterogare in FROM (inline view)
Enunt: Afisati top 5 utilizatori dupa suma totala aprobata, cu media scoring-ului pentru fiecare

SELECT 
    u.Nume || ' ' || u.Prenume AS NumeComplet,
    stats.SumaTotala,
    stats.ScoringMediu,
    stats.NumarAplicatii
FROM UTILIZATORI u
INNER JOIN (
    SELECT 
        UserId,
        SUM(SumaAprobata) AS SumaTotala,
        AVG(Scoring) AS ScoringMediu,
        COUNT(*) AS NumarAplicatii
    FROM APLICATII
    WHERE Status = 'APROBAT' AND SumaAprobata IS NOT NULL
    GROUP BY UserId
) stats ON u.IdUtilizator = stats.UserId
WHERE ROWNUM <= 5
ORDER BY stats.SumaTotala DESC;

INTEROGAREA 13: Subinterogare in HAVING
Enunt: Afisati bancile care au un numar de aplicatii mai mare decat media numarului de aplicatii per banca

SELECT 
    b.Name AS Banca,
    COUNT(ab.ApplicationId) AS NumarAplicatii,
    AVG(a.Scoring) AS ScoringMediu
FROM BANCI b
INNER JOIN APPLICATION_BANKS ab ON b.Id = ab.BankId
INNER JOIN APLICATII a ON ab.ApplicationId = a.Id
GROUP BY b.Name
HAVING COUNT(ab.ApplicationId) > (
    SELECT AVG(COUNT(*))
    FROM APPLICATION_BANKS
    GROUP BY BankId
)
ORDER BY NumarAplicatii DESC;

INTEROGAREA 14: START WITH, CONNECT BY (hierarhie)
Enunt: Afisati ierarhia utilizatorilor: brokeri si clientii lor (prin mandate), cu nivelul in ierarhie

SELECT 
    LEVEL AS NivelIerarhie,
    LPAD(' ', 2 * (LEVEL - 1)) || u.Nume || ' ' || u.Prenume AS NumeComplet,
    r.NumeRol AS Rol,
    CASE 
        WHEN LEVEL = 1 THEN 'Broker'
        WHEN LEVEL = 2 THEN 'Client'
        ELSE 'N/A'
    END AS TipNod
FROM UTILIZATORI u
INNER JOIN ROLURI r ON u.IdRol = r.IdRol
LEFT JOIN MANDATE m ON u.IdUtilizator = m.BrokerId
START WITH r.NumeRol = 'BROKER' AND m.Status = 'ACTIV'
CONNECT BY PRIOR m.UserId = m.BrokerId
ORDER SIBLINGS BY u.Nume;

INTEROGAREA 15: OPERATORUL DIVISION
Enunt: Afisati bancile care au procesat aplicatii pentru TOTI utilizatorii care au aplicatii aprobate (operator DIVISION)

SELECT b.Name AS Banca
FROM BANCI b
WHERE NOT EXISTS (
    SELECT u.IdUtilizator
    FROM UTILIZATORI u
    INNER JOIN APLICATII a ON u.IdUtilizator = a.UserId
    WHERE a.Status = 'APROBAT'
    AND NOT EXISTS (
        SELECT 1
        FROM APPLICATION_BANKS ab
        WHERE ab.BankId = b.Id
        AND ab.ApplicationId = a.Id
    )
)
AND EXISTS (
    SELECT 1
    FROM APPLICATION_BANKS ab
    WHERE ab.BankId = b.Id
);

6. SUBPROGRAME PL/SQL

6.1 Procedura cu Colectii (SP_PROCESARE_COLECTII)
- VARRAY: t_varray_nume pentru nume banci
- NESTED TABLE: t_nested_table_id pentru ID-uri aplicatii
- ASSOCIATIVE ARRAY: t_assoc_array pentru sume pe status

CODUL PL/SQL:

SET SERVEROUTPUT ON;
CREATE OR REPLACE TYPE t_varray_nume AS VARRAY(100) OF VARCHAR2(100);
/
CREATE OR REPLACE TYPE t_nested_table_id AS TABLE OF NUMBER;
/
CREATE OR REPLACE PROCEDURE SP_PROCESARE_COLECTII (
p_id_utilizator IN NUMBER,
p_rezultat OUT VARCHAR2
)
IS
v_nume_banci t_varray_nume := t_varray_nume();
v_id_aplicatii t_nested_table_id := t_nested_table_id();
TYPE t_assoc_array IS TABLE OF NUMBER INDEX BY VARCHAR2(50);
v_sume_pe_status t_assoc_array;
BEGIN
FOR rec IN (
SELECT DISTINCT b.Name
FROM BANCI b
INNER JOIN APPLICATION_BANKS ab ON b.Id = ab.BankId
INNER JOIN APLICATII a ON ab.ApplicationId = a.Id
WHERE a.UserId = p_id_utilizator
AND ROWNUM <= 100
) LOOP
v_nume_banci.EXTEND;
v_nume_banci(v_nume_banci.COUNT) := rec.Name;
END LOOP;
FOR rec IN (
SELECT Id
FROM APLICATII
WHERE UserId = p_id_utilizator
) LOOP
v_id_aplicatii.EXTEND;
v_id_aplicatii(v_id_aplicatii.COUNT) := rec.Id;
END LOOP;
FOR rec IN (
SELECT Status, SUM(NVL(SumaAprobata, 0)) AS SumaTotala
FROM APLICATII
WHERE UserId = p_id_utilizator
GROUP BY Status
) LOOP
v_sume_pe_status(rec.Status) := rec.SumaTotala;
END LOOP;
p_rezultat := 'VARRAY: ' || v_nume_banci.COUNT || ' bănci, ' ||
'NESTED TABLE: ' || v_id_aplicatii.COUNT || ' aplicații, ' ||
'ASSOCIATIVE ARRAY: ' || v_sume_pe_status.COUNT || ' statusuri';
EXCEPTION
WHEN OTHERS THEN
p_rezultat := 'EROARE: ' || SQLERRM;
RAISE;
END;
/

6.2 Procedura cu Cursoare (SP_PROCESARE_CURSOARE)
- Cursor explicit parametrizat: c_utilizatori_rol(p_rol_id)
- Cursor FOR: Dependent de primul cursor, proceseaza aplicatiile

CODUL PL/SQL:

SET SERVEROUTPUT ON;
CREATE OR REPLACE PROCEDURE SP_PROCESARE_CURSOARE (
p_id_rol IN NUMBER,
p_rezultat OUT VARCHAR2
)
IS
CURSOR c_utilizatori_rol (p_rol_id NUMBER) IS
SELECT IdUtilizator, Nume, Prenume, Email
FROM UTILIZATORI
WHERE IdRol = p_rol_id
AND IsDeleted = 0
ORDER BY Nume, Prenume;
v_id_utilizator NUMBER;
v_nume VARCHAR2(100);
v_prenume VARCHAR2(100);
v_email VARCHAR2(255);
v_total_utilizatori NUMBER := 0;
v_total_aplicatii NUMBER := 0;
BEGIN
OPEN c_utilizatori_rol(p_id_rol);
LOOP
FETCH c_utilizatori_rol INTO v_id_utilizator, v_nume, v_prenume, v_email;
EXIT WHEN c_utilizatori_rol%NOTFOUND;
v_total_utilizatori := v_total_utilizatori + 1;
FOR rec_aplicatie IN (
SELECT Id, Status, SumaAprobata
FROM APLICATII
WHERE UserId = v_id_utilizator
) LOOP
v_total_aplicatii := v_total_aplicatii + 1;
END LOOP;
END LOOP;
CLOSE c_utilizatori_rol;
p_rezultat := 'Procesați ' || v_total_utilizatori || ' utilizatori, ' ||
v_total_aplicatii || ' aplicații';
EXCEPTION
WHEN OTHERS THEN
IF c_utilizatori_rol%ISOPEN THEN
CLOSE c_utilizatori_rol;
END IF;
p_rezultat := 'EROARE: ' || SQLERRM;
RAISE;
END;
/

6.3 Functie cu Exceptii (FN_CALCUL_STATISTICI_UTILIZATOR)
- Foloseste 3 tabele: UTILIZATORI, APLICATII, APPLICATION_BANKS
- Exceptii proprii: ex_utilizator_inexistent, ex_date_insuficiente
- Tratare exceptii predefinite: NO_DATA_FOUND, TOO_MANY_ROWS, OTHERS

CODUL PL/SQL:

SET SERVEROUTPUT ON;
CREATE OR REPLACE FUNCTION FN_CALCUL_STATISTICI_UTILIZATOR (
p_id_utilizator IN NUMBER
) RETURN VARCHAR2
IS
ex_utilizator_inexistent EXCEPTION;
ex_date_insuficiente EXCEPTION;
PRAGMA EXCEPTION_INIT(ex_utilizator_inexistent, -20001);
PRAGMA EXCEPTION_INIT(ex_date_insuficiente, -20002);
v_nume_complet VARCHAR2(200);
v_numar_aplicatii NUMBER := 0;
v_suma_totala NUMBER := 0;
v_scoring_mediu NUMBER := 0;
v_numar_banci NUMBER := 0;
v_rezultat VARCHAR2(1000);
v_utilizator_exista NUMBER := 0;
BEGIN
SELECT COUNT(*) INTO v_utilizator_exista
FROM UTILIZATORI
WHERE IdUtilizator = p_id_utilizator
AND IsDeleted = 0;
IF v_utilizator_exista = 0 THEN
RAISE ex_utilizator_inexistent;
END IF;
SELECT
u.Nume || ' ' || u.Prenume,
COUNT(DISTINCT a.Id),
SUM(NVL(a.SumaAprobata, 0)),
AVG(a.Scoring),
COUNT(DISTINCT ab.BankId)
INTO
v_nume_complet,
v_numar_aplicatii,
v_suma_totala,
v_scoring_mediu,
v_numar_banci
FROM UTILIZATORI u
LEFT JOIN APLICATII a ON u.IdUtilizator = a.UserId
LEFT JOIN APPLICATION_BANKS ab ON a.Id = ab.ApplicationId
WHERE u.IdUtilizator = p_id_utilizator
AND u.IsDeleted = 0
GROUP BY u.IdUtilizator, u.Nume, u.Prenume;
IF v_numar_aplicatii = 0 THEN
RAISE ex_date_insuficiente;
END IF;
v_rezultat := 'Utilizator: ' || v_nume_complet || ' | ' ||
'Aplicații: ' || v_numar_aplicatii || ' | ' ||
'Suma totală: ' || TO_CHAR(v_suma_totala, '999,999,999.00') || ' | ' ||
'Scoring mediu: ' || NVL(TO_CHAR(ROUND(v_scoring_mediu, 2)), 'N/A') || ' | ' ||
'Bănci: ' || v_numar_banci;
RETURN v_rezultat;
EXCEPTION
WHEN ex_utilizator_inexistent THEN
RETURN 'EROARE: Utilizator inexistent (ID: ' || p_id_utilizator || ')';
WHEN ex_date_insuficiente THEN
RETURN 'EROARE: Date insuficiente - utilizatorul nu are aplicații';
WHEN NO_DATA_FOUND THEN
RETURN 'EROARE: Date negăsite pentru utilizator (ID: ' || p_id_utilizator || ')';
WHEN TOO_MANY_ROWS THEN
RETURN 'EROARE: Date duplicate pentru utilizator (ID: ' || p_id_utilizator || ')';
WHEN OTHERS THEN
RETURN 'EROARE: ' || SQLCODE || ' - ' || SUBSTR(SQLERRM, 1, 200);
END;
/

7. TRIGGERI

7.1 Trigger LDD (trg_audit_ddl)
- Se declanseaza la CREATE, ALTER, DROP pe schema
- Insereaza mesaje in MESAJE pentru audit

CODUL PL/SQL:

SET SERVEROUTPUT ON;
CREATE OR REPLACE TRIGGER trg_audit_ddl
AFTER CREATE OR ALTER OR DROP ON SCHEMA
DECLARE
v_event_type VARCHAR2(30);
v_object_type VARCHAR2(30);
v_object_name VARCHAR2(128);
BEGIN
IF ORA_SYSEVENT = 'CREATE' THEN
v_event_type := 'CREATE';
ELSIF ORA_SYSEVENT = 'ALTER' THEN
v_event_type := 'ALTER';
ELSIF ORA_SYSEVENT = 'DROP' THEN
v_event_type := 'DROP';
ELSE
v_event_type := ORA_SYSEVENT;
END IF;
v_object_type := ORA_DICT_OBJ_TYPE;
v_object_name := ORA_DICT_OBJ_NAME;
BEGIN
INSERT INTO MESAJE (
cod_mesaj,
mesaj,
tip_mesaj,
creat_de,
creat_la
) VALUES (
seq_mesaje.NEXTVAL,
'DDL Event: ' || v_event_type || ' ' || v_object_type || ' ' || v_object_name,
'I',
USER,
SYSDATE
);
COMMIT;
EXCEPTION
WHEN OTHERS THEN
NULL;
END;
EXCEPTION
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('EROARE în trigger LDD: ' || SQLERRM);
END;
/

7.2 Triggeri LMD
- trg_aplicatii_before_insert: Nivel comanda, verifica utilizatori activi
- trg_aplicatii_before_update: Nivel linie, valideaza scoring si inregistreaza schimbari status
- trg_aplicatii_after_insert: Nivel linie, inregistreaza crearea aplicatiei
- trg_aplicatii_after_delete: Nivel linie, inregistreaza stergerea aplicatiei
- trg_utilizatori_varsta_mesaje: Nivel linie, valideaza varsta minim 18 ani

CODUL PL/SQL:

SET SERVEROUTPUT ON;
CREATE OR REPLACE TRIGGER trg_aplicatii_before_insert
BEFORE INSERT ON APLICATII
DECLARE
v_count NUMBER;
BEGIN
SELECT COUNT(*) INTO v_count
FROM UTILIZATORI
WHERE IsDeleted = 0;
IF v_count = 0 THEN
INSERT INTO MESAJE (
cod_mesaj,
mesaj,
tip_mesaj,
creat_de,
creat_la
) VALUES (
seq_mesaje.NEXTVAL,
'ATENȚIONARE: Nu există utilizatori activi în sistem!',
'W',
USER,
SYSDATE
);
COMMIT;
END IF;
EXCEPTION
WHEN OTHERS THEN
NULL;
END;
/

CREATE OR REPLACE TRIGGER trg_aplicatii_before_update
BEFORE UPDATE ON APLICATII
FOR EACH ROW
DECLARE
v_mesaj VARCHAR2(255);
BEGIN
IF :OLD.Status != :NEW.Status THEN
v_mesaj := 'Status aplicație ' || :NEW.Id || ' schimbat de la ' ||
:OLD.Status || ' la ' || :NEW.Status;
INSERT INTO MESAJE (
cod_mesaj,
mesaj,
tip_mesaj,
creat_de,
creat_la
) VALUES (
seq_mesaje.NEXTVAL,
v_mesaj,
'I',
USER,
SYSDATE
);
END IF;
IF :NEW.Scoring IS NOT NULL AND (:NEW.Scoring < 300 OR :NEW.Scoring > 850) THEN
INSERT INTO MESAJE (
cod_mesaj,
mesaj,
tip_mesaj,
creat_de,
creat_la
) VALUES (
seq_mesaje.NEXTVAL,
'EROARE: Scoring invalid pentru aplicația ' || :NEW.Id ||
' (valoare: ' || :NEW.Scoring || ', trebuie între 300-850)',
'E',
USER,
SYSDATE
);
RAISE_APPLICATION_ERROR(-20020, 'Scoring invalid! Trebuie să fie între 300 și 850.');
END IF;
EXCEPTION
WHEN OTHERS THEN
RAISE;
END;
/

CREATE OR REPLACE TRIGGER trg_aplicatii_after_insert
AFTER INSERT ON APLICATII
FOR EACH ROW
BEGIN
INSERT INTO MESAJE (
cod_mesaj,
mesaj,
tip_mesaj,
creat_de,
creat_la
) VALUES (
seq_mesaje.NEXTVAL,
'Aplicație nouă creată: ID=' || :NEW.Id ||
', Utilizator=' || :NEW.UserId ||
', Status=' || :NEW.Status,
'I',
USER,
SYSDATE
);
EXCEPTION
WHEN OTHERS THEN
NULL;
END;
/

CREATE OR REPLACE TRIGGER trg_aplicatii_after_delete
AFTER DELETE ON APLICATII
FOR EACH ROW
BEGIN
INSERT INTO MESAJE (
cod_mesaj,
mesaj,
tip_mesaj,
creat_de,
creat_la
) VALUES (
seq_mesaje.NEXTVAL,
'Aplicație ștearsă: ID=' || :OLD.Id ||
', Utilizator=' || :OLD.UserId ||
', Status=' || :OLD.Status,
'W',
USER,
SYSDATE
);
EXCEPTION
WHEN OTHERS THEN
NULL;
END;
/

CREATE OR REPLACE TRIGGER trg_utilizatori_varsta_mesaje
BEFORE INSERT OR UPDATE OF DataNastere ON UTILIZATORI
FOR EACH ROW
BEGIN
IF :NEW.DataNastere > ADD_MONTHS(SYSDATE, -216) THEN
INSERT INTO MESAJE (
cod_mesaj,
mesaj,
tip_mesaj,
creat_de,
creat_la
) VALUES (
seq_mesaje.NEXTVAL,
'EROARE: Utilizator ' || :NEW.IdUtilizator ||
' are vârsta mai mică de 18 ani!',
'E',
USER,
SYSDATE
);
COMMIT;
RAISE_APPLICATION_ERROR(-20005, 'Utilizatorul trebuie să aibă minim 18 ani');
END IF;
EXCEPTION
WHEN OTHERS THEN
RAISE;
END;
/

8. PACHET PKG_MONEYSHOP

Pachetul contine:
- SP_PROCESARE_COLECTII: Procedura cu colectii
- SP_PROCESARE_CURSOARE: Procedura cu cursoare
- FN_CALCUL_STATISTICI_UTILIZATOR: Functie cu 3 tabele si exceptii
- SP_ACTUALIZARE_APLICATIE: Procedura care declanseaza trigger LMD
- SP_CREARE_APLICATIE: Procedura care declanseaza trigger LMD
- FN_INSERARE_MESAJ: Functie helper pentru tratare exceptii

CODUL PL/SQL PENTRU PACHET:

SET SERVEROUTPUT ON;
CREATE OR REPLACE PACKAGE PKG_MONEYSHOP AS
PROCEDURE SP_PROCESARE_COLECTII (
p_id_utilizator IN NUMBER,
p_rezultat OUT VARCHAR2
);
PROCEDURE SP_PROCESARE_CURSOARE (
p_id_rol IN NUMBER,
p_rezultat OUT VARCHAR2
);
FUNCTION FN_CALCUL_STATISTICI_UTILIZATOR (
p_id_utilizator IN NUMBER
) RETURN VARCHAR2;
PROCEDURE SP_ACTUALIZARE_APLICATIE (
p_id_aplicatie IN NUMBER,
p_nou_status IN VARCHAR2,
p_suma_aprobata IN NUMBER DEFAULT NULL
);
PROCEDURE SP_CREARE_APLICATIE (
p_id_utilizator IN NUMBER,
p_type_credit IN VARCHAR2,
p_tip_operatiune IN VARCHAR2,
p_salariu_net IN NUMBER,
p_id_aplicatie OUT NUMBER
);
FUNCTION FN_INSERARE_MESAJ (
p_mesaj IN VARCHAR2,
p_tip_mesaj IN VARCHAR2 DEFAULT 'I',
p_creat_de IN VARCHAR2 DEFAULT USER
) RETURN NUMBER;
END PKG_MONEYSHOP;
/

CREATE OR REPLACE PACKAGE BODY PKG_MONEYSHOP AS
TYPE t_varray_nume IS VARRAY(100) OF VARCHAR2(100);
TYPE t_nested_table_id IS TABLE OF NUMBER;
TYPE t_assoc_array IS TABLE OF NUMBER INDEX BY VARCHAR2(50);

PROCEDURE SP_PROCESARE_COLECTII (
p_id_utilizator IN NUMBER,
p_rezultat OUT VARCHAR2
)
IS
v_nume_banci t_varray_nume := t_varray_nume();
v_id_aplicatii t_nested_table_id := t_nested_table_id();
v_sume_pe_status t_assoc_array;
BEGIN
FOR rec IN (
SELECT DISTINCT b.Name
FROM BANCI b
INNER JOIN APPLICATION_BANKS ab ON b.Id = ab.BankId
INNER JOIN APLICATII a ON ab.ApplicationId = a.Id
WHERE a.UserId = p_id_utilizator
AND ROWNUM <= 100
) LOOP
v_nume_banci.EXTEND;
v_nume_banci(v_nume_banci.COUNT) := rec.Name;
END LOOP;
FOR rec IN (
SELECT Id
FROM APLICATII
WHERE UserId = p_id_utilizator
) LOOP
v_id_aplicatii.EXTEND;
v_id_aplicatii(v_id_aplicatii.COUNT) := rec.Id;
END LOOP;
FOR rec IN (
SELECT Status, SUM(NVL(SumaAprobata, 0)) AS SumaTotala
FROM APLICATII
WHERE UserId = p_id_utilizator
GROUP BY Status
) LOOP
v_sume_pe_status(rec.Status) := rec.SumaTotala;
END LOOP;
p_rezultat := 'VARRAY: ' || v_nume_banci.COUNT || ' bănci, ' ||
'NESTED TABLE: ' || v_id_aplicatii.COUNT || ' aplicații, ' ||
'ASSOCIATIVE ARRAY: ' || v_sume_pe_status.COUNT || ' statusuri';
EXCEPTION
WHEN OTHERS THEN
p_rezultat := 'EROARE: ' || SQLERRM;
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('EROARE SP_PROCESARE_COLECTII: ' || SQLERRM, 'E');
END;
RAISE;
END SP_PROCESARE_COLECTII;

PROCEDURE SP_PROCESARE_CURSOARE (
p_id_rol IN NUMBER,
p_rezultat OUT VARCHAR2
)
IS
CURSOR c_utilizatori_rol (p_rol_id NUMBER) IS
SELECT IdUtilizator, Nume, Prenume, Email
FROM UTILIZATORI
WHERE IdRol = p_rol_id
AND IsDeleted = 0
ORDER BY Nume, Prenume;
v_id_utilizator NUMBER;
v_nume VARCHAR2(100);
v_prenume VARCHAR2(100);
v_email VARCHAR2(255);
v_total_utilizatori NUMBER := 0;
v_total_aplicatii NUMBER := 0;
BEGIN
OPEN c_utilizatori_rol(p_id_rol);
LOOP
FETCH c_utilizatori_rol INTO v_id_utilizator, v_nume, v_prenume, v_email;
EXIT WHEN c_utilizatori_rol%NOTFOUND;
v_total_utilizatori := v_total_utilizatori + 1;
FOR rec_aplicatie IN (
SELECT Id, Status, SumaAprobata
FROM APLICATII
WHERE UserId = v_id_utilizator
) LOOP
v_total_aplicatii := v_total_aplicatii + 1;
END LOOP;
END LOOP;
CLOSE c_utilizatori_rol;
p_rezultat := 'Procesați ' || v_total_utilizatori || ' utilizatori, ' ||
v_total_aplicatii || ' aplicații';
EXCEPTION
WHEN OTHERS THEN
IF c_utilizatori_rol%ISOPEN THEN
CLOSE c_utilizatori_rol;
END IF;
p_rezultat := 'EROARE: ' || SQLERRM;
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('EROARE SP_PROCESARE_CURSOARE: ' || SQLERRM, 'E');
END;
RAISE;
END SP_PROCESARE_CURSOARE;

FUNCTION FN_CALCUL_STATISTICI_UTILIZATOR (
p_id_utilizator IN NUMBER
) RETURN VARCHAR2
IS
ex_utilizator_inexistent EXCEPTION;
ex_date_insuficiente EXCEPTION;
PRAGMA EXCEPTION_INIT(ex_utilizator_inexistent, -20001);
PRAGMA EXCEPTION_INIT(ex_date_insuficiente, -20002);
v_nume_complet VARCHAR2(200);
v_numar_aplicatii NUMBER := 0;
v_suma_totala NUMBER := 0;
v_scoring_mediu NUMBER := 0;
v_numar_banci NUMBER := 0;
v_rezultat VARCHAR2(1000);
v_utilizator_exista NUMBER := 0;
BEGIN
SELECT COUNT(*) INTO v_utilizator_exista
FROM UTILIZATORI
WHERE IdUtilizator = p_id_utilizator
AND IsDeleted = 0;
IF v_utilizator_exista = 0 THEN
RAISE ex_utilizator_inexistent;
END IF;
SELECT
u.Nume || ' ' || u.Prenume,
COUNT(DISTINCT a.Id),
SUM(NVL(a.SumaAprobata, 0)),
AVG(a.Scoring),
COUNT(DISTINCT ab.BankId)
INTO
v_nume_complet,
v_numar_aplicatii,
v_suma_totala,
v_scoring_mediu,
v_numar_banci
FROM UTILIZATORI u
LEFT JOIN APLICATII a ON u.IdUtilizator = a.UserId
LEFT JOIN APPLICATION_BANKS ab ON a.Id = ab.ApplicationId
WHERE u.IdUtilizator = p_id_utilizator
AND u.IsDeleted = 0
GROUP BY u.IdUtilizator, u.Nume, u.Prenume;
IF v_numar_aplicatii = 0 THEN
RAISE ex_date_insuficiente;
END IF;
v_rezultat := 'Utilizator: ' || v_nume_complet || ' | ' ||
'Aplicații: ' || v_numar_aplicatii || ' | ' ||
'Suma totală: ' || TO_CHAR(v_suma_totala, '999,999,999.00') || ' | ' ||
'Scoring mediu: ' || NVL(TO_CHAR(ROUND(v_scoring_mediu, 2)), 'N/A') || ' | ' ||
'Bănci: ' || v_numar_banci;
RETURN v_rezultat;
EXCEPTION
WHEN ex_utilizator_inexistent THEN
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('Utilizator inexistent: ' || p_id_utilizator, 'E');
END;
RETURN 'EROARE: Utilizator inexistent (ID: ' || p_id_utilizator || ')';
WHEN ex_date_insuficiente THEN
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('Date insuficiente pentru utilizator: ' || p_id_utilizator, 'W');
END;
RETURN 'EROARE: Date insuficiente - utilizatorul nu are aplicații';
WHEN OTHERS THEN
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('EROARE FN_CALCUL_STATISTICI: ' || SQLERRM, 'E');
END;
RETURN 'EROARE: ' || SQLCODE || ' - ' || SUBSTR(SQLERRM, 1, 200);
END FN_CALCUL_STATISTICI_UTILIZATOR;

PROCEDURE SP_ACTUALIZARE_APLICATIE (
p_id_aplicatie IN NUMBER,
p_nou_status IN VARCHAR2,
p_suma_aprobata IN NUMBER DEFAULT NULL
)
IS
BEGIN
UPDATE APLICATII
SET Status = p_nou_status,
SumaAprobata = NVL(p_suma_aprobata, SumaAprobata),
UpdatedAt = SYSTIMESTAMP
WHERE Id = p_id_aplicatie;
IF SQL%ROWCOUNT = 0 THEN
RAISE_APPLICATION_ERROR(-20010, 'Aplicația cu ID ' || p_id_aplicatie || ' nu există!');
END IF;
COMMIT;
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('Aplicație actualizată: ' || p_id_aplicatie || ' -> Status: ' || p_nou_status, 'I');
END;
EXCEPTION
WHEN OTHERS THEN
ROLLBACK;
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('EROARE SP_ACTUALIZARE_APLICATIE: ' || SQLERRM, 'E');
END;
RAISE;
END SP_ACTUALIZARE_APLICATIE;

PROCEDURE SP_CREARE_APLICATIE (
p_id_utilizator IN NUMBER,
p_type_credit IN VARCHAR2,
p_tip_operatiune IN VARCHAR2,
p_salariu_net IN NUMBER,
p_id_aplicatie OUT NUMBER
)
IS
BEGIN
INSERT INTO APLICATII (
UserId,
Status,
TypeCredit,
TipOperatiune,
SalariuNet,
CreatedAt,
UpdatedAt
) VALUES (
p_id_utilizator,
'INREGISTRAT',
p_type_credit,
p_tip_operatiune,
p_salariu_net,
SYSTIMESTAMP,
SYSTIMESTAMP
)
RETURNING Id INTO p_id_aplicatie;
COMMIT;
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('Aplicație creată: ' || p_id_aplicatie || ' pentru utilizator: ' || p_id_utilizator, 'I');
END;
EXCEPTION
WHEN OTHERS THEN
ROLLBACK;
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('EROARE SP_CREARE_APLICATIE: ' || SQLERRM, 'E');
END;
RAISE;
END SP_CREARE_APLICATIE;

FUNCTION FN_INSERARE_MESAJ (
p_mesaj IN VARCHAR2,
p_tip_mesaj IN VARCHAR2 DEFAULT 'I',
p_creat_de IN VARCHAR2 DEFAULT USER
) RETURN NUMBER
IS
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := seq_mesaje.NEXTVAL;
INSERT INTO MESAJE (
cod_mesaj,
mesaj,
tip_mesaj,
creat_de,
creat_la
) VALUES (
v_cod_mesaj,
SUBSTR(p_mesaj, 1, 255),
p_tip_mesaj,
p_creat_de,
SYSDATE
);
COMMIT;
RETURN v_cod_mesaj;
EXCEPTION
WHEN OTHERS THEN
RETURN 0;
END FN_INSERARE_MESAJ;
END PKG_MONEYSHOP;
/

9. TRATARE EXCEPTII

Toate subprogramele si triggerii insereaza mesaje in tabelul MESAJE la aparitia exceptiilor:
- Tip E: Eroare
- Tip W: Avertisment
- Tip I: Informatie

10. DATE DE TEST

Au fost populate date de test conform cerintelor:
- Minim 5 inregistrari per entitate independenta
- Minim 10 inregistrari per tabel asociativ

CODUL SQL PENTRU POPULAREA DATELOR:

SET SERVEROUTPUT ON;

BEGIN
INSERT INTO ROLURI (NumeRol, Descriere)
SELECT 'CLIENT', 'Utilizator standard care aplică pentru credite' FROM DUAL
WHERE NOT EXISTS (SELECT 1 FROM ROLURI WHERE NumeRol = 'CLIENT');
INSERT INTO ROLURI (NumeRol, Descriere)
SELECT 'BROKER', 'Broker autorizat care procesează cererile de credit' FROM DUAL
WHERE NOT EXISTS (SELECT 1 FROM ROLURI WHERE NumeRol = 'BROKER');
INSERT INTO ROLURI (NumeRol, Descriere)
SELECT 'ADMIN', 'Administrator cu acces complet la sistem' FROM DUAL
WHERE NOT EXISTS (SELECT 1 FROM ROLURI WHERE NumeRol = 'ADMIN');
COMMIT;
END;
/

DECLARE
v_count NUMBER;
BEGIN
SELECT COUNT(*) INTO v_count FROM BANCI;
IF v_count < 5 THEN
INSERT INTO BANCI (Name, CommissionPercent, Active) VALUES ('BCR', 2.5, 1);
INSERT INTO BANCI (Name, CommissionPercent, Active) VALUES ('BRD', 2.8, 1);
INSERT INTO BANCI (Name, CommissionPercent, Active) VALUES ('BT', 2.3, 1);
INSERT INTO BANCI (Name, CommissionPercent, Active) VALUES ('ING', 2.6, 1);
INSERT INTO BANCI (Name, CommissionPercent, Active) VALUES ('UniCredit', 2.7, 1);
INSERT INTO BANCI (Name, CommissionPercent, Active) VALUES ('Raiffeisen', 2.4, 1);
INSERT INTO BANCI (Name, CommissionPercent, Active) VALUES ('CEC Bank', 2.2, 1);
COMMIT;
END IF;
END;
/

DECLARE
v_count NUMBER;
v_id_client NUMBER;
v_id_broker NUMBER;
v_parola_hash VARCHAR2(255) := 'a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3';
BEGIN
SELECT COUNT(*) INTO v_count FROM UTILIZATORI;
SELECT IdRol INTO v_id_client FROM ROLURI WHERE NumeRol = 'CLIENT';
SELECT IdRol INTO v_id_broker FROM ROLURI WHERE NumeRol = 'BROKER';
IF v_count < 5 THEN
INSERT INTO UTILIZATORI (Nume, Prenume, Username, Email, Parola, DataNastere, IdRol, EmailVerified)
VALUES ('Popescu', 'Ion', 'popescu.ion', 'popescu.ion@email.com', v_parola_hash, DATE '1990-01-15', v_id_client, 1);
INSERT INTO UTILIZATORI (Nume, Prenume, Username, Email, Parola, DataNastere, IdRol, EmailVerified)
VALUES ('Ionescu', 'Maria', 'ionescu.maria', 'ionescu.maria@email.com', v_parola_hash, DATE '1985-03-20', v_id_client, 1);
INSERT INTO UTILIZATORI (Nume, Prenume, Username, Email, Parola, DataNastere, IdRol, EmailVerified)
VALUES ('Georgescu', 'Andrei', 'georgescu.andrei', 'georgescu.andrei@email.com', v_parola_hash, DATE '1992-07-10', v_id_client, 1);
INSERT INTO UTILIZATORI (Nume, Prenume, Username, Email, Parola, DataNastere, IdRol, EmailVerified)
VALUES ('Dumitrescu', 'Elena', 'dumitrescu.elena', 'dumitrescu.elena@email.com', v_parola_hash, DATE '1988-11-25', v_id_client, 1);
INSERT INTO UTILIZATORI (Nume, Prenume, Username, Email, Parola, DataNastere, IdRol, EmailVerified)
VALUES ('Marinescu', 'Constantin', 'marinescu.constantin', 'marinescu.constantin@email.com', v_parola_hash, DATE '1995-05-30', v_id_client, 1);
INSERT INTO UTILIZATORI (Nume, Prenume, Username, Email, Parola, DataNastere, IdRol, EmailVerified)
VALUES ('Broker', 'Agent1', 'broker.agent1', 'broker.agent1@moneyshop.ro', v_parola_hash, DATE '1980-02-14', v_id_broker, 1);
INSERT INTO UTILIZATORI (Nume, Prenume, Username, Email, Parola, DataNastere, IdRol, EmailVerified)
VALUES ('Broker', 'Agent2', 'broker.agent2', 'broker.agent2@moneyshop.ro', v_parola_hash, DATE '1982-06-18', v_id_broker, 1);
COMMIT;
END IF;
END;
/

DECLARE
v_count NUMBER;
v_counter NUMBER := 0;
BEGIN
SELECT COUNT(*) INTO v_count FROM APLICATII;
IF v_count < 5 THEN
FOR rec_user IN (
SELECT IdUtilizator
FROM UTILIZATORI
WHERE IdRol = (SELECT IdRol FROM ROLURI WHERE NumeRol = 'CLIENT')
AND ROWNUM <= 10
) LOOP
FOR i IN 1..2 LOOP
IF v_count + v_counter >= 10 THEN
EXIT;
END IF;
INSERT INTO APLICATII (
UserId, Status, TypeCredit, TipOperatiune,
SalariuNet, Scoring, Dti, SumaAprobata, Comision,
CreatedAt, UpdatedAt
) VALUES (
rec_user.IdUtilizator,
CASE MOD(v_counter, 5)
WHEN 0 THEN 'INREGISTRAT'
WHEN 1 THEN 'IN_PROCESARE'
WHEN 2 THEN 'APROBAT'
WHEN 3 THEN 'REFUZAT'
ELSE 'ANULAT'
END,
CASE MOD(v_counter, 3)
WHEN 0 THEN 'IPOTECAR'
WHEN 1 THEN 'NEVOI_PERSONALE'
ELSE 'REFINANTARE'
END,
CASE MOD(v_counter, 2) WHEN 0 THEN 'NOU' ELSE 'REFINANTARE' END,
5000 + (v_counter * 500),
600 + (v_counter * 20),
30 + (v_counter * 5),
CASE WHEN MOD(v_counter, 5) = 2 THEN 50000 + (v_counter * 10000) ELSE NULL END,
CASE WHEN MOD(v_counter, 5) = 2 THEN (50000 + (v_counter * 10000)) * 0.025 ELSE NULL END,
SYSDATE - v_counter,
SYSDATE - v_counter + 5
);
v_counter := v_counter + 1;
END LOOP;
EXIT WHEN v_count + v_counter >= 10;
END LOOP;
COMMIT;
END IF;
END;
/

DECLARE
v_count NUMBER;
v_counter NUMBER := 0;
BEGIN
SELECT COUNT(*) INTO v_count FROM APPLICATION_BANKS;
IF v_count < 10 THEN
FOR rec_app IN (
SELECT Id FROM APLICATII WHERE ROWNUM <= 20
) LOOP
FOR rec_bank IN (
SELECT Id FROM BANCI WHERE ROWNUM <= 3
) LOOP
IF v_count + v_counter >= 20 THEN
EXIT;
END IF;
BEGIN
INSERT INTO APPLICATION_BANKS (
ApplicationId, BankId, Status, CreatedAt
) VALUES (
rec_app.Id,
rec_bank.Id,
CASE MOD(v_counter, 4)
WHEN 0 THEN 'PENDING'
WHEN 1 THEN 'APPROVED'
WHEN 2 THEN 'REJECTED'
ELSE 'CANCELLED'
END,
SYSDATE
);
v_counter := v_counter + 1;
EXCEPTION
WHEN DUP_VAL_ON_INDEX THEN
NULL;
END;
END LOOP;
EXIT WHEN v_count + v_counter >= 20;
END LOOP;
COMMIT;
END IF;
END;
/

11. CONCLUZII

Proiectul implementeaza toate cerintele specificate in documentul de cerinte. Baza de date este normalizata corect la FN3, interogarile SQL sunt complexe si acopera toate cerintele, iar subprogramele PL/SQL si triggerii sunt implementati conform specificatiilor.

NOTA: Pentru capturile de ecran cu executia comenzilor, consultati documentul 505_Cristea_Eduard_Aplicatie.txt unde trebuie adaugate screenshot-urile din aplicatie.

