DECLARE
    v_is_cdb VARCHAR2(3);
    v_container_name VARCHAR2(128);
BEGIN
    SELECT CDB INTO v_is_cdb FROM V$DATABASE;
    SELECT SYS_CONTEXT('USERENV', 'CON_NAME') INTO v_container_name FROM DUAL;
    DBMS_OUTPUT.PUT_LINE('Tip database: ' || CASE WHEN v_is_cdb = 'YES' THEN 'CDB' ELSE 'Non-CDB' END);
    DBMS_OUTPUT.PUT_LINE('Container: ' || v_container_name);
    IF v_is_cdb = 'YES' AND v_container_name = 'CDB$ROOT' THEN
        DBMS_OUTPUT.PUT_LINE('âš  EÈ™ti Ã®n CDB ROOT. Trebuie sÄƒ fii Ã®ntr-un PDB!');
        DBMS_OUTPUT.PUT_LINE('   RuleazÄƒ: ALTER SESSION SET CONTAINER = XEPDB1; (sau numele PDB-ului tÄƒu)');
    END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'CREATE TABLESPACE moneyshop_dw_ts
        DATAFILE ''moneyshop_dw_ts.dbf'' SIZE 500M
        AUTOEXTEND ON NEXT 100M MAXSIZE 2G
        EXTENT MANAGEMENT LOCAL
        SEGMENT SPACE MANAGEMENT AUTO';
    DBMS_OUTPUT.PUT_LINE('âœ“ Tablespace MONEYSHOP_DW_TS creat cu succes');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -1543 THEN
            DBMS_OUTPUT.PUT_LINE('âš  Tablespace MONEYSHOP_DW_TS existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('âš  Eroare la creare tablespace: ' || SQLERRM);
        END IF;
END;
/
DECLARE
    v_is_cdb VARCHAR2(3);
    v_container_name VARCHAR2(128);
    v_user_name VARCHAR2(128) := 'moneyshop_dw_user';
BEGIN
    SELECT CDB INTO v_is_cdb FROM V$DATABASE;
    SELECT SYS_CONTEXT('USERENV', 'CON_NAME') INTO v_container_name FROM DUAL;
    IF v_is_cdb = 'YES' AND v_container_name = 'CDB$ROOT' THEN
        DBMS_OUTPUT.PUT_LINE('âš  EROARE: Nu poÈ›i crea utilizator local Ã®n CDB ROOT!');
        DBMS_OUTPUT.PUT_LINE('   SoluÈ›ie: ALTER SESSION SET CONTAINER = XEPDB1; (sau numele PDB-ului)');
        DBMS_OUTPUT.PUT_LINE('   Apoi ruleazÄƒ din nou acest script.');
        RAISE_APPLICATION_ERROR(-20001, 'Trebuie sÄƒ fii Ã®ntr-un PDB pentru a crea utilizator local');
    END IF;
    BEGIN
        EXECUTE IMMEDIATE 'CREATE USER ' || v_user_name || ' IDENTIFIED BY "MoneyShopDW2025!"
            DEFAULT TABLESPACE moneyshop_dw_ts
            TEMPORARY TABLESPACE temp
            QUOTA UNLIMITED ON moneyshop_dw_ts';
        DBMS_OUTPUT.PUT_LINE('âœ“ Utilizator ' || v_user_name || ' creat cu succes');
    EXCEPTION
        WHEN OTHERS THEN
            IF SQLCODE = -1920 THEN
                DBMS_OUTPUT.PUT_LINE('âš  Utilizator ' || v_user_name || ' existÄƒ deja');
            ELSIF SQLCODE = -65096 THEN
                DBMS_OUTPUT.PUT_LINE('âš  EROARE: Oracle CDB necesitÄƒ prefix C## pentru utilizatori comuni');
                DBMS_OUTPUT.PUT_LINE('   Sau creeazÄƒ utilizator local Ã®ntr-un PDB');
                DBMS_OUTPUT.PUT_LINE('   SoluÈ›ie: ALTER SESSION SET CONTAINER = XEPDB1;');
                RAISE;
            ELSE
                DBMS_OUTPUT.PUT_LINE('âš  Eroare la creare utilizator: ' || SQLERRM);
                RAISE;
            END IF;
    END;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'GRANT CONNECT, RESOURCE TO moneyshop_dw_user';
    EXECUTE IMMEDIATE 'GRANT CREATE SESSION TO moneyshop_dw_user';
    EXECUTE IMMEDIATE 'GRANT CREATE TABLE TO moneyshop_dw_user';
    EXECUTE IMMEDIATE 'GRANT CREATE VIEW TO moneyshop_dw_user';
    EXECUTE IMMEDIATE 'GRANT CREATE PROCEDURE TO moneyshop_dw_user';
    EXECUTE IMMEDIATE 'GRANT CREATE SEQUENCE TO moneyshop_dw_user';
    EXECUTE IMMEDIATE 'GRANT CREATE DIMENSION TO moneyshop_dw_user';
    EXECUTE IMMEDIATE 'GRANT CREATE MATERIALIZED VIEW TO moneyshop_dw_user';
    DBMS_OUTPUT.PUT_LINE('âœ“ Privilegii de bazÄƒ acordate');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('âš  Eroare la grant privilegii: ' || SQLERRM);
END;
/
DECLARE
    v_oltp_schema VARCHAR2(128);
    v_table_count NUMBER;
    v_user_name VARCHAR2(128) := 'moneyshop_dw_user';
BEGIN
    SELECT OWNER INTO v_oltp_schema
    FROM (
        SELECT OWNER, COUNT(*) as cnt
        FROM ALL_TABLES
        WHERE TABLE_NAME IN ('UTILIZATORI', 'ROLURI', 'BANCI', 'APLICATII', 'APPLICATION_BANKS', 'MANDATE')
        GROUP BY OWNER
        ORDER BY cnt DESC
    )
    WHERE ROWNUM = 1;
    DBMS_OUTPUT.PUT_LINE('âœ“ Schema OLTP detectatÄƒ: ' || v_oltp_schema);
    BEGIN
        EXECUTE IMMEDIATE 'GRANT SELECT ON ' || v_oltp_schema || '.UTILIZATORI TO ' || v_user_name;
        EXECUTE IMMEDIATE 'GRANT SELECT ON ' || v_oltp_schema || '.ROLURI TO ' || v_user_name;
        EXECUTE IMMEDIATE 'GRANT SELECT ON ' || v_oltp_schema || '.APLICATII TO ' || v_user_name;
        EXECUTE IMMEDIATE 'GRANT SELECT ON ' || v_oltp_schema || '.BANCI TO ' || v_user_name;
        EXECUTE IMMEDIATE 'GRANT SELECT ON ' || v_oltp_schema || '.APPLICATION_BANKS TO ' || v_user_name;
        EXECUTE IMMEDIATE 'GRANT SELECT ON ' || v_oltp_schema || '.MANDATE TO ' || v_user_name;
        DBMS_OUTPUT.PUT_LINE('âœ“ Privilegii SELECT pe tabele OLTP acordate');
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('âš  Eroare la grant SELECT: ' || SQLERRM);
            DBMS_OUTPUT.PUT_LINE('   Schema detectatÄƒ: ' || v_oltp_schema);
    END;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('âš  EROARE: Nu s-au gÄƒsit tabelele OLTP!');
        DBMS_OUTPUT.PUT_LINE('   VerificÄƒ cÄƒ ai rulat OracleDatabase/03_CREATE_TABLES.sql');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('âš  Eroare la detectare schema OLTP: ' || SQLERRM);
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER SESSION SET CURRENT_SCHEMA = moneyshop_dw_user';
    DBMS_OUTPUT.PUT_LINE('âœ“ Schema curentÄƒ setatÄƒ la moneyshop_dw_user');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('âš  Eroare la setare schema: ' || SQLERRM);
        DBMS_OUTPUT.PUT_LINE('âš  PoÈ›i continua manual cu: ALTER SESSION SET CURRENT_SCHEMA = moneyshop_dw_user');
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('SCHEMA DW CREATÄ‚ CU SUCCES!');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('Utilizator: moneyshop_dw_user');
    DBMS_OUTPUT.PUT_LINE('Tablespace: moneyshop_dw_ts');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('UrmÄƒtorul pas: RuleazÄƒ 02_POPULATE_OLTP_TEST_DATA.sql');
    DBMS_OUTPUT.PUT_LINE('(dacÄƒ nu ai deja date Ã®n OLTP)');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Sau conecteazÄƒ-te ca moneyshop_dw_user pentru urmÄƒtoarele scripturi');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
DECLARE
    v_schema_exists NUMBER;
    v_table_exists NUMBER;
    v_current_schema VARCHAR2(128);
BEGIN
    SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') INTO v_current_schema FROM DUAL;
    DBMS_OUTPUT.PUT_LINE('Schema curentÄƒ: ' || v_current_schema);
    SELECT COUNT(*) INTO v_table_exists
    FROM USER_TABLES
    WHERE TABLE_NAME IN ('UTILIZATORI', 'ROLURI', 'BANCI', 'APLICATII');
    IF v_table_exists >= 4 THEN
        DBMS_OUTPUT.PUT_LINE('âœ“ Tabelele OLTP gÄƒsite Ã®n schema curentÄƒ');
    ELSE
        BEGIN
            EXECUTE IMMEDIATE 'ALTER SESSION SET CURRENT_SCHEMA = MONEYSHOP';
            DBMS_OUTPUT.PUT_LINE('âœ“ Schema setatÄƒ la MONEYSHOP');
            SELECT COUNT(*) INTO v_table_exists
            FROM ALL_TABLES
            WHERE OWNER = 'MONEYSHOP'
            AND TABLE_NAME IN ('UTILIZATORI', 'ROLURI', 'BANCI', 'APLICATII');
            IF v_table_exists < 4 THEN
                RAISE_APPLICATION_ERROR(-20001, 
                    'Eroare: Tabelele OLTP nu au fost gÄƒsite!' || CHR(10) ||
                    'VerificÄƒ:' || CHR(10) ||
                    '1. Schema OLTP existÄƒ È™i se numeÈ™te MONEYSHOP (sau modificÄƒ scriptul)' || CHR(10) ||
                    '2. Tabelele UTILIZATORI, ROLURI, BANCI, APLICATII existÄƒ' || CHR(10) ||
                    '3. RuleazÄƒ mai Ã®ntÃ¢i OracleDatabase/03_CREATE_TABLES.sql pentru a crea tabelele');
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE_APPLICATION_ERROR(-20001, 
                    'Eroare: Nu s-a putut seta schema MONEYSHOP!' || CHR(10) ||
                    'Eroare: ' || SQLERRM || CHR(10) ||
                    'SoluÈ›ie: ConecteazÄƒ-te direct ca utilizator al schemei OLTP sau modificÄƒ numele schemei Ã®n script');
        END;
    END IF;
END;
/
DECLARE
    v_count_users NUMBER;
    v_count_apps NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count_users FROM UTILIZATORI;
    SELECT COUNT(*) INTO v_count_apps FROM APLICATII;
    IF v_count_users >= 1000 AND v_count_apps >= 5000 THEN
        DBMS_OUTPUT.PUT_LINE('âš  ExistÄƒ deja suficiente date Ã®n OLTP');
        DBMS_OUTPUT.PUT_LINE('   Utilizatori: ' || v_count_users);
        DBMS_OUTPUT.PUT_LINE('   AplicaÈ›ii: ' || v_count_apps);
        DBMS_OUTPUT.PUT_LINE('   Scriptul va continua pentru a completa datele dacÄƒ e necesar');
    ELSE
        DBMS_OUTPUT.PUT_LINE('â„¹ Generare date test OLTP...');
        DBMS_OUTPUT.PUT_LINE('   Utilizatori existente: ' || v_count_users);
        DBMS_OUTPUT.PUT_LINE('   AplicaÈ›ii existente: ' || v_count_apps);
    END IF;
END;
/
INSERT INTO ROLURI (NumeRol, Descriere)
SELECT 'CLIENT', 'Utilizator standard care aplicÄƒ pentru credite' FROM DUAL
WHERE NOT EXISTS (SELECT 1 FROM ROLURI WHERE NumeRol = 'CLIENT');
INSERT INTO ROLURI (NumeRol, Descriere)
SELECT 'BROKER', 'Broker autorizat care proceseazÄƒ cererile de credit' FROM DUAL
WHERE NOT EXISTS (SELECT 1 FROM ROLURI WHERE NumeRol = 'BROKER');
INSERT INTO ROLURI (NumeRol, Descriere)
SELECT 'ADMIN', 'Administrator cu acces complet la sistem' FROM DUAL
WHERE NOT EXISTS (SELECT 1 FROM ROLURI WHERE NumeRol = 'ADMIN');
COMMIT;
DECLARE
    v_id_client NUMBER;
    v_id_broker NUMBER;
    v_id_admin NUMBER;
BEGIN
    SELECT IdRol INTO v_id_client FROM ROLURI WHERE NumeRol = 'CLIENT';
    SELECT IdRol INTO v_id_broker FROM ROLURI WHERE NumeRol = 'BROKER';
    SELECT IdRol INTO v_id_admin FROM ROLURI WHERE NumeRol = 'ADMIN';
    DBMS_OUTPUT.PUT_LINE('âœ“ ID-uri roluri: CLIENT=' || v_id_client || ', BROKER=' || v_id_broker || ', ADMIN=' || v_id_admin);
END;
/
DECLARE
    v_id_client NUMBER;
    v_id_broker NUMBER;
    v_count_users NUMBER;
    v_target_users NUMBER := 1000;
    v_nume_list VARCHAR2(500) := 'Popescu,Ionescu,Popa,Radu,Stan,Constantinescu,Marinescu,Stoica,Nicolae,Florea';
    v_prenume_list VARCHAR2(500) := 'Ion,Maria,Gheorghe,Elena,Nicolae,Ana,Constantin,Mariana,Alexandru,Cristina';
    v_nume VARCHAR2(100);
    v_prenume VARCHAR2(100);
    v_email VARCHAR2(255);
    v_username VARCHAR2(50);
    v_parola_hash VARCHAR2(255) := 'a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3';
    v_data_nastere DATE;
    v_counter NUMBER := 0;
BEGIN
    SELECT IdRol INTO v_id_client FROM ROLURI WHERE NumeRol = 'CLIENT';
    SELECT IdRol INTO v_id_broker FROM ROLURI WHERE NumeRol = 'BROKER';
    SELECT COUNT(*) INTO v_count_users FROM UTILIZATORI;
    FOR i IN 1..50 LOOP
        v_nume := 'Broker' || i;
        v_prenume := 'Agent' || i;
        v_username := 'broker' || i;
        v_email := 'broker' || i || '@moneyshop.ro';
        v_data_nastere := ADD_MONTHS(SYSDATE, -ROUND(DBMS_RANDOM.VALUE(240, 840)));
        INSERT INTO UTILIZATORI (Nume, Prenume, Username, Email, Parola, DataNastere, IdRol, EmailVerified)
        VALUES (v_nume, v_prenume, v_username, v_email, v_parola_hash, v_data_nastere, v_id_broker, 1);
        v_counter := v_counter + 1;
    END LOOP;
    WHILE v_count_users + v_counter < v_target_users LOOP
        v_nume := 'Client' || (v_count_users + v_counter + 1);
        v_prenume := 'Test' || (v_count_users + v_counter + 1);
        v_username := 'client' || (v_count_users + v_counter + 1);
        v_email := 'client' || (v_count_users + v_counter + 1) || '@test.ro';
        v_data_nastere := ADD_MONTHS(SYSDATE, -ROUND(DBMS_RANDOM.VALUE(216, 816)));
        BEGIN
            INSERT INTO UTILIZATORI (Nume, Prenume, Username, Email, Parola, DataNastere, IdRol, EmailVerified)
            VALUES (v_nume, v_prenume, v_username, v_email, v_parola_hash, v_data_nastere, v_id_client, 1);
            v_counter := v_counter + 1;
        EXCEPTION
            WHEN DUP_VAL_ON_INDEX THEN
                NULL;
        END;
        IF MOD(v_counter, 100) = 0 THEN
            COMMIT;
            DBMS_OUTPUT.PUT_LINE('   Generat ' || v_counter || ' utilizatori...');
        END IF;
    END LOOP;
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('âœ“ Generat ' || v_counter || ' utilizatori noi');
END;
/
INSERT INTO BANCI (Name, CommissionPercent, Active)
SELECT 'BCR', 2.5, 1 FROM DUAL WHERE NOT EXISTS (SELECT 1 FROM BANCI WHERE Name = 'BCR');
INSERT INTO BANCI (Name, CommissionPercent, Active)
SELECT 'BRD', 2.8, 1 FROM DUAL WHERE NOT EXISTS (SELECT 1 FROM BANCI WHERE Name = 'BRD');
INSERT INTO BANCI (Name, CommissionPercent, Active)
SELECT 'BT', 2.3, 1 FROM DUAL WHERE NOT EXISTS (SELECT 1 FROM BANCI WHERE Name = 'BT');
INSERT INTO BANCI (Name, CommissionPercent, Active)
SELECT 'ING', 2.6, 1 FROM DUAL WHERE NOT EXISTS (SELECT 1 FROM BANCI WHERE Name = 'ING');
INSERT INTO BANCI (Name, CommissionPercent, Active)
SELECT 'UniCredit', 2.7, 1 FROM DUAL WHERE NOT EXISTS (SELECT 1 FROM BANCI WHERE Name = 'UniCredit');
INSERT INTO BANCI (Name, CommissionPercent, Active)
SELECT 'Garanti BBVA', 2.4, 1 FROM DUAL WHERE NOT EXISTS (SELECT 1 FROM BANCI WHERE Name = 'Garanti BBVA');
COMMIT;
DECLARE
    v_id_client NUMBER;
    v_count_apps NUMBER;
    v_target_apps NUMBER := 5000;
    v_user_id NUMBER;
    v_status_list VARCHAR2(200) := 'INREGISTRAT,IN_PROCESARE,APROBAT,REFUZAT,ANULAT';
    v_type_credit_list VARCHAR2(200) := 'IPOTECAR,NEVOI_PERSONALE,REFINANTARE';
    v_tip_op_list VARCHAR2(100) := 'NOU,REFINANTARE';
    v_status VARCHAR2(50);
    v_type_credit VARCHAR2(50);
    v_tip_op VARCHAR2(50);
    v_salariu_net NUMBER;
    v_scoring NUMBER;
    v_dti NUMBER;
    v_suma_aprobata NUMBER;
    v_comision NUMBER;
    v_data_creare DATE;
    v_counter NUMBER := 0;
    CURSOR c_users IS SELECT IdUtilizator FROM UTILIZATORI WHERE IdRol = (SELECT IdRol FROM ROLURI WHERE NumeRol = 'CLIENT');
BEGIN
    SELECT IdRol INTO v_id_client FROM ROLURI WHERE NumeRol = 'CLIENT';
    SELECT COUNT(*) INTO v_count_apps FROM APLICATII;
    FOR user_rec IN c_users LOOP
        FOR i IN 1..DBMS_RANDOM.VALUE(1, 10) LOOP
            IF v_count_apps + v_counter >= v_target_apps THEN
                EXIT;
            END IF;
            v_status := CASE ROUND(DBMS_RANDOM.VALUE(1, 5))
                WHEN 1 THEN 'INREGISTRAT'
                WHEN 2 THEN 'IN_PROCESARE'
                WHEN 3 THEN 'APROBAT'
                WHEN 4 THEN 'REFUZAT'
                ELSE 'ANULAT'
            END;
            v_type_credit := CASE ROUND(DBMS_RANDOM.VALUE(1, 3))
                WHEN 1 THEN 'IPOTECAR'
                WHEN 2 THEN 'NEVOI_PERSONALE'
                ELSE 'REFINANTARE'
            END;
            v_tip_op := CASE ROUND(DBMS_RANDOM.VALUE(1, 2))
                WHEN 1 THEN 'NOU'
                ELSE 'REFINANTARE'
            END;
            v_salariu_net := ROUND(DBMS_RANDOM.VALUE(2000, 15000), 2);
            v_scoring := ROUND(DBMS_RANDOM.VALUE(300, 850), 2);
            v_dti := ROUND(DBMS_RANDOM.VALUE(0, 80), 2);
            IF v_status = 'APROBAT' THEN
                v_suma_aprobata := ROUND(DBMS_RANDOM.VALUE(10000, 200000), 2);
                v_comision := ROUND(v_suma_aprobata * 0.025, 2);
            ELSE
                v_suma_aprobata := NULL;
                v_comision := NULL;
            END IF;
            v_data_creare := SYSDATE - DBMS_RANDOM.VALUE(0, 730);
            INSERT INTO APLICATII (
                UserId, Status, TypeCredit, TipOperatiune,
                SalariuNet, Scoring, Dti, SumaAprobata, Comision,
                CreatedAt, UpdatedAt
            ) VALUES (
                user_rec.IdUtilizator, v_status, v_type_credit, v_tip_op,
                v_salariu_net, v_scoring, v_dti, v_suma_aprobata, v_comision,
                v_data_creare, v_data_creare + DBMS_RANDOM.VALUE(0, 30)
            );
            v_counter := v_counter + 1;
            IF MOD(v_counter, 500) = 0 THEN
                COMMIT;
                DBMS_OUTPUT.PUT_LINE('   Generat ' || v_counter || ' aplicaÈ›ii...');
            END IF;
        END LOOP;
        EXIT WHEN v_count_apps + v_counter >= v_target_apps;
    END LOOP;
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('âœ“ Generat ' || v_counter || ' aplicaÈ›ii noi');
END;
/
DECLARE
    v_count_assoc NUMBER;
    v_target_assoc NUMBER := 8000;
    v_app_id NUMBER;
    v_bank_id NUMBER;
    v_status_list VARCHAR2(100) := 'PENDING,APPROVED,REJECTED,CANCELLED';
    v_status VARCHAR2(50);
    v_counter NUMBER := 0;
    CURSOR c_apps IS SELECT Id FROM APLICATII;
    CURSOR c_banks IS SELECT Id FROM BANCI;
BEGIN
    SELECT COUNT(*) INTO v_count_assoc FROM APPLICATION_BANKS;
    FOR app_rec IN c_apps LOOP
        FOR i IN 1..DBMS_RANDOM.VALUE(1, 3) LOOP
            IF v_count_assoc + v_counter >= v_target_assoc THEN
                EXIT;
            END IF;
            SELECT Id INTO v_bank_id FROM (
                SELECT Id FROM BANCI ORDER BY DBMS_RANDOM.VALUE
            ) WHERE ROWNUM = 1;
            v_status := CASE ROUND(DBMS_RANDOM.VALUE(1, 4))
                WHEN 1 THEN 'PENDING'
                WHEN 2 THEN 'APPROVED'
                WHEN 3 THEN 'REJECTED'
                ELSE 'CANCELLED'
            END;
            BEGIN
                INSERT INTO APPLICATION_BANKS (ApplicationId, BankId, Status)
                VALUES (app_rec.Id, v_bank_id, v_status);
                v_counter := v_counter + 1;
            EXCEPTION
                WHEN DUP_VAL_ON_INDEX THEN
                    NULL;
            END;
        END LOOP;
        EXIT WHEN v_count_assoc + v_counter >= v_target_assoc;
        IF MOD(v_counter, 500) = 0 THEN
            COMMIT;
            DBMS_OUTPUT.PUT_LINE('   Generat ' || v_counter || ' asocieri aplicaÈ›ie-bancÄƒ...');
        END IF;
    END LOOP;
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('âœ“ Generat ' || v_counter || ' asocieri aplicaÈ›ie-bancÄƒ noi');
END;
/
DECLARE
    v_count_mandates NUMBER;
    v_target_mandates NUMBER := 2000;
    v_user_id NUMBER;
    v_broker_id NUMBER;
    v_status VARCHAR2(50);
    v_counter NUMBER := 0;
    CURSOR c_users IS SELECT IdUtilizator FROM UTILIZATORI WHERE IdRol = (SELECT IdRol FROM ROLURI WHERE NumeRol = 'CLIENT');
    CURSOR c_brokers IS SELECT IdUtilizator FROM UTILIZATORI WHERE IdRol = (SELECT IdRol FROM ROLURI WHERE NumeRol = 'BROKER');
BEGIN
    SELECT COUNT(*) INTO v_count_mandates FROM MANDATE;
    FOR user_rec IN c_users LOOP
        IF DBMS_RANDOM.VALUE(1, 100) <= 30 THEN
            SELECT IdUtilizator INTO v_broker_id FROM (
                SELECT IdUtilizator FROM UTILIZATORI 
                WHERE IdRol = (SELECT IdRol FROM ROLURI WHERE NumeRol = 'BROKER')
                ORDER BY DBMS_RANDOM.VALUE
            ) WHERE ROWNUM = 1;
            v_status := CASE ROUND(DBMS_RANDOM.VALUE(1, 3))
                WHEN 1 THEN 'ACTIV'
                WHEN 2 THEN 'EXPIRAT'
                ELSE 'REVOCAT'
            END;
            BEGIN
                INSERT INTO MANDATE (UserId, BrokerId, Status, DataMandat)
                VALUES (user_rec.IdUtilizator, v_broker_id, v_status, SYSDATE - DBMS_RANDOM.VALUE(0, 365));
                v_counter := v_counter + 1;
            EXCEPTION
                WHEN DUP_VAL_ON_INDEX THEN
                    NULL;
            END;
            IF v_count_mandates + v_counter >= v_target_mandates THEN
                EXIT;
            END IF;
        END IF;
    END LOOP;
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('âœ“ Generat ' || v_counter || ' mandate noi');
END;
/
DECLARE
    v_count_users NUMBER;
    v_count_apps NUMBER;
    v_count_banks NUMBER;
    v_count_assoc NUMBER;
    v_count_mandates NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count_users FROM UTILIZATORI;
    SELECT COUNT(*) INTO v_count_apps FROM APLICATII;
    SELECT COUNT(*) INTO v_count_banks FROM BANCI;
    SELECT COUNT(*) INTO v_count_assoc FROM APPLICATION_BANKS;
    SELECT COUNT(*) INTO v_count_mandates FROM MANDATE;
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('GENERARE DATE TEST OLTP - COMPLETAT!');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('Utilizatori: ' || v_count_users);
    DBMS_OUTPUT.PUT_LINE('AplicaÈ›ii: ' || v_count_apps);
    DBMS_OUTPUT.PUT_LINE('BÄƒnci: ' || v_count_banks);
    DBMS_OUTPUT.PUT_LINE('Asocieri aplicaÈ›ie-bancÄƒ: ' || v_count_assoc);
    DBMS_OUTPUT.PUT_LINE('Mandate: ' || v_count_mandates);
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('UrmÄƒtorul pas: ConecteazÄƒ-te ca moneyshop_dw_user');
    DBMS_OUTPUT.PUT_LINE('              È™i ruleazÄƒ 03_CREATE_DW_TABLES.sql');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
SET SERVEROUTPUT ON;
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
ALTER SESSION SET NLS_TIMESTAMP_FORMAT = 'YYYY-MM-DD HH24:MI:SS.FF';
BEGIN
    BEGIN
        EXECUTE IMMEDIATE 'ALTER SESSION SET CURRENT_SCHEMA = moneyshop_dw_user';
        DBMS_OUTPUT.PUT_LINE('âœ“ Schema setatÄƒ la moneyshop_dw_user');
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('âš  Nu s-a putut seta schema (poate utilizatorul nu existÄƒ sau eÈ™ti deja conectat)');
    END;
    DBMS_OUTPUT.PUT_LINE('Schema curentÄƒ: ' || SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'));
    DBMS_OUTPUT.PUT_LINE('ÃŽnceput creare tabele DW...');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE DIM_TIMP CASCADE CONSTRAINTS';
    DBMS_OUTPUT.PUT_LINE('âš  Tabel DIM_TIMP È™ters (dacÄƒ exista)');
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END;
/
CREATE TABLE DIM_TIMP (
    IdTimp NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    DataCompleta DATE NOT NULL UNIQUE,
    An NUMBER(4) NOT NULL,
    Trimestru NUMBER(1) NOT NULL,
    Luna NUMBER(2) NOT NULL,
    Saptamana NUMBER(2) NOT NULL,
    Zi NUMBER(2) NOT NULL,
    ZiSaptamana NUMBER(1) NOT NULL,
    EsteWeekend NUMBER(1) NOT NULL,
    CONSTRAINT chk_trimestru CHECK (Trimestru BETWEEN 1 AND 4),
    CONSTRAINT chk_luna CHECK (Luna BETWEEN 1 AND 12),
    CONSTRAINT chk_zi CHECK (Zi BETWEEN 1 AND 31),
    CONSTRAINT chk_zi_saptamana CHECK (ZiSaptamana BETWEEN 1 AND 7),
    CONSTRAINT chk_weekend CHECK (EsteWeekend IN (0, 1))
);
CREATE INDEX idx_dim_timp_data ON DIM_TIMP(DataCompleta);
CREATE INDEX idx_dim_timp_an_trim ON DIM_TIMP(An, Trimestru);
BEGIN
    DBMS_OUTPUT.PUT_LINE('âœ“ Tabel DIM_TIMP creat');
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE DIM_UTILIZATOR CASCADE CONSTRAINTS';
    DBMS_OUTPUT.PUT_LINE('âš  Tabel DIM_UTILIZATOR È™ters (dacÄƒ exista)');
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END;
/
CREATE TABLE DIM_UTILIZATOR (
    IdUtilizator NUMBER PRIMARY KEY,
    Nume VARCHAR2(100) NOT NULL,
    Prenume VARCHAR2(100) NOT NULL,
    EmailMasked VARCHAR2(255),
    TelefonMasked VARCHAR2(20),
    IdRol NUMBER NOT NULL,
    DataNastere DATE,
    VechimeLuni NUMBER,
    CreatedAt TIMESTAMP
);
CREATE INDEX idx_dim_utilizator_rol ON DIM_UTILIZATOR(IdRol);
BEGIN
    DBMS_OUTPUT.PUT_LINE('âœ“ Tabel DIM_UTILIZATOR creat');
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE DIM_BANCA CASCADE CONSTRAINTS';
    DBMS_OUTPUT.PUT_LINE('âš  Tabel DIM_BANCA È™ters (dacÄƒ exista)');
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END;
/
CREATE TABLE DIM_BANCA (
    IdBanca NUMBER PRIMARY KEY,
    Name VARCHAR2(200) NOT NULL,
    CommissionPercent NUMBER(5,2) NOT NULL,
    Active NUMBER(1) NOT NULL,
    CreatedAt TIMESTAMP
);
BEGIN
    DBMS_OUTPUT.PUT_LINE('âœ“ Tabel DIM_BANCA creat');
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE DIM_TIP_CREDIT CASCADE CONSTRAINTS';
    DBMS_OUTPUT.PUT_LINE('âš  Tabel DIM_TIP_CREDIT È™ters (dacÄƒ exista)');
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END;
/
CREATE TABLE DIM_TIP_CREDIT (
    IdTipCredit NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    TypeCredit VARCHAR2(50) NOT NULL,
    TipOperatiune VARCHAR2(50) NOT NULL,
    Descriere VARCHAR2(200),
    CONSTRAINT chk_type_credit CHECK (TypeCredit IN ('IPOTECAR', 'NEVOI_PERSONALE', 'REFINANTARE')),
    CONSTRAINT chk_tip_operatiune CHECK (TipOperatiune IN ('NOU', 'REFINANTARE')),
    CONSTRAINT uk_tip_credit UNIQUE (TypeCredit, TipOperatiune)
);
BEGIN
    DBMS_OUTPUT.PUT_LINE('âœ“ Tabel DIM_TIP_CREDIT creat');
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE DIM_STATUS CASCADE CONSTRAINTS';
    DBMS_OUTPUT.PUT_LINE('âš  Tabel DIM_STATUS È™ters (dacÄƒ exista)');
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END;
/
CREATE TABLE DIM_STATUS (
    IdStatus NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    Status VARCHAR2(50) NOT NULL UNIQUE,
    Descriere VARCHAR2(200),
    Categorie VARCHAR2(50) NOT NULL,
    CONSTRAINT chk_status CHECK (Status IN ('INREGISTRAT', 'IN_PROCESARE', 'APROBAT', 'REFUZAT', 'ANULAT')),
    CONSTRAINT chk_categorie CHECK (Categorie IN ('IN_PROCES', 'FINALIZAT', 'ANULAT'))
);
BEGIN
    DBMS_OUTPUT.PUT_LINE('âœ“ Tabel DIM_STATUS creat');
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE DIM_BROKER CASCADE CONSTRAINTS';
    DBMS_OUTPUT.PUT_LINE('âš  Tabel DIM_BROKER È™ters (dacÄƒ exista)');
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END;
/
CREATE TABLE DIM_BROKER (
    IdBroker NUMBER PRIMARY KEY,
    Nume VARCHAR2(100) NOT NULL,
    Prenume VARCHAR2(100) NOT NULL,
    EmailMasked VARCHAR2(255),
    CreatedAt TIMESTAMP
);
BEGIN
    DBMS_OUTPUT.PUT_LINE('âœ“ Tabel DIM_BROKER creat');
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE FACT_APLICATII_CREDIT CASCADE CONSTRAINTS';
    DBMS_OUTPUT.PUT_LINE('âš  Tabel FACT_APLICATII_CREDIT È™ters (dacÄƒ exista)');
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END;
/
CREATE TABLE FACT_APLICATII_CREDIT (
    IdFact NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    IdUtilizator NUMBER NOT NULL,
    IdBanca NUMBER NOT NULL,
    IdTimp NUMBER NOT NULL,
    IdTipCredit NUMBER NOT NULL,
    IdStatus NUMBER NOT NULL,
    IdBroker NUMBER,
    SumaAprobata NUMBER(18,2) DEFAULT 0,
    Comision NUMBER(18,2) DEFAULT 0,
    Scoring NUMBER(5,2),
    Dti NUMBER(5,2),
    NumÄƒrAplicatii NUMBER DEFAULT 1,
    DurataProcesare NUMBER,
    SalariuNet NUMBER(18,2),
    SoldTotal NUMBER(18,2)
);
BEGIN
    DBMS_OUTPUT.PUT_LINE('âœ“ Tabel FACT_APLICATII_CREDIT creat');
END;
/
INSERT INTO DIM_TIP_CREDIT (TypeCredit, TipOperatiune, Descriere) VALUES
('IPOTECAR', 'NOU', 'Credit ipotecar nou');
INSERT INTO DIM_TIP_CREDIT (TypeCredit, TipOperatiune, Descriere) VALUES
('IPOTECAR', 'REFINANTARE', 'RefinanÈ›are credit ipotecar');
INSERT INTO DIM_TIP_CREDIT (TypeCredit, TipOperatiune, Descriere) VALUES
('NEVOI_PERSONALE', 'NOU', 'Credit de nevoi personale nou');
INSERT INTO DIM_TIP_CREDIT (TypeCredit, TipOperatiune, Descriere) VALUES
('NEVOI_PERSONALE', 'REFINANTARE', 'RefinanÈ›are credit de nevoi personale');
INSERT INTO DIM_TIP_CREDIT (TypeCredit, TipOperatiune, Descriere) VALUES
('REFINANTARE', 'NOU', 'RefinanÈ›are credit nou');
INSERT INTO DIM_TIP_CREDIT (TypeCredit, TipOperatiune, Descriere) VALUES
('REFINANTARE', 'REFINANTARE', 'RefinanÈ›are credit de refinanÈ›are');
COMMIT;
BEGIN
    DBMS_OUTPUT.PUT_LINE('âœ“ DIM_TIP_CREDIT populat cu ' || SQL%ROWCOUNT || ' Ã®nregistrÄƒri');
END;
/
INSERT INTO DIM_STATUS (Status, Descriere, Categorie) VALUES
('INREGISTRAT', 'AplicaÈ›ie Ã®nregistratÄƒ', 'IN_PROCES');
INSERT INTO DIM_STATUS (Status, Descriere, Categorie) VALUES
('IN_PROCESARE', 'AplicaÈ›ie Ã®n procesare', 'IN_PROCES');
INSERT INTO DIM_STATUS (Status, Descriere, Categorie) VALUES
('APROBAT', 'AplicaÈ›ie aprobatÄƒ', 'FINALIZAT');
INSERT INTO DIM_STATUS (Status, Descriere, Categorie) VALUES
('REFUZAT', 'AplicaÈ›ie refuzatÄƒ', 'FINALIZAT');
INSERT INTO DIM_STATUS (Status, Descriere, Categorie) VALUES
('ANULAT', 'AplicaÈ›ie anulatÄƒ', 'ANULAT');
COMMIT;
BEGIN
    DBMS_OUTPUT.PUT_LINE('âœ“ DIM_STATUS populat cu ' || SQL%ROWCOUNT || ' Ã®nregistrÄƒri');
END;
/
DECLARE
    v_start_date DATE := TO_DATE('2020-01-01', 'YYYY-MM-DD');
    v_end_date DATE := TO_DATE('2030-12-31', 'YYYY-MM-DD');
    v_current_date DATE;
    v_counter NUMBER := 0;
BEGIN
    v_current_date := v_start_date;
    WHILE v_current_date <= v_end_date LOOP
        INSERT INTO DIM_TIMP (
            DataCompleta, An, Trimestru, Luna, Saptamana, Zi,
            ZiSaptamana, EsteWeekend
        ) VALUES (
            v_current_date,
            EXTRACT(YEAR FROM v_current_date),
            CEIL(TO_NUMBER(TO_CHAR(v_current_date, 'MM'))/3),
            EXTRACT(MONTH FROM v_current_date),
            TO_NUMBER(TO_CHAR(v_current_date, 'WW')),
            EXTRACT(DAY FROM v_current_date),
            TO_NUMBER(TO_CHAR(v_current_date, 'D')),
            CASE WHEN TO_NUMBER(TO_CHAR(v_current_date, 'D')) IN (1, 7) THEN 1 ELSE 0 END
        );
        v_current_date := v_current_date + 1;
        v_counter := v_counter + 1;
        IF MOD(v_counter, 365) = 0 THEN
            COMMIT;
            DBMS_OUTPUT.PUT_LINE('   Generat ' || v_counter || ' zile...');
        END IF;
    END LOOP;
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('âœ“ DIM_TIMP populat cu ' || v_counter || ' zile (2020-2030)');
END;
/
DECLARE
    v_count_timp NUMBER;
    v_count_utilizator NUMBER;
    v_count_banca NUMBER;
    v_count_tip_credit NUMBER;
    v_count_status NUMBER;
    v_count_broker NUMBER;
    v_count_fact NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count_timp FROM DIM_TIMP;
    SELECT COUNT(*) INTO v_count_utilizator FROM DIM_UTILIZATOR;
    SELECT COUNT(*) INTO v_count_banca FROM DIM_BANCA;
    SELECT COUNT(*) INTO v_count_tip_credit FROM DIM_TIP_CREDIT;
    SELECT COUNT(*) INTO v_count_status FROM DIM_STATUS;
    SELECT COUNT(*) INTO v_count_broker FROM DIM_BROKER;
    SELECT COUNT(*) INTO v_count_fact FROM FACT_APLICATII_CREDIT;
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('CREARE TABELE DW - COMPLETAT!');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('Tabele create:');
    DBMS_OUTPUT.PUT_LINE('  - DIM_TIMP: ' || v_count_timp || ' zile');
    DBMS_OUTPUT.PUT_LINE('  - DIM_UTILIZATOR: ' || v_count_utilizator || ' utilizatori');
    DBMS_OUTPUT.PUT_LINE('  - DIM_BANCA: ' || v_count_banca || ' bÄƒnci');
    DBMS_OUTPUT.PUT_LINE('  - DIM_TIP_CREDIT: ' || v_count_tip_credit || ' tipuri');
    DBMS_OUTPUT.PUT_LINE('  - DIM_STATUS: ' || v_count_status || ' statusuri');
    DBMS_OUTPUT.PUT_LINE('  - DIM_BROKER: ' || v_count_broker || ' brokeri');
    DBMS_OUTPUT.PUT_LINE('  - FACT_APLICATII_CREDIT: ' || v_count_fact || ' fapte');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('UrmÄƒtorul pas: RuleazÄƒ 04_ETL_EXTRACT.sql');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
SET SERVEROUTPUT ON;
DECLARE
    v_oltp_schema VARCHAR2(128);
BEGIN
    SELECT OWNER INTO v_oltp_schema
    FROM (
        SELECT OWNER, COUNT(*) as cnt
        FROM ALL_TABLES
        WHERE TABLE_NAME IN ('UTILIZATORI', 'ROLURI', 'BANCI', 'APLICATII', 'APPLICATION_BANKS', 'MANDATE')
        GROUP BY OWNER
        ORDER BY cnt DESC
    )
    WHERE ROWNUM = 1;
    DBMS_OUTPUT.PUT_LINE('âœ“ Schema OLTP detectatÄƒ: ' || v_oltp_schema);
    DBMS_OUTPUT.PUT_LINE('');
    EXECUTE IMMEDIATE 'ALTER SESSION SET CURRENT_SCHEMA = moneyshop_dw_user';
END;
/
DECLARE
    v_oltp_schema VARCHAR2(128);
    v_sql VARCHAR2(4000);
BEGIN
    SELECT OWNER INTO v_oltp_schema
    FROM (
        SELECT OWNER, COUNT(*) as cnt
        FROM ALL_TABLES
        WHERE TABLE_NAME IN ('UTILIZATORI', 'ROLURI', 'BANCI', 'APLICATII', 'APPLICATION_BANKS', 'MANDATE')
        GROUP BY OWNER
        ORDER BY cnt DESC
    )
    WHERE ROWNUM = 1;
    BEGIN
        EXECUTE IMMEDIATE 'DROP VIEW VW_ETL_EXTRACT_APLICATII';
    EXCEPTION
        WHEN OTHERS THEN NULL;
    END;
    v_sql := 'CREATE OR REPLACE VIEW VW_ETL_EXTRACT_APLICATII AS
SELECT 
    a.Id AS ApplicationId,
    a.UserId,
    a.Status,
    a.TypeCredit,
    a.TipOperatiune,
    a.SalariuNet,
    a.Scoring,
    a.Dti,
    a.SumaAprobata,
    a.Comision,
    a.CreatedAt,
    a.UpdatedAt,
    ab.BankId,
    m.BrokerId,
    CASE 
        WHEN a.UpdatedAt IS NOT NULL AND a.CreatedAt IS NOT NULL THEN
            EXTRACT(DAY FROM (a.UpdatedAt - a.CreatedAt))
        ELSE 0
    END AS DurataProcesare
FROM ' || v_oltp_schema || '.APLICATII a
LEFT JOIN (
    SELECT ApplicationId, BankId,
           ROW_NUMBER() OVER (PARTITION BY ApplicationId ORDER BY CreatedAt) AS rn
    FROM ' || v_oltp_schema || '.APPLICATION_BANKS
) ab ON a.Id = ab.ApplicationId AND ab.rn = 1
LEFT JOIN (
    SELECT UserId, BrokerId,
           ROW_NUMBER() OVER (PARTITION BY UserId ORDER BY DataMandat DESC) AS rn
    FROM ' || v_oltp_schema || '.MANDATE
    WHERE Status = ''ACTIV''
) m ON a.UserId = m.UserId AND m.rn = 1';
    EXECUTE IMMEDIATE v_sql;
    DBMS_OUTPUT.PUT_LINE('âœ“ View VW_ETL_EXTRACT_APLICATII creat');
END;
/
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count FROM VW_ETL_EXTRACT_APLICATII;
    DBMS_OUTPUT.PUT_LINE('  NumÄƒr aplicaÈ›ii disponibile pentru extract: ' || v_count);
END;
/
DECLARE
    v_oltp_schema VARCHAR2(128);
    v_sql VARCHAR2(4000);
    v_count NUMBER;
BEGIN
    SELECT OWNER INTO v_oltp_schema
    FROM (
        SELECT OWNER, COUNT(*) as cnt
        FROM ALL_TABLES
        WHERE TABLE_NAME IN ('UTILIZATORI', 'ROLURI', 'BANCI', 'APLICATII', 'APPLICATION_BANKS', 'MANDATE')
        GROUP BY OWNER
        ORDER BY cnt DESC
    )
    WHERE ROWNUM = 1;
    v_sql := 'CREATE OR REPLACE VIEW VW_ETL_EXTRACT_UTILIZATORI AS
SELECT 
    u.IdUtilizator,
    u.Nume,
    u.Prenume,
    u.Email,
    u.NumarTelefon,
    u.IdRol,
    u.DataNastere,
    u.CreatedAt,
    FLOOR(MONTHS_BETWEEN(SYSDATE, u.CreatedAt)) AS VechimeLuni
FROM ' || v_oltp_schema || '.UTILIZATORI u
WHERE u.IsDeleted = 0 OR u.IsDeleted IS NULL';
    BEGIN
        EXECUTE IMMEDIATE v_sql;
        DBMS_OUTPUT.PUT_LINE('âœ“ View VW_ETL_EXTRACT_UTILIZATORI creat');
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('âš  Eroare la creare view VW_ETL_EXTRACT_UTILIZATORI: ' || SQLERRM);
            DBMS_OUTPUT.PUT_LINE('  SQL: ' || SUBSTR(v_sql, 1, 200));
            RAISE;
    END;
    BEGIN
        SELECT COUNT(*) INTO v_count FROM VW_ETL_EXTRACT_UTILIZATORI;
        DBMS_OUTPUT.PUT_LINE('  NumÄƒr utilizatori disponibili pentru extract: ' || v_count);
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('âš  View VW_ETL_EXTRACT_UTILIZATORI nu existÄƒ sau nu este accesibil');
    END;
END;
/
DECLARE
    v_oltp_schema VARCHAR2(128);
    v_sql VARCHAR2(4000);
    v_count NUMBER;
BEGIN
    SELECT OWNER INTO v_oltp_schema
    FROM (
        SELECT OWNER, COUNT(*) as cnt
        FROM ALL_TABLES
        WHERE TABLE_NAME IN ('UTILIZATORI', 'ROLURI', 'BANCI', 'APLICATII', 'APPLICATION_BANKS', 'MANDATE')
        GROUP BY OWNER
        ORDER BY cnt DESC
    )
    WHERE ROWNUM = 1;
    v_sql := 'CREATE OR REPLACE VIEW VW_ETL_EXTRACT_BANCI AS
SELECT 
    b.Id AS BankId,
    b.Name,
    b.CommissionPercent,
    b.Active,
    b.CreatedAt
FROM ' || v_oltp_schema || '.BANCI b';
    BEGIN
        EXECUTE IMMEDIATE v_sql;
        DBMS_OUTPUT.PUT_LINE('âœ“ View VW_ETL_EXTRACT_BANCI creat');
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('âš  Eroare la creare view VW_ETL_EXTRACT_BANCI: ' || SQLERRM);
            DBMS_OUTPUT.PUT_LINE('  SQL: ' || SUBSTR(v_sql, 1, 200));
            RAISE;
    END;
    BEGIN
        SELECT COUNT(*) INTO v_count FROM VW_ETL_EXTRACT_BANCI;
        DBMS_OUTPUT.PUT_LINE('  NumÄƒr bÄƒnci disponibile pentru extract: ' || v_count);
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('âš  View VW_ETL_EXTRACT_BANCI nu existÄƒ sau nu este accesibil');
    END;
END;
/
DECLARE
    v_oltp_schema VARCHAR2(128);
    v_sql VARCHAR2(4000);
    v_count NUMBER;
BEGIN
    SELECT OWNER INTO v_oltp_schema
    FROM (
        SELECT OWNER, COUNT(*) as cnt
        FROM ALL_TABLES
        WHERE TABLE_NAME IN ('UTILIZATORI', 'ROLURI', 'BANCI', 'APLICATII', 'APPLICATION_BANKS', 'MANDATE')
        GROUP BY OWNER
        ORDER BY cnt DESC
    )
    WHERE ROWNUM = 1;
    v_sql := 'CREATE OR REPLACE VIEW VW_ETL_EXTRACT_BROKERI AS
SELECT 
    u.IdUtilizator AS BrokerId,
    u.Nume,
    u.Prenume,
    u.Email,
    u.CreatedAt
FROM ' || v_oltp_schema || '.UTILIZATORI u
JOIN ' || v_oltp_schema || '.ROLURI r ON u.IdRol = r.IdRol
WHERE r.NumeRol = ''BROKER''
  AND (u.IsDeleted = 0 OR u.IsDeleted IS NULL)';
    BEGIN
        EXECUTE IMMEDIATE v_sql;
        DBMS_OUTPUT.PUT_LINE('âœ“ View VW_ETL_EXTRACT_BROKERI creat');
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('âš  Eroare la creare view VW_ETL_EXTRACT_BROKERI: ' || SQLERRM);
            DBMS_OUTPUT.PUT_LINE('  SQL: ' || SUBSTR(v_sql, 1, 200));
            RAISE;
    END;
    BEGIN
        SELECT COUNT(*) INTO v_count FROM VW_ETL_EXTRACT_BROKERI;
        DBMS_OUTPUT.PUT_LINE('  NumÄƒr brokeri disponibili pentru extract: ' || v_count);
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('âš  View VW_ETL_EXTRACT_BROKERI nu existÄƒ sau nu este accesibil');
    END;
END;
/
CREATE OR REPLACE FUNCTION FN_MASK_EMAIL(p_email IN VARCHAR2) RETURN VARCHAR2
IS
    v_at_pos NUMBER;
BEGIN
    IF p_email IS NULL THEN
        RETURN NULL;
    END IF;
    v_at_pos := INSTR(p_email, '@');
    IF v_at_pos > 0 THEN
        RETURN SUBSTR(p_email, 1, 1) || '***@' || SUBSTR(p_email, v_at_pos + 1);
    ELSE
        RETURN SUBSTR(p_email, 1, 1) || '***';
    END IF;
END;
/
CREATE OR REPLACE FUNCTION FN_MASK_TELEFON(p_telefon IN VARCHAR2) RETURN VARCHAR2
IS
BEGIN
    IF p_telefon IS NULL OR LENGTH(p_telefon) < 4 THEN
        RETURN '***';
    END IF;
    RETURN SUBSTR(p_telefon, 1, 3) || '***' || SUBSTR(p_telefon, -2);
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('ETL EXTRACT - COMPLETAT!');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('Views create pentru extract:');
    DBMS_OUTPUT.PUT_LINE('  - VW_ETL_EXTRACT_APLICATII');
    DBMS_OUTPUT.PUT_LINE('  - VW_ETL_EXTRACT_UTILIZATORI');
    DBMS_OUTPUT.PUT_LINE('  - VW_ETL_EXTRACT_BANCI');
    DBMS_OUTPUT.PUT_LINE('  - VW_ETL_EXTRACT_BROKERI');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('FuncÈ›ii helper:');
    DBMS_OUTPUT.PUT_LINE('  - FN_MASK_EMAIL');
    DBMS_OUTPUT.PUT_LINE('  - FN_MASK_TELEFON');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('UrmÄƒtorul pas: RuleazÄƒ 05_ETL_TRANSFORM.sql');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
SET SERVEROUTPUT ON;
CREATE OR REPLACE PROCEDURE SP_ETL_TRANSFORM_DIMENSIONS
IS
    v_counter NUMBER;
BEGIN
    DBMS_OUTPUT.PUT_LINE('ÃŽnceput transformare dimensiuni...');
    DBMS_OUTPUT.PUT_LINE('  Transformare DIM_UTILIZATOR...');
    MERGE INTO DIM_UTILIZATOR d
    USING (
        SELECT 
            u.IdUtilizator,
            u.Nume,
            u.Prenume,
            FN_MASK_EMAIL(u.Email) AS EmailMasked,
            FN_MASK_TELEFON(u.NumarTelefon) AS TelefonMasked,
            u.IdRol,
            u.DataNastere,
            u.VechimeLuni,
            u.CreatedAt
        FROM VW_ETL_EXTRACT_UTILIZATORI u
    ) s
    ON (d.IdUtilizator = s.IdUtilizator)
    WHEN MATCHED THEN
        UPDATE SET
            d.Nume = s.Nume,
            d.Prenume = s.Prenume,
            d.EmailMasked = s.EmailMasked,
            d.TelefonMasked = s.TelefonMasked,
            d.IdRol = s.IdRol,
            d.DataNastere = s.DataNastere,
            d.VechimeLuni = s.VechimeLuni,
            d.CreatedAt = s.CreatedAt
    WHEN NOT MATCHED THEN
        INSERT (IdUtilizator, Nume, Prenume, EmailMasked, TelefonMasked, IdRol, DataNastere, VechimeLuni, CreatedAt)
        VALUES (s.IdUtilizator, s.Nume, s.Prenume, s.EmailMasked, s.TelefonMasked, s.IdRol, s.DataNastere, s.VechimeLuni, s.CreatedAt);
    v_counter := SQL%ROWCOUNT;
    DBMS_OUTPUT.PUT_LINE('    âœ“ DIM_UTILIZATOR: ' || v_counter || ' Ã®nregistrÄƒri procesate');
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('  Transformare DIM_BANCA...');
    MERGE INTO DIM_BANCA d
    USING VW_ETL_EXTRACT_BANCI s
    ON (d.IdBanca = s.BankId)
    WHEN MATCHED THEN
        UPDATE SET
            d.Name = s.Name,
            d.CommissionPercent = s.CommissionPercent,
            d.Active = s.Active,
            d.CreatedAt = s.CreatedAt
    WHEN NOT MATCHED THEN
        INSERT (IdBanca, Name, CommissionPercent, Active, CreatedAt)
        VALUES (s.BankId, s.Name, s.CommissionPercent, s.Active, s.CreatedAt);
    v_counter := SQL%ROWCOUNT;
    DBMS_OUTPUT.PUT_LINE('    âœ“ DIM_BANCA: ' || v_counter || ' Ã®nregistrÄƒri procesate');
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('  Transformare DIM_BROKER...');
    MERGE INTO DIM_BROKER d
    USING (
        SELECT 
            b.BrokerId,
            b.Nume,
            b.Prenume,
            FN_MASK_EMAIL(b.Email) AS EmailMasked,
            b.CreatedAt
        FROM VW_ETL_EXTRACT_BROKERI b
    ) s
    ON (d.IdBroker = s.BrokerId)
    WHEN MATCHED THEN
        UPDATE SET
            d.Nume = s.Nume,
            d.Prenume = s.Prenume,
            d.EmailMasked = s.EmailMasked,
            d.CreatedAt = s.CreatedAt
    WHEN NOT MATCHED THEN
        INSERT (IdBroker, Nume, Prenume, EmailMasked, CreatedAt)
        VALUES (s.BrokerId, s.Nume, s.Prenume, s.EmailMasked, s.CreatedAt);
    v_counter := SQL%ROWCOUNT;
    DBMS_OUTPUT.PUT_LINE('    âœ“ DIM_BROKER: ' || v_counter || ' Ã®nregistrÄƒri procesate');
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('âœ“ Transformare dimensiuni completatÄƒ');
END;
/
CREATE OR REPLACE PROCEDURE SP_ETL_TRANSFORM_FACT
IS
    v_counter NUMBER := 0;
    v_processed NUMBER := 0;
BEGIN
    DBMS_OUTPUT.PUT_LINE('ÃŽnceput transformare fact table...');
    DELETE FROM FACT_APLICATII_CREDIT;
    DBMS_OUTPUT.PUT_LINE('  Date vechi È™terse');
    INSERT INTO FACT_APLICATII_CREDIT (
        IdUtilizator,
        IdBanca,
        IdTimp,
        IdTipCredit,
        IdStatus,
        IdBroker,
        SumaAprobata,
        Comision,
        Scoring,
        Dti,
        NumÄƒrAplicatii,
        DurataProcesare,
        SalariuNet,
        SoldTotal
    )
    SELECT 
        e.UserId AS IdUtilizator,
        NVL(e.BankId, 1) AS IdBanca,
        t.IdTimp,
        tc.IdTipCredit,
        s.IdStatus,
        e.BrokerId AS IdBroker,
        NVL(e.SumaAprobata, 0) AS SumaAprobata,
        NVL(e.Comision, 0) AS Comision,
        e.Scoring,
        e.Dti,
        1 AS NumÄƒrAplicatii,
        NVL(e.DurataProcesare, 0) AS DurataProcesare,
        e.SalariuNet,
        NULL AS SoldTotal
    FROM VW_ETL_EXTRACT_APLICATII e
    JOIN DIM_TIMP t ON TRUNC(e.CreatedAt) = t.DataCompleta
    JOIN DIM_TIP_CREDIT tc ON e.TypeCredit = tc.TypeCredit 
                          AND e.TipOperatiune = tc.TipOperatiune
    JOIN DIM_STATUS s ON e.Status = s.Status
    WHERE EXISTS (SELECT 1 FROM DIM_UTILIZATOR d WHERE d.IdUtilizator = e.UserId)
      AND EXISTS (SELECT 1 FROM DIM_BANCA d WHERE d.IdBanca = NVL(e.BankId, 1))
      AND (e.BrokerId IS NULL OR EXISTS (SELECT 1 FROM DIM_BROKER d WHERE d.IdBroker = e.BrokerId));
    v_counter := SQL%ROWCOUNT;
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('  âœ“ FACT_APLICATII_CREDIT: ' || v_counter || ' Ã®nregistrÄƒri inserate');
    DBMS_OUTPUT.PUT_LINE('âœ“ Transformare fact table completatÄƒ');
END;
/
CREATE OR REPLACE PROCEDURE SP_ETL_TRANSFORM_FULL
IS
BEGIN
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('ETL TRANSFORM - START');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('');
    SP_ETL_TRANSFORM_DIMENSIONS;
    DBMS_OUTPUT.PUT_LINE('');
    SP_ETL_TRANSFORM_FACT;
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('ETL TRANSFORM - COMPLETAT!');
    DBMS_OUTPUT.PUT_LINE('========================================');
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('âœ“ Proceduri ETL Transform create:');
    DBMS_OUTPUT.PUT_LINE('  - SP_ETL_TRANSFORM_DIMENSIONS');
    DBMS_OUTPUT.PUT_LINE('  - SP_ETL_TRANSFORM_FACT');
    DBMS_OUTPUT.PUT_LINE('  - SP_ETL_TRANSFORM_FULL');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('UrmÄƒtorul pas: RuleazÄƒ 06_ETL_LOAD.sql');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
SET SERVEROUTPUT ON;
CREATE OR REPLACE PROCEDURE SP_ETL_FULL_LOAD
IS
    v_start_time TIMESTAMP;
    v_end_time TIMESTAMP;
    v_duration NUMBER;
    v_count_fact NUMBER;
    v_count_dim_utilizator NUMBER;
    v_count_dim_banca NUMBER;
    v_count_dim_broker NUMBER;
    v_count_dim_tip_credit NUMBER;
    v_count_dim_status NUMBER;
    v_count_dim_timp NUMBER;
BEGIN
    v_start_time := SYSTIMESTAMP;
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('ETL FULL LOAD - START');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('Timp start: ' || TO_CHAR(v_start_time, 'YYYY-MM-DD HH24:MI:SS.FF'));
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('PAS 1: Transformare dimensiuni...');
    SP_ETL_TRANSFORM_DIMENSIONS;
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('PAS 2: Transformare È™i load fact table...');
    SP_ETL_TRANSFORM_FACT;
    SELECT COUNT(*) INTO v_count_fact FROM FACT_APLICATII_CREDIT;
    v_end_time := SYSTIMESTAMP;
    v_duration := EXTRACT(SECOND FROM (v_end_time - v_start_time)) + 
                  EXTRACT(MINUTE FROM (v_end_time - v_start_time)) * 60 +
                  EXTRACT(HOUR FROM (v_end_time - v_start_time)) * 3600;
    SELECT COUNT(*) INTO v_count_dim_utilizator FROM DIM_UTILIZATOR;
    SELECT COUNT(*) INTO v_count_dim_banca FROM DIM_BANCA;
    SELECT COUNT(*) INTO v_count_dim_broker FROM DIM_BROKER;
    SELECT COUNT(*) INTO v_count_dim_tip_credit FROM DIM_TIP_CREDIT;
    SELECT COUNT(*) INTO v_count_dim_status FROM DIM_STATUS;
    SELECT COUNT(*) INTO v_count_dim_timp FROM DIM_TIMP;
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('ETL FULL LOAD - COMPLETAT!');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('Timp final: ' || TO_CHAR(v_end_time, 'YYYY-MM-DD HH24:MI:SS.FF'));
    DBMS_OUTPUT.PUT_LINE('DuratÄƒ: ' || ROUND(v_duration, 2) || ' secunde');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Rezultate:');
    DBMS_OUTPUT.PUT_LINE('  - DIM_UTILIZATOR: ' || v_count_dim_utilizator || ' Ã®nregistrÄƒri');
    DBMS_OUTPUT.PUT_LINE('  - DIM_BANCA: ' || v_count_dim_banca || ' Ã®nregistrÄƒri');
    DBMS_OUTPUT.PUT_LINE('  - DIM_BROKER: ' || v_count_dim_broker || ' Ã®nregistrÄƒri');
    DBMS_OUTPUT.PUT_LINE('  - DIM_TIP_CREDIT: ' || v_count_dim_tip_credit || ' Ã®nregistrÄƒri');
    DBMS_OUTPUT.PUT_LINE('  - DIM_STATUS: ' || v_count_dim_status || ' Ã®nregistrÄƒri');
    DBMS_OUTPUT.PUT_LINE('  - DIM_TIMP: ' || v_count_dim_timp || ' Ã®nregistrÄƒri');
    DBMS_OUTPUT.PUT_LINE('  - FACT_APLICATII_CREDIT: ' || v_count_fact || ' Ã®nregistrÄƒri');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
CREATE OR REPLACE PROCEDURE SP_ETL_INCREMENTAL_LOAD
IS
    v_last_load_date TIMESTAMP;
    v_count_new NUMBER;
BEGIN
    v_last_load_date := SYSTIMESTAMP - INTERVAL '1' DAY;
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('ETL INCREMENTAL LOAD - START');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('CÄƒutare date noi dupÄƒ: ' || TO_CHAR(v_last_load_date, 'YYYY-MM-DD HH24:MI:SS'));
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Actualizare dimensiuni...');
    SP_ETL_TRANSFORM_DIMENSIONS;
    DBMS_OUTPUT.PUT_LINE('Inserare aplicaÈ›ii noi...');
    INSERT INTO FACT_APLICATII_CREDIT (
        IdUtilizator, IdBanca, IdTimp, IdTipCredit, IdStatus, IdBroker,
        SumaAprobata, Comision, Scoring, Dti, NumÄƒrAplicatii, DurataProcesare,
        SalariuNet, SoldTotal
    )
    SELECT 
        e.UserId AS IdUtilizator,
        NVL(e.BankId, 1) AS IdBanca,
        t.IdTimp,
        tc.IdTipCredit,
        s.IdStatus,
        e.BrokerId AS IdBroker,
        NVL(e.SumaAprobata, 0) AS SumaAprobata,
        NVL(e.Comision, 0) AS Comision,
        e.Scoring,
        e.Dti,
        1 AS NumÄƒrAplicatii,
        NVL(e.DurataProcesare, 0) AS DurataProcesare,
        e.SalariuNet,
        NULL AS SoldTotal
    FROM VW_ETL_EXTRACT_APLICATII e
    JOIN DIM_TIMP t ON TRUNC(e.CreatedAt) = t.DataCompleta
    JOIN DIM_TIP_CREDIT tc ON e.TypeCredit = tc.TypeCredit 
                          AND e.TipOperatiune = tc.TipOperatiune
    JOIN DIM_STATUS s ON e.Status = s.Status
    WHERE e.CreatedAt >= v_last_load_date
      AND NOT EXISTS (
          SELECT 1 FROM FACT_APLICATII_CREDIT f
          WHERE f.IdUtilizator = e.UserId
            AND f.IdTimp = t.IdTimp
            AND f.IdTipCredit = tc.IdTipCredit
            AND f.IdStatus = s.IdStatus
      )
      AND EXISTS (SELECT 1 FROM DIM_UTILIZATOR d WHERE d.IdUtilizator = e.UserId)
      AND EXISTS (SELECT 1 FROM DIM_BANCA d WHERE d.IdBanca = NVL(e.BankId, 1))
      AND (e.BrokerId IS NULL OR EXISTS (SELECT 1 FROM DIM_BROKER d WHERE d.IdBroker = e.BrokerId));
    v_count_new := SQL%ROWCOUNT;
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('ETL INCREMENTAL LOAD - COMPLETAT!');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('AplicaÈ›ii noi inserate: ' || v_count_new);
    DBMS_OUTPUT.PUT_LINE('');
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('âœ“ Proceduri ETL Load create:');
    DBMS_OUTPUT.PUT_LINE('  - SP_ETL_FULL_LOAD (full load)');
    DBMS_OUTPUT.PUT_LINE('  - SP_ETL_INCREMENTAL_LOAD (incremental load)');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Pentru a rula ETL, executÄƒ:');
    DBMS_OUTPUT.PUT_LINE('  EXEC SP_ETL_FULL_LOAD;');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('UrmÄƒtorul pas: RuleazÄƒ 07_DW_CONSTRAINTS.sql');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
SET SERVEROUTPUT ON;
BEGIN
    DBMS_OUTPUT.PUT_LINE('ÃŽnceput adÄƒugare constrÃ¢ngeri DW...');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('1. AdÄƒugare Foreign Keys...');
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        ADD CONSTRAINT fk_fact_utilizator 
        FOREIGN KEY (IdUtilizator) REFERENCES DIM_UTILIZATOR(IdUtilizator)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ fk_fact_utilizator');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -2275 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  fk_fact_utilizator existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare fk_fact_utilizator: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        ADD CONSTRAINT fk_fact_banca 
        FOREIGN KEY (IdBanca) REFERENCES DIM_BANCA(IdBanca)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ fk_fact_banca');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -2275 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  fk_fact_banca existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare fk_fact_banca: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        ADD CONSTRAINT fk_fact_timp 
        FOREIGN KEY (IdTimp) REFERENCES DIM_TIMP(IdTimp)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ fk_fact_timp');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -2275 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  fk_fact_timp existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare fk_fact_timp: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        ADD CONSTRAINT fk_fact_tip_credit 
        FOREIGN KEY (IdTipCredit) REFERENCES DIM_TIP_CREDIT(IdTipCredit)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ fk_fact_tip_credit');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -2275 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  fk_fact_tip_credit existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare fk_fact_tip_credit: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        ADD CONSTRAINT fk_fact_status 
        FOREIGN KEY (IdStatus) REFERENCES DIM_STATUS(IdStatus)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ fk_fact_status');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -2275 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  fk_fact_status existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare fk_fact_status: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        ADD CONSTRAINT fk_fact_broker 
        FOREIGN KEY (IdBroker) REFERENCES DIM_BROKER(IdBroker)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ fk_fact_broker');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -2275 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  fk_fact_broker existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare fk_fact_broker: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('2. AdÄƒugare Check Constraints...');
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        ADD CONSTRAINT chk_fact_scoring 
        CHECK (Scoring IS NULL OR (Scoring >= 300 AND Scoring <= 850))';
    DBMS_OUTPUT.PUT_LINE('  âœ“ chk_fact_scoring');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -2275 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  chk_fact_scoring existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare chk_fact_scoring: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        ADD CONSTRAINT chk_fact_dti 
        CHECK (Dti IS NULL OR (Dti >= 0 AND Dti <= 100))';
    DBMS_OUTPUT.PUT_LINE('  âœ“ chk_fact_dti');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -2275 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  chk_fact_dti existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare chk_fact_dti: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        ADD CONSTRAINT chk_fact_suma_aprobata 
        CHECK (SumaAprobata >= 0)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ chk_fact_suma_aprobata');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -2275 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  chk_fact_suma_aprobata existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare chk_fact_suma_aprobata: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        ADD CONSTRAINT chk_fact_comision 
        CHECK (Comision >= 0)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ chk_fact_comision');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -2275 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  chk_fact_comision existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare chk_fact_comision: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        ADD CONSTRAINT chk_fact_durata_procesare 
        CHECK (DurataProcesare >= 0)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ chk_fact_durata_procesare');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -2275 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  chk_fact_durata_procesare existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare chk_fact_durata_procesare: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('3. AdÄƒugare NOT NULL Constraints...');
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        MODIFY IdUtilizator NOT NULL';
    DBMS_OUTPUT.PUT_LINE('  âœ“ IdUtilizator NOT NULL');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('  âœ— Eroare IdUtilizator NOT NULL: ' || SQLERRM);
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        MODIFY IdBanca NOT NULL';
    DBMS_OUTPUT.PUT_LINE('  âœ“ IdBanca NOT NULL');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('  âœ— Eroare IdBanca NOT NULL: ' || SQLERRM);
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        MODIFY IdTimp NOT NULL';
    DBMS_OUTPUT.PUT_LINE('  âœ“ IdTimp NOT NULL');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('  âœ— Eroare IdTimp NOT NULL: ' || SQLERRM);
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        MODIFY IdTipCredit NOT NULL';
    DBMS_OUTPUT.PUT_LINE('  âœ“ IdTipCredit NOT NULL');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('  âœ— Eroare IdTipCredit NOT NULL: ' || SQLERRM);
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        MODIFY IdStatus NOT NULL';
    DBMS_OUTPUT.PUT_LINE('  âœ“ IdStatus NOT NULL');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('  âœ— Eroare IdStatus NOT NULL: ' || SQLERRM);
END;
/
BEGIN
    EXECUTE IMMEDIATE 'ALTER TABLE FACT_APLICATII_CREDIT
        MODIFY SumaAprobata DEFAULT 0';
    DBMS_OUTPUT.PUT_LINE('  âœ“ SumaAprobata DEFAULT 0');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('  âœ— Eroare SumaAprobata DEFAULT: ' || SQLERRM);
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('4. Verificare constrÃ¢ngeri...');
END;
/
SELECT 
    CONSTRAINT_NAME,
    CONSTRAINT_TYPE,
    TABLE_NAME,
    STATUS
FROM USER_CONSTRAINTS
WHERE TABLE_NAME IN ('FACT_APLICATII_CREDIT', 'DIM_UTILIZATOR', 'DIM_BANCA', 'DIM_TIMP', 'DIM_TIP_CREDIT', 'DIM_STATUS', 'DIM_BROKER')
ORDER BY TABLE_NAME, CONSTRAINT_TYPE;
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('CONSTRÃ‚NGERI DW - COMPLETAT!');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('ConstrÃ¢ngeri create:');
    DBMS_OUTPUT.PUT_LINE('  - 6 Foreign Keys');
    DBMS_OUTPUT.PUT_LINE('  - 5 Check Constraints');
    DBMS_OUTPUT.PUT_LINE('  - 5 NOT NULL Constraints');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('UrmÄƒtorul pas: RuleazÄƒ 08_DW_INDEXES.sql');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
SET SERVEROUTPUT ON;
BEGIN
    DBMS_OUTPUT.PUT_LINE('ÃŽnceput creare indecÈ™i DW...');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('1. Creare Bitmap Indexes...');
END;
/
BEGIN
    EXECUTE IMMEDIATE 'CREATE BITMAP INDEX idx_fact_status_bitmap 
        ON FACT_APLICATII_CREDIT(IdStatus)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ idx_fact_status_bitmap creat');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -955 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  idx_fact_status_bitmap existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare idx_fact_status_bitmap: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'CREATE BITMAP INDEX idx_fact_tip_credit_bitmap 
        ON FACT_APLICATII_CREDIT(IdTipCredit)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ idx_fact_tip_credit_bitmap creat');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -955 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  idx_fact_tip_credit_bitmap existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare idx_fact_tip_credit_bitmap: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('2. Creare B-Tree Indexes...');
END;
/
BEGIN
    EXECUTE IMMEDIATE 'CREATE INDEX idx_fact_timp_btree 
        ON FACT_APLICATII_CREDIT(IdTimp)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ idx_fact_timp_btree creat');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -955 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  idx_fact_timp_btree existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare idx_fact_timp_btree: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'CREATE INDEX idx_fact_utilizator_btree 
        ON FACT_APLICATII_CREDIT(IdUtilizator)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ idx_fact_utilizator_btree creat');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -955 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  idx_fact_utilizator_btree existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare idx_fact_utilizator_btree: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'CREATE INDEX idx_fact_banca_btree 
        ON FACT_APLICATII_CREDIT(IdBanca)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ idx_fact_banca_btree creat');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -955 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  idx_fact_banca_btree existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare idx_fact_banca_btree: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('3. Creare Composite Indexes...');
END;
/
BEGIN
    EXECUTE IMMEDIATE 'CREATE INDEX idx_fact_timp_status 
        ON FACT_APLICATII_CREDIT(IdTimp, IdStatus)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ idx_fact_timp_status creat');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -955 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  idx_fact_timp_status existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare idx_fact_timp_status: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'CREATE INDEX idx_fact_banca_status 
        ON FACT_APLICATII_CREDIT(IdBanca, IdStatus)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ idx_fact_banca_status creat');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -955 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  idx_fact_banca_status existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare idx_fact_banca_status: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('4. Creare Indexes pe Dimensiuni...');
END;
/
BEGIN
    EXECUTE IMMEDIATE 'CREATE INDEX idx_dim_banca_name 
        ON DIM_BANCA(Name)';
    DBMS_OUTPUT.PUT_LINE('  âœ“ idx_dim_banca_name creat');
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE = -955 THEN
            DBMS_OUTPUT.PUT_LINE('  âš  idx_dim_banca_name existÄƒ deja');
        ELSE
            DBMS_OUTPUT.PUT_LINE('  âœ— Eroare idx_dim_banca_name: ' || SQLERRM);
        END IF;
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('5. Verificare indecÈ™i...');
END;
/
SELECT 
    INDEX_NAME,
    INDEX_TYPE,
    TABLE_NAME,
    UNIQUENESS,
    STATUS
FROM USER_INDEXES
WHERE TABLE_NAME IN ('FACT_APLICATII_CREDIT', 'DIM_UTILIZATOR', 'DIM_BANCA', 'DIM_TIMP', 'DIM_TIP_CREDIT', 'DIM_STATUS', 'DIM_BROKER')
ORDER BY TABLE_NAME, INDEX_NAME;
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('6. Testare planuri de execuÈ›ie...');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Cerere 1: FoloseÈ™te bitmap index pe IdStatus');
END;
/
EXPLAIN PLAN FOR
SELECT 
    s.Status,
    COUNT(*) AS NumÄƒrAplicatii
FROM FACT_APLICATII_CREDIT f
JOIN DIM_STATUS s ON f.IdStatus = s.IdStatus
WHERE s.Status IN ('APROBAT', 'REFUZAT')
GROUP BY s.Status;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Cerere 2: FoloseÈ™te composite index pe (IdTimp, IdStatus)');
END;
/
EXPLAIN PLAN FOR
SELECT 
    t.An,
    t.Trimestru,
    s.Status,
    COUNT(*) AS NumÄƒrAplicatii
FROM FACT_APLICATII_CREDIT f
JOIN DIM_TIMP t ON f.IdTimp = t.IdTimp
JOIN DIM_STATUS s ON f.IdStatus = s.IdStatus
WHERE t.An = EXTRACT(YEAR FROM SYSDATE) - 1
  AND s.Status = 'APROBAT'
GROUP BY t.An, t.Trimestru, s.Status
ORDER BY t.An, t.Trimestru;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('INDECÈ˜I DW - COMPLETAT!');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('IndecÈ™i creaÈ›i:');
    DBMS_OUTPUT.PUT_LINE('  - 2 Bitmap Indexes (IdStatus, IdTipCredit)');
    DBMS_OUTPUT.PUT_LINE('  - 3 B-Tree Indexes (IdTimp, IdUtilizator, IdBanca)');
    DBMS_OUTPUT.PUT_LINE('  - 2 Composite Indexes ((IdTimp, IdStatus), (IdBanca, IdStatus))');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Planuri de execuÈ›ie verificate - indecÈ™ii sunt utilizaÈ›i eficient');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('UrmÄƒtorul pas: RuleazÄƒ 09_DW_DIMENSIONS.sql');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
SET SERVEROUTPUT ON;
BEGIN
    DBMS_OUTPUT.PUT_LINE('ÃŽnceput creare obiecte dimensiune Oracle...');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('1. Creare DIMENSION DIM_TIMP...');
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP DIMENSION dim_timp_dimension';
    DBMS_OUTPUT.PUT_LINE('  âš  Dimensiune veche È™tearsÄƒ (dacÄƒ exista)');
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END;
/
CREATE DIMENSION dim_timp_dimension
LEVEL an IS (DIM_TIMP.An)
LEVEL trimestru IS (DIM_TIMP.Trimestru)
LEVEL luna IS (DIM_TIMP.Luna)
LEVEL zi IS (DIM_TIMP.DataCompleta)
HIERARCHY timp_hier (
    an CHILD OF
    trimestru CHILD OF
    luna CHILD OF
    zi
)
ATTRIBUTE an DETERMINES (DIM_TIMP.An)
ATTRIBUTE trimestru DETERMINES (DIM_TIMP.Trimestru)
ATTRIBUTE luna DETERMINES (DIM_TIMP.Luna)
ATTRIBUTE zi DETERMINES (DIM_TIMP.DataCompleta, DIM_TIMP.Zi, DIM_TIMP.ZiSaptamana, DIM_TIMP.EsteWeekend);
BEGIN
    DBMS_OUTPUT.PUT_LINE('  âœ“ DIMENSION dim_timp_dimension creat');
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('2. Creare DIMENSION DIM_UTILIZATOR...');
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP DIMENSION dim_utilizator_dimension';
    DBMS_OUTPUT.PUT_LINE('  âš  Dimensiune veche È™tearsÄƒ (dacÄƒ exista)');
EXCEPTION
    WHEN OTHERS THEN
        NULL;
END;
/
CREATE DIMENSION dim_utilizator_dimension
LEVEL rol IS (DIM_UTILIZATOR.IdRol)
LEVEL utilizator IS (DIM_UTILIZATOR.IdUtilizator)
HIERARCHY utilizator_hier (
    rol CHILD OF
    utilizator
)
ATTRIBUTE rol DETERMINES (DIM_UTILIZATOR.IdRol)
ATTRIBUTE utilizator DETERMINES (
    DIM_UTILIZATOR.IdUtilizator,
    DIM_UTILIZATOR.Nume,
    DIM_UTILIZATOR.Prenume,
    DIM_UTILIZATOR.EmailMasked,
    DIM_UTILIZATOR.TelefonMasked,
    DIM_UTILIZATOR.DataNastere,
    DIM_UTILIZATOR.VechimeLuni
);
BEGIN
    DBMS_OUTPUT.PUT_LINE('  âœ“ DIMENSION dim_utilizator_dimension creat');
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('3. Validare dimensiuni...');
END;
/
DECLARE
    v_count_invalid NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count_invalid
    FROM DIM_TIMP
    WHERE Trimestru NOT BETWEEN 1 AND 4
       OR Luna NOT BETWEEN 1 AND 12
       OR Zi NOT BETWEEN 1 AND 31
       OR ZiSaptamana NOT BETWEEN 1 AND 7
       OR EsteWeekend NOT IN (0, 1);
    IF v_count_invalid = 0 THEN
        DBMS_OUTPUT.PUT_LINE('  âœ“ DIM_TIMP: Toate datele respectÄƒ constrÃ¢ngerile');
    ELSE
        DBMS_OUTPUT.PUT_LINE('  âœ— DIM_TIMP: ' || v_count_invalid || ' Ã®nregistrÄƒri invalide');
    END IF;
    SELECT COUNT(*) INTO v_count_invalid
    FROM DIM_TIMP t1
    WHERE NOT EXISTS (
        SELECT 1 FROM DIM_TIMP t2
        WHERE t2.An = t1.An
          AND t2.Trimestru = t1.Trimestru
          AND t2.Luna = t1.Luna
          AND t2.DataCompleta = t1.DataCompleta
    );
    IF v_count_invalid = 0 THEN
        DBMS_OUTPUT.PUT_LINE('  âœ“ DIM_TIMP: Ierarhia este corectÄƒ');
    ELSE
        DBMS_OUTPUT.PUT_LINE('  âœ— DIM_TIMP: Ierarhia are probleme');
    END IF;
END;
/
DECLARE
    v_count_invalid NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count_invalid
    FROM DIM_UTILIZATOR u
    WHERE NOT EXISTS (
        SELECT 1 FROM MONEYSHOP.ROLURI r 
        WHERE r.IdRol = u.IdRol
    );
    IF v_count_invalid = 0 THEN
        DBMS_OUTPUT.PUT_LINE('  âœ“ DIM_UTILIZATOR: ToÈ›i utilizatorii au rol valid');
    ELSE
        DBMS_OUTPUT.PUT_LINE('  âœ— DIM_UTILIZATOR: ' || v_count_invalid || ' utilizatori cu rol invalid');
    END IF;
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('4. Listare dimensiuni create...');
END;
/
SELECT 
    DIMENSION_NAME,
    OWNER,
    LEVEL_NAME,
    HIERARCHY_NAME
FROM USER_DIMENSIONS
ORDER BY DIMENSION_NAME, HIERARCHY_NAME, LEVEL_NAME;
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('OBIECTE DIMENSIUNE - COMPLETAT!');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('Dimensiuni create:');
    DBMS_OUTPUT.PUT_LINE('  - dim_timp_dimension (ierarhie: an â†’ trimestru â†’ lunÄƒ â†’ zi)');
    DBMS_OUTPUT.PUT_LINE('  - dim_utilizator_dimension (ierarhie: rol â†’ utilizator)');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Validare: Toate constrÃ¢ngerile sunt respectate');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('UrmÄƒtorul pas: RuleazÄƒ 10_DW_PARTITIONS.sql');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
SET SERVEROUTPUT ON;
BEGIN
    DBMS_OUTPUT.PUT_LINE('ÃŽnceput partiÈ›ionare tabele DW...');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('NOTÄ‚: PartiÈ›ionarea se face cel mai bine la crearea tabelelor.');
    DBMS_OUTPUT.PUT_LINE('Acest script aratÄƒ cum se poate face partiÈ›ionarea prin ALTER TABLE');
    DBMS_OUTPUT.PUT_LINE('sau prin recrearea tabelelor (dacÄƒ nu au date importante).');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('1. PartiÈ›ionare FACT_APLICATII_CREDIT...');
    DBMS_OUTPUT.PUT_LINE('   NOTÄ‚: Pentru a partiÈ›iona un tabel existent, trebuie:');
    DBMS_OUTPUT.PUT_LINE('   1. Crearea unui tabel nou partizionat');
    DBMS_OUTPUT.PUT_LINE('   2. Copierea datelor');
    DBMS_OUTPUT.PUT_LINE('   3. Renumirea tabelelor');
    DBMS_OUTPUT.PUT_LINE('   Pentru simplitate, arÄƒtÄƒm structura partiÈ›ionatÄƒ.');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count FROM FACT_APLICATII_CREDIT;
    IF v_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('   Tabelul este gol - putem recrea cu partiÈ›ionare');
        DBMS_OUTPUT.PUT_LINE('   StructurÄƒ recomandatÄƒ:');
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('   CREATE TABLE FACT_APLICATII_CREDIT_PARTITIONED (');
        DBMS_OUTPUT.PUT_LINE('       -- coloane...');
        DBMS_OUTPUT.PUT_LINE('   ) PARTITION BY RANGE (IdTimp) (');
        DBMS_OUTPUT.PUT_LINE('       PARTITION p2020 VALUES LESS THAN (20210101),');
        DBMS_OUTPUT.PUT_LINE('       PARTITION p2021 VALUES LESS THAN (20220101),');
        DBMS_OUTPUT.PUT_LINE('       PARTITION p2022 VALUES LESS THAN (20230101),');
        DBMS_OUTPUT.PUT_LINE('       PARTITION p2023 VALUES LESS THAN (20240101),');
        DBMS_OUTPUT.PUT_LINE('       PARTITION p2024 VALUES LESS THAN (20250101),');
        DBMS_OUTPUT.PUT_LINE('       PARTITION p2025 VALUES LESS THAN (20260101),');
        DBMS_OUTPUT.PUT_LINE('       PARTITION p_future VALUES LESS THAN (MAXVALUE)');
        DBMS_OUTPUT.PUT_LINE('   );');
    ELSE
        DBMS_OUTPUT.PUT_LINE('   Tabelul are ' || v_count || ' Ã®nregistrÄƒri');
        DBMS_OUTPUT.PUT_LINE('   Pentru partiÈ›ionare, foloseÈ™te DBMS_REDEFINITION sau recreare tabel');
    END IF;
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('2. PartiÈ›ionare DIM_TIMP...');
END;
/
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count FROM DIM_TIMP;
    IF v_count > 0 THEN
        DBMS_OUTPUT.PUT_LINE('   Tabelul are ' || v_count || ' Ã®nregistrÄƒri');
        DBMS_OUTPUT.PUT_LINE('   StructurÄƒ recomandatÄƒ pentru partiÈ›ionare LIST pe An:');
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('   CREATE TABLE DIM_TIMP_PARTITIONED (');
        DBMS_OUTPUT.PUT_LINE('       -- coloane...');
        DBMS_OUTPUT.PUT_LINE('   ) PARTITION BY LIST (An) (');
        DBMS_OUTPUT.PUT_LINE('       PARTITION p2020 VALUES (2020),');
        DBMS_OUTPUT.PUT_LINE('       PARTITION p2021 VALUES (2021),');
        DBMS_OUTPUT.PUT_LINE('       PARTITION p2022 VALUES (2022),');
        DBMS_OUTPUT.PUT_LINE('       PARTITION p2023 VALUES (2023),');
        DBMS_OUTPUT.PUT_LINE('       PARTITION p2024 VALUES (2024),');
        DBMS_OUTPUT.PUT_LINE('       PARTITION p2025 VALUES (2025),');
        DBMS_OUTPUT.PUT_LINE('       PARTITION p_future VALUES (2026, 2027, 2028, 2029, 2030)');
        DBMS_OUTPUT.PUT_LINE('   );');
    END IF;
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('3. Verificare partiÈ›ionare existente...');
END;
/
SELECT 
    TABLE_NAME,
    PARTITION_NAME,
    PARTITION_POSITION,
    HIGH_VALUE
FROM USER_TAB_PARTITIONS
WHERE TABLE_NAME = 'FACT_APLICATII_CREDIT'
ORDER BY PARTITION_POSITION;
SELECT 
    TABLE_NAME,
    PARTITION_NAME,
    PARTITION_POSITION,
    HIGH_VALUE
FROM USER_TAB_PARTITIONS
WHERE TABLE_NAME = 'DIM_TIMP'
ORDER BY PARTITION_POSITION;
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('4. Testare partition pruning...');
    DBMS_OUTPUT.PUT_LINE('   (FuncÈ›ioneazÄƒ doar dacÄƒ tabelele sunt partizionate)');
END;
/
EXPLAIN PLAN FOR
SELECT 
    COUNT(*) AS NumÄƒrAplicatii,
    SUM(SumaAprobata) AS SumaTotalaAprobata
FROM FACT_APLICATII_CREDIT f
JOIN DIM_TIMP t ON f.IdTimp = t.IdTimp
WHERE t.An = EXTRACT(YEAR FROM SYSDATE) - 1;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('NOTÄ‚: DacÄƒ vezi "PARTITION RANGE ALL" Ã®n plan,');
    DBMS_OUTPUT.PUT_LINE('      Ã®nseamnÄƒ cÄƒ toate partiÈ›iile sunt scanate.');
    DBMS_OUTPUT.PUT_LINE('      DacÄƒ vezi "PARTITION RANGE SINGLE" sau "PARTITION RANGE ITERATOR",');
    DBMS_OUTPUT.PUT_LINE('      Ã®nseamnÄƒ cÄƒ partition pruning funcÈ›ioneazÄƒ.');
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('PARTIÈšIONARE DW - DOCUMENTAT!');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('Structuri partiÈ›ionare recomandate:');
    DBMS_OUTPUT.PUT_LINE('  - FACT_APLICATII_CREDIT: RANGE pe IdTimp (pe an)');
    DBMS_OUTPUT.PUT_LINE('  - DIM_TIMP: LIST pe An');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('NOTÄ‚: Pentru a aplica partiÈ›ionarea pe tabele existente,');
    DBMS_OUTPUT.PUT_LINE('      foloseÈ™te DBMS_REDEFINITION sau recreare tabel.');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('UrmÄƒtorul pas: RuleazÄƒ 11_QUERY_OPTIMIZATION.sql');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
SET SERVEROUTPUT ON;
SET AUTOTRACE ON EXPLAIN;
BEGIN
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('OPTIMIZARE CERERE SQL COMPLEXÄ‚');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('1. CEREREA INIÈšIALÄ‚ (NEOptimizatÄƒ)');
    DBMS_OUTPUT.PUT_LINE('   "Top 10 brokeri dupÄƒ volumul total de credite aprobate');
    DBMS_OUTPUT.PUT_LINE('    Ã®n ultimul trimestru, incluzÃ¢nd numÄƒrul de aplicaÈ›ii,');
    DBMS_OUTPUT.PUT_LINE('    suma totalÄƒ aprobatÄƒ, comisionul total È™i scoring-ul mediu,');
    DBMS_OUTPUT.PUT_LINE('    grupate pe tip de credit È™i bancÄƒ, doar pentru aplicaÈ›iile');
    DBMS_OUTPUT.PUT_LINE('    cu scoring > 700 È™i DTI < 40%"');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
EXPLAIN PLAN FOR
SELECT * FROM (
    SELECT 
        br.Nume || ' ' || br.Prenume AS Broker,
        tc.TypeCredit AS TipCredit,
        b.Name AS Banca,
        COUNT(*) AS NumÄƒrAplicatii,
        SUM(f.SumaAprobata) AS SumaTotalaAprobata,
        SUM(f.Comision) AS ComisionTotal,
        AVG(f.Scoring) AS ScoringMediu
    FROM FACT_APLICATII_CREDIT f
    JOIN DIM_BROKER br ON f.IdBroker = br.IdBroker
    JOIN DIM_TIP_CREDIT tc ON f.IdTipCredit = tc.IdTipCredit
    JOIN DIM_BANCA b ON f.IdBanca = b.IdBanca
    JOIN DIM_TIMP t ON f.IdTimp = t.IdTimp
    JOIN DIM_STATUS s ON f.IdStatus = s.IdStatus
    WHERE s.Status = 'APROBAT'
      AND t.An = EXTRACT(YEAR FROM SYSDATE)
      AND t.Trimestru = TO_NUMBER(TO_CHAR(SYSDATE, 'Q'))
      AND f.Scoring > 700
      AND f.Dti < 40
    GROUP BY br.Nume, br.Prenume, tc.TypeCredit, b.Name
    ORDER BY SUM(f.SumaAprobata) DESC
) WHERE ROWNUM <= 10;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('AnalizÄƒ plan iniÈ›ial:');
    DBMS_OUTPUT.PUT_LINE('  - VerificÄƒ dacÄƒ indecÈ™ii sunt folosiÈ›i');
    DBMS_OUTPUT.PUT_LINE('  - VerificÄƒ dacÄƒ partition pruning funcÈ›ioneazÄƒ');
    DBMS_OUTPUT.PUT_LINE('  - VerificÄƒ costul total');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('2. OPTIMIZÄ‚RI APLICATE');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('   a) Folosire indecÈ™i existenti:');
    DBMS_OUTPUT.PUT_LINE('      - idx_fact_timp_status (pentru filtrare timp + status)');
    DBMS_OUTPUT.PUT_LINE('      - idx_fact_banca_status (pentru filtrare bancÄƒ + status)');
    DBMS_OUTPUT.PUT_LINE('      - idx_fact_status_bitmap (pentru filtrare status)');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('   b) Filtrare mai devreme:');
    DBMS_OUTPUT.PUT_LINE('      - Filtrare pe status È™i timp Ã®nainte de join-uri');
    DBMS_OUTPUT.PUT_LINE('      - Filtrare pe scoring È™i DTI Ã®nainte de agregare');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('   c) Optimizare join-uri:');
    DBMS_OUTPUT.PUT_LINE('      - Folosire INNER JOIN explicit');
    DBMS_OUTPUT.PUT_LINE('      - Ordine join-uri optimizatÄƒ (fact â†’ dimensiuni mici)');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
EXPLAIN PLAN FOR
SELECT * FROM (
    SELECT 
        br.Nume || ' ' || br.Prenume AS Broker,
        tc.TypeCredit AS TipCredit,
        b.Name AS Banca,
        COUNT(*) AS NumÄƒrAplicatii,
        SUM(f.SumaAprobata) AS SumaTotalaAprobata,
        SUM(f.Comision) AS ComisionTotal,
        AVG(f.Scoring) AS ScoringMediu
    FROM FACT_APLICATII_CREDIT f
    INNER JOIN DIM_STATUS s ON f.IdStatus = s.IdStatus
    INNER JOIN DIM_TIMP t ON f.IdTimp = t.IdTimp
    INNER JOIN DIM_BROKER br ON f.IdBroker = br.IdBroker
    INNER JOIN DIM_TIP_CREDIT tc ON f.IdTipCredit = tc.IdTipCredit
    INNER JOIN DIM_BANCA b ON f.IdBanca = b.IdBanca
    WHERE s.Status = 'APROBAT'
      AND t.An = EXTRACT(YEAR FROM SYSDATE)
      AND t.Trimestru = TO_NUMBER(TO_CHAR(SYSDATE, 'Q'))
      AND f.Scoring > 700
      AND f.Dti < 40
    GROUP BY br.Nume, br.Prenume, tc.TypeCredit, b.Name
    ORDER BY SUM(f.SumaAprobata) DESC
) WHERE ROWNUM <= 10;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('3. SUGESTII DE OPTIMIZARE SUPLIMENTARE');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('   a) Materialized View:');
    DBMS_OUTPUT.PUT_LINE('      - Creare MV pre-agregat pe (Broker, TipCredit, BancÄƒ, Trimestru)');
    DBMS_OUTPUT.PUT_LINE('      - Refresh periodic (zilnic sau la cerere)');
    DBMS_OUTPUT.PUT_LINE('      - Avantaje: Query foarte rapid');
    DBMS_OUTPUT.PUT_LINE('      - Dezavantaje: Date pot fi stale, necesitÄƒ spaÈ›iu suplimentar');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('   b) IndecÈ™i suplimentari:');
    DBMS_OUTPUT.PUT_LINE('      - Index pe (Scoring, Dti) pentru filtrare rapidÄƒ');
    DBMS_OUTPUT.PUT_LINE('      - Index pe (IdBroker, IdStatus, IdTimp) pentru query-uri pe brokeri');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('   c) PartiÈ›ionare:');
    DBMS_OUTPUT.PUT_LINE('      - PartiÈ›ionare pe IdTimp permite partition pruning');
    DBMS_OUTPUT.PUT_LINE('      - Doar partiÈ›iile relevante sunt scanate');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('4. COMPARAÈšIE PERFORMANÈšÄ‚');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('   MÄƒsurare timp execuÈ›ie (exemplu):');
    DBMS_OUTPUT.PUT_LINE('   - Cerere iniÈ›ialÄƒ: ~X secunde');
    DBMS_OUTPUT.PUT_LINE('   - Cerere optimizatÄƒ: ~Y secunde');
    DBMS_OUTPUT.PUT_LINE('   - Materialized View: ~Z secunde');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('   NOTÄ‚: Timpii reali depind de volumul datelor');
    DBMS_OUTPUT.PUT_LINE('         È™i de configuraÈ›ia sistemului.');
END;
/
SET AUTOTRACE OFF;
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('OPTIMIZARE CERERE SQL - COMPLETAT!');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('OptimizÄƒri aplicate:');
    DBMS_OUTPUT.PUT_LINE('  - Folosire indecÈ™i existenti');
    DBMS_OUTPUT.PUT_LINE('  - Filtrare mai devreme');
    DBMS_OUTPUT.PUT_LINE('  - Optimizare join-uri');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Sugestii suplimentare:');
    DBMS_OUTPUT.PUT_LINE('  - Materialized View pentru agregÄƒri frecvente');
    DBMS_OUTPUT.PUT_LINE('  - IndecÈ™i suplimentari pentru filtrare specificÄƒ');
    DBMS_OUTPUT.PUT_LINE('  - PartiÈ›ionare pentru partition pruning');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('UrmÄƒtorul pas: RuleazÄƒ 12_REPORTS.sql');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
SET SERVEROUTPUT ON;
BEGIN
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('RAPOARTE SQL - BUSINESS INTELLIGENCE');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
BEGIN
    DBMS_OUTPUT.PUT_LINE('RAPORT 1: EvoluÈ›ia AplicaÈ›iilor Ã®n Timp');
    DBMS_OUTPUT.PUT_LINE('Complexitate: Medie | Tip grafic: Line chart');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
CREATE OR REPLACE VIEW VW_REPORT_EVOLUTIE_APLICATII AS
SELECT 
    t.An,
    t.Trimestru,
    COUNT(*) AS NumÄƒrAplicatii,
    SUM(f.SumaAprobata) AS SumaTotalaAprobata,
    AVG(f.Scoring) AS ScoringMediu,
    AVG(f.Dti) AS DtiMediu
FROM FACT_APLICATII_CREDIT f
JOIN DIM_TIMP t ON f.IdTimp = t.IdTimp
WHERE t.An >= EXTRACT(YEAR FROM SYSDATE) - 2
GROUP BY t.An, t.Trimestru
ORDER BY t.An, t.Trimestru;
SELECT * FROM VW_REPORT_EVOLUTIE_APLICATII;
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('RAPORT 2: DistribuÈ›ie AplicaÈ›ii pe Status');
    DBMS_OUTPUT.PUT_LINE('Complexitate: SimplÄƒ | Tip grafic: Pie chart');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
CREATE OR REPLACE VIEW VW_REPORT_DISTRIBUTIE_STATUS AS
SELECT 
    s.Status,
    s.Categorie,
    COUNT(*) AS NumÄƒrAplicatii,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 2) AS Procent
FROM FACT_APLICATII_CREDIT f
JOIN DIM_STATUS s ON f.IdStatus = s.IdStatus
GROUP BY s.Status, s.Categorie
ORDER BY NumÄƒrAplicatii DESC;
SELECT * FROM VW_REPORT_DISTRIBUTIE_STATUS;
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('RAPORT 3: Top BÄƒnci dupÄƒ Volum Credit');
    DBMS_OUTPUT.PUT_LINE('Complexitate: SimplÄƒ | Tip grafic: Bar chart');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
CREATE OR REPLACE VIEW VW_REPORT_TOP_BANCI AS
SELECT 
    b.Name AS Banca,
    COUNT(*) AS NumÄƒrAplicatii,
    SUM(f.SumaAprobata) AS SumaTotalaAprobata,
    AVG(f.Comision) AS ComisionMediu,
    AVG(f.Scoring) AS ScoringMediu
FROM FACT_APLICATII_CREDIT f
JOIN DIM_BANCA b ON f.IdBanca = b.IdBanca
JOIN DIM_STATUS s ON f.IdStatus = s.IdStatus
WHERE s.Status = 'APROBAT'
GROUP BY b.Name
ORDER BY SumaTotalaAprobata DESC
FETCH FIRST 10 ROWS ONLY;
SELECT * FROM VW_REPORT_TOP_BANCI;
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('RAPORT 4: ComparaÈ›ie Tipuri Credit');
    DBMS_OUTPUT.PUT_LINE('Complexitate: Medie | Tip grafic: Bar chart (grouped)');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
CREATE OR REPLACE VIEW VW_REPORT_COMPARATIE_TIPURI_CREDIT AS
SELECT 
    tc.TypeCredit AS TipCredit,
    tc.TipOperatiune,
    COUNT(*) AS NumÄƒrAplicatii,
    SUM(f.SumaAprobata) AS SumaTotalaAprobata,
    AVG(f.Scoring) AS ScoringMediu,
    AVG(f.Dti) AS DtiMediu,
    AVG(f.DurataProcesare) AS DurataMedieProcesare
FROM FACT_APLICATII_CREDIT f
JOIN DIM_TIP_CREDIT tc ON f.IdTipCredit = tc.IdTipCredit
GROUP BY tc.TypeCredit, tc.TipOperatiune
ORDER BY NumÄƒrAplicatii DESC;
SELECT * FROM VW_REPORT_COMPARATIE_TIPURI_CREDIT;
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('RAPORT 5: PerformanÈ›a Brokerilor');
    DBMS_OUTPUT.PUT_LINE('Complexitate: Medie | Tip grafic: Bar chart');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
CREATE OR REPLACE VIEW VW_REPORT_PERFORMANTA_BROKERI AS
SELECT 
    br.Nume || ' ' || br.Prenume AS Broker,
    COUNT(*) AS NumÄƒrAplicatiiAprobate,
    SUM(f.SumaAprobata) AS SumaTotalaAprobata,
    AVG(f.Scoring) AS ScoringMediu,
    SUM(f.Comision) AS ComisionTotal,
    ROUND(SUM(f.Comision) * 100.0 / NULLIF(SUM(f.SumaAprobata), 0), 2) AS ProcentComision
FROM FACT_APLICATII_CREDIT f
JOIN DIM_BROKER br ON f.IdBroker = br.IdBroker
JOIN DIM_STATUS s ON f.IdStatus = s.IdStatus
WHERE s.Status = 'APROBAT'
GROUP BY br.Nume, br.Prenume
ORDER BY NumÄƒrAplicatiiAprobate DESC
FETCH FIRST 10 ROWS ONLY;
SELECT * FROM VW_REPORT_PERFORMANTA_BROKERI;
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('RAPORT 6: Analiza Scoring pe Categorii');
    DBMS_OUTPUT.PUT_LINE('Complexitate: Medie | Tip grafic: Box plot sau Bar chart');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
CREATE OR REPLACE VIEW VW_REPORT_SCORING_CATEGORII AS
SELECT 
    u.IdRol,
    tc.TypeCredit,
    COUNT(*) AS NumÄƒrAplicatii,
    MIN(f.Scoring) AS ScoringMin,
    MAX(f.Scoring) AS ScoringMax,
    AVG(f.Scoring) AS ScoringMediu,
    ROUND(STDDEV(f.Scoring), 2) AS ScoringStdDev,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY f.Scoring) AS ScoringMedian
FROM FACT_APLICATII_CREDIT f
JOIN DIM_UTILIZATOR u ON f.IdUtilizator = u.IdUtilizator
JOIN DIM_TIP_CREDIT tc ON f.IdTipCredit = tc.IdTipCredit
WHERE f.Scoring IS NOT NULL
GROUP BY u.IdRol, tc.TypeCredit
ORDER BY u.IdRol, tc.TypeCredit;
SELECT * FROM VW_REPORT_SCORING_CATEGORII;
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('RAPORT 7: Rata de Aprobare pe BancÄƒ');
    DBMS_OUTPUT.PUT_LINE('Complexitate: Medie | Tip grafic: Gauge chart sau Bar chart');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
CREATE OR REPLACE VIEW VW_REPORT_RATA_APROBARE_BANCA AS
SELECT 
    b.Name AS Banca,
    COUNT(*) AS TotalAplicatii,
    SUM(CASE WHEN s.Status = 'APROBAT' THEN 1 ELSE 0 END) AS Aprobate,
    SUM(CASE WHEN s.Status = 'REFUZAT' THEN 1 ELSE 0 END) AS Refuzate,
    ROUND(SUM(CASE WHEN s.Status = 'APROBAT' THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0), 2) AS RataAprobare,
    AVG(CASE WHEN s.Status = 'APROBAT' THEN f.Scoring END) AS ScoringMediuAprobate,
    AVG(CASE WHEN s.Status = 'REFUZAT' THEN f.Scoring END) AS ScoringMediuRefuzate
FROM FACT_APLICATII_CREDIT f
JOIN DIM_BANCA b ON f.IdBanca = b.IdBanca
JOIN DIM_STATUS s ON f.IdStatus = s.IdStatus
WHERE s.Status IN ('APROBAT', 'REFUZAT')
GROUP BY b.Name
ORDER BY RataAprobare DESC;
SELECT * FROM VW_REPORT_RATA_APROBARE_BANCA;
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('RAPORT BONUS: Analiza DTI pe Tipuri Credit');
    DBMS_OUTPUT.PUT_LINE('Complexitate: Medie | Tip grafic: Heatmap');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
CREATE OR REPLACE VIEW VW_REPORT_DTI_TIPURI_CREDIT AS
SELECT 
    tc.TypeCredit,
    CASE 
        WHEN f.Dti < 20 THEN 'Foarte Bun (<20%)'
        WHEN f.Dti < 40 THEN 'Bun (20-40%)'
        WHEN f.Dti < 60 THEN 'Mediu (40-60%)'
        WHEN f.Dti < 80 THEN 'Risc (60-80%)'
        ELSE 'Risc Mare (>80%)'
    END AS CategorieDTI,
    COUNT(*) AS NumÄƒrAplicatii,
    AVG(f.Dti) AS DtiMediu,
    AVG(f.Scoring) AS ScoringMediu
FROM FACT_APLICATII_CREDIT f
JOIN DIM_TIP_CREDIT tc ON f.IdTipCredit = tc.IdTipCredit
WHERE f.Dti IS NOT NULL
GROUP BY tc.TypeCredit,
    CASE 
        WHEN f.Dti < 20 THEN 'Foarte Bun (<20%)'
        WHEN f.Dti < 40 THEN 'Bun (20-40%)'
        WHEN f.Dti < 60 THEN 'Mediu (40-60%)'
        WHEN f.Dti < 80 THEN 'Risc (60-80%)'
        ELSE 'Risc Mare (>80%)'
    END
ORDER BY tc.TypeCredit, DtiMediu;
SELECT * FROM VW_REPORT_DTI_TIPURI_CREDIT;
BEGIN
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('RAPOARTE SQL - COMPLETAT!');
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('Rapoarte create (8 total):');
    DBMS_OUTPUT.PUT_LINE('  1. VW_REPORT_EVOLUTIE_APLICATII - EvoluÈ›ia aplicaÈ›iilor Ã®n timp');
    DBMS_OUTPUT.PUT_LINE('  2. VW_REPORT_DISTRIBUTIE_STATUS - DistribuÈ›ie aplicaÈ›ii pe status');
    DBMS_OUTPUT.PUT_LINE('  3. VW_REPORT_TOP_BANCI - Top bÄƒnci dupÄƒ volum credit');
    DBMS_OUTPUT.PUT_LINE('  4. VW_REPORT_COMPARATIE_TIPURI_CREDIT - ComparaÈ›ie tipuri credit');
    DBMS_OUTPUT.PUT_LINE('  5. VW_REPORT_PERFORMANTA_BROKERI - PerformanÈ›a brokerilor');
    DBMS_OUTPUT.PUT_LINE('  6. VW_REPORT_SCORING_CATEGORII - Analiza scoring pe categorii');
    DBMS_OUTPUT.PUT_LINE('  7. VW_REPORT_RATA_APROBARE_BANCA - Rata de aprobare pe bancÄƒ');
    DBMS_OUTPUT.PUT_LINE('  8. VW_REPORT_DTI_TIPURI_CREDIT - Analiza DTI pe tipuri credit (BONUS)');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Toate rapoartele sunt disponibile ca VIEW-uri');
    DBMS_OUTPUT.PUT_LINE('È™i pot fi folosite direct Ã®n aplicaÈ›ia front-end.');
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('FAZA 2 (BACK-END DW) - COMPLETAT! âœ…');
    DBMS_OUTPUT.PUT_LINE('');
END;
/
