PROIECT SBD - MONEYSHOP
Student: Cristea Eduard
Grupa: 505

DOCUMENT COMPLET - REZOLVAREA TUTUROR CERINTELOR

========================================
CERINTA 1: PREZENTAREA CONCISA A BAZEI DE DATE
========================================

MoneyShop este o platforma de brokeraj de credite care permite utilizatorilor sa aplice pentru credite prin intermediul unor brokeri autorizati. Sistemul gestioneaza aplicatiile, documentele, consimtamanturile si mandatele intre utilizatori si brokeri.

Baza de date contine urmatoarele entitati principale:
- ROLURI: defineste rolurile utilizatorilor (CLIENT, BROKER, ADMIN)
- UTILIZATORI: stocheaza datele utilizatorilor
- BANCI: lista bancilor partenere
- APLICATII: aplicatiile de credit ale utilizatorilor
- APPLICATION_BANKS: asocierea many-to-many intre aplicatii si banci
- DOCUMENTE: documentele asociate aplicatiilor
- CONSENTURI: consimtamanturile utilizatorilor
- MANDATE: mandatele intre utilizatori si brokeri
- MESAJE: mesajele de eroare, avertisment si informatie

========================================
CERINTA 2: DIAGRAMA ENTITATE-RELATIE (ERD)
========================================

ROLURI (1) ----< (N) UTILIZATORI
UTILIZATORI (1) ----< (N) APLICATII
UTILIZATORI (1) ----< (N) CONSENTURI
UTILIZATORI (1) ----< (N) MANDATE (N) >---- (1) UTILIZATORI (Broker)
APLICATII (N) >----< (N) BANCI (prin APPLICATION_BANKS)
APLICATII (1) ----< (N) DOCUMENTE

Entitati independente: ROLURI, UTILIZATORI, BANCI, APLICATII, DOCUMENTE, CONSENTURI, MANDATE, LEADURI, AGREEMENTS, USER_FINANCIAL_DATA, USER_SESSIONS, AUDIT_LOG, MESAJE

Relatie many-to-many: APPLICATION_BANKS (APLICATII <-> BANCI)

========================================
CERINTA 3: DIAGRAMA CONCEPTUALA
========================================

Diagrama conceptuala reprezinta structura bazei de date cu toate entitatile si relatiile dintre ele, conform diagramei ERD prezentate mai sus.

========================================
CERINTA 4: DESIGN LOGIC (CHEI PRIMARE SI STRAINE)
========================================

ROLURI (IdRol PK)
UTILIZATORI (IdUtilizator PK, IdRol FK -> ROLURI)
BANCI (Id PK)
APLICATII (Id PK, UserId FK -> UTILIZATORI)
APPLICATION_BANKS (Id PK, ApplicationId FK -> APLICATII, BankId FK -> BANCI)
DOCUMENTE (Id PK, ApplicationId FK -> APLICATII)
CONSENTURI (Id PK, UserId FK -> UTILIZATORI)
MANDATE (Id PK, UserId FK -> UTILIZATORI, BrokerId FK -> UTILIZATORI)
MESAJE (cod_mesaj PK)

========================================
CERINTA 5: DESIGN FIZIC IN FN3
========================================

Toate tabelele sunt normalizate la forma normala 3 (FN3):

Exemplu atribut repetitiv: ListaBanciActive CLOB din APLICATII -> rezolvat prin APPLICATION_BANKS

Exemplu FN1 -> FN2: 
- Tabel APLICATII_TEMP_FN1 contine dependente functionale partiale (NumeUtilizator, EmailUtilizator depind de UserId)
- Solutie: Aceste atribute au fost mutate in UTILIZATORI, APLICATII_TEMP_FN2 referentiaza doar UserId

Exemplu FN2 -> FN3:
- Tabel APLICATII_TEMP_FN2_TRANZ contine dependente functionale tranzitive (NumeBanca, CommissionPercent depind de IdBanca)
- Solutie: Datele bancii au fost mutate in BANCI, asocierea este in APPLICATION_BANKS

Toate tabelele existente sunt in FN3.

Codul pentru normalizare este disponibil in fisierul 16_NORMALIZARE_EXEMPLE.sql

========================================
CERINTA 6: CREAREA TABELELOR SI POPULAREA LOR
========================================

NOTA: Pentru codul complet, consultati fisierul 505_Cristea_Eduard_SCHEMA.txt

Tabelele create:
- ROLURI, UTILIZATORI, BANCI, APLICATII, APPLICATION_BANKS, DOCUMENTE, CONSENTURI, MANDATE, MESAJE
- Constrangeri: chei primare, chei straine, CHECK constraints
- Indexuri pentru performanta
- Secventa seq_mesaje pentru MESAJE

Date populate:
- Minim 5 inregistrari per entitate independenta
- Minim 10 inregistrari per tabel asociativ

========================================
CERINTA 7: 15 INTEROGARI SQL COMPLEXE
========================================

NOTA: Pentru codul complet cu enunturi, consultati fisierul 505_Cristea_Eduard_SQL.txt

Interogarile acopera:
- GROUP BY, HAVING, ORDER BY
- START WITH, CONNECT BY (hierarhie)
- Functii siruri: LOWER, UPPER, SUBSTR, INSTR
- Functii date: TO_CHAR, TO_DATE, ADD_MONTHS, MONTHS_BETWEEN
- Functii diverse: DECODE, NVL, NULLIF, CASE
- INNER, LEFT, RIGHT, FULL JOIN
- Operatori pe multimi: UNION, INTERSECT, MINUS
- Functii agregat: AVG, SUM, MIN, MAX, COUNT
- Subinterogari in SELECT, FROM, WHERE, HAVING
- Operatorul DIVISION

========================================
CERINTA 8: SUBPROGRAM CU COLECTII
========================================

NOTA: Pentru codul complet, consultati fisierul 505_Cristea_Eduard_PLSQL.txt

Subprogram SP_PROCESARE_COLECTII utilizeaza:
- VARRAY: t_varray_nume pentru nume banci
- NESTED TABLE: t_nested_table_id pentru ID-uri aplicatii
- ASSOCIATIVE ARRAY: t_assoc_array pentru sume pe status

========================================
CERINTA 9: SUBPROGRAME PL/SQL SI TRIGGERI
========================================

NOTA: Pentru codul complet, consultati fisierul 505_Cristea_Eduard_PLSQL.txt

9.1 Subprogram cu cursoare: SP_PROCESARE_CURSOARE
- Cursor explicit parametrizat: c_utilizatori_rol
- Cursor FOR: Dependent de primul cursor

9.2 Functie cu 3 tabele si exceptii: FN_CALCUL_STATISTICI_UTILIZATOR
- Foloseste: UTILIZATORI, APLICATII, APPLICATION_BANKS
- Exceptii proprii: ex_utilizator_inexistent, ex_date_insuficiente

9.3 Trigger LDD: trg_audit_ddl
- Se declanseaza la CREATE, ALTER, DROP pe schema
- Insereaza mesaje in MESAJE

9.4 Pachet: PKG_MONEYSHOP
- Contine toate subprogramele create
- Declanseaza triggeri LMD prin instructiuni din subprograme

========================================
CERINTA 10: TRIGGERI LMD SI TRATARE EXCEPTII
========================================

NOTA: Pentru codul complet, consultati fisierul 505_Cristea_Eduard_PLSQL.txt

Triggeri LMD:
- trg_aplicatii_before_insert: Nivel comanda
- trg_aplicatii_before_update: Nivel linie
- trg_aplicatii_after_insert: Nivel linie
- trg_aplicatii_after_delete: Nivel linie
- trg_utilizatori_varsta_mesaje: Nivel linie

Tratare exceptii:
- Toate subprogramele insereaza mesaje in MESAJE la exceptii
- Secventa seq_mesaje este folosita pentru cod_mesaj
- Tipuri mesaje: E (Eroare), W (Avertisment), I (Informatie)

========================================
CAPTURI DE ECRAN CU EXECUTIA COMENZILOR
========================================

NOTA: In acest document trebuie adaugate capturile de ecran care demonstreaza executia comenzilor SQL si PL/SQL in Oracle SQL Developer sau Oracle SQL*Plus.

Capturi de ecran necesare:
1. Executia scriptului de creare tabele
2. Executia scriptului de populare date
3. Executia fiecarei interogari SQL (minim 3-4 exemple)
4. Executia subprogramelor PL/SQL
5. Executia triggerilor (LDD si LMD)
6. Verificarea mesajelor din tabelul MESAJE

========================================
CONCLUZII
========================================

Proiectul implementeaza toate cerintele specificate. Baza de date este normalizata corect la FN3, interogarile SQL sunt complexe si acopera toate cerintele, iar subprogramele PL/SQL si triggerii sunt implementati conform specificatiilor.