Perfect. Mai jos refac TOT pachetul, 100% in romana fara diacritice, inclusiv prompt, endpoint /chat Azure Functions cu JWT Entra ID, rate-limit + cost control, fallback 3.5 -> 4o mini, plus disclaimer legal.
Nota: numele modelelor si cheile din ENV raman in engleza (tehnic), dar toate mesajele/prompturile catre model sunt in romana fara diacritice. Referinta pricing si API: OpenAI Pricing + Responses API docs.
________________________________________
1) Prompt final MoneyShop (RO fara diacritice, fara nume banci)
Seteaza asta ca SYSTEM_PROMPT_MONEYSHOP (in config / admin):
Esti Asistentul Virtual MoneyShop pentru POPIX BROKERAGE CONSULTING S.R.L. (broker de credite / intermediar, NU institutie de credit).
Rolul tau este sa explici pe intelesul tuturor concepte de creditare, eligibilitate, documente, pasi de urmat si sa ajuti utilizatorii sa inteleaga rezultatele calculatoarelor MoneyShop.

REGULI OBLIGATORII (nu ai voie sa le incalci):
1) NU ai voie niciodata sa mentionezi, sa listezi, sa compari sau sa recomanzi nume de banci, IFN-uri sau branduri financiare.
   - Daca utilizatorul intreaba "Ce banca imi recomanzi?", refuza politicos si ofera doar criterii generale.
   - Foloseste doar termeni neutri: "o banca", "un creditor", "o institutie financiara", "un furnizor de credit".
2) NU promite aprobari si NU garanta dobanzi. Vorbeste doar estimativ si conditionat.
3) NU solicita si NU afisa date sensibile: CNP, serie/numar CI, numar complet card, parole, OTP.
   - Daca ai nevoie de informatii, cere doar date nesensibile: venit net aproximativ, tip contract, vechime, obligatii lunare totale.
4) Daca utilizatorul insista sa afle banca potrivita, raspunde astfel:
   - Explica criterii generale si recomanda programarea unei discutii cu un broker autorizat (uman).
5) Raspunsurile trebuie sa fie in romana fara diacritice, clare, scurte, structurate (liste/bullets).
6) Daca nu esti sigur, spune ce informatie minima lipseste si pune 1-2 intrebari scurte.

Conformitate:
- Ofera informatii educationale si ghidaj de proces, nu consultanta financiara/juridica personalizata.
- Include la final o nota scurta: "Rezultatele sunt estimative; aprobarea finala apartine creditorului."
Context intern (optional, tot RO fara diacritice)
Il poti pune ca mesaj "system" suplimentar la fiecare request (nu e obligatoriu):
Context: Utilizatorul este in MoneyShop si poate folosi calculator simplu sau verificat (ANAF/BC). Daca ajuta, cere rezultatele din calculator (valori numerice), dar nu cere date sensibile si nu mentiona banci.
________________________________________
2) Endpoint Azure Function POST /chat (JWT Entra + rate limit + cost control + fallback)
Dependențe
npm i openai zod @azure/cosmos jose
ENV (Function App)
•	OPENAI_API_KEY
•	OPENAI_MODEL_PRIMARY=gpt-3.5-turbo
•	OPENAI_MODEL_FALLBACK=gpt-4o-mini
•	CHAT_MAX_OUTPUT_TOKENS=350
•	CHAT_BUDGET_USD_MONTH=150
•	SYSTEM_PROMPT_MONEYSHOP (textul de mai sus)
•	JWT Entra:
o	AUTH_JWKS_URL=https://login.microsoftonline.com/<TENANT_ID>/discovery/v2.0/keys
o	AUTH_ISSUER=https://login.microsoftonline.com/<TENANT_ID>/v2.0
o	AUTH_AUDIENCE=<API_CLIENT_ID sau api://...>
•	Cosmos:
o	COSMOS_ENDPOINT, COSMOS_KEY, COSMOS_DB
o	COSMOS_CONTAINER_CHAT_RL=chat_rate_limits
o	COSMOS_CONTAINER_CHAT_USAGE=chat_usage
________________________________________
2.1 JWT user auth (RO fara diacritice)
src/shared/userAuth.ts
import { HttpRequest } from "@azure/functions";
import { jwtVerify, createRemoteJWKSet } from "jose";

const JWKS = process.env.AUTH_JWKS_URL ? createRemoteJWKSet(new URL(process.env.AUTH_JWKS_URL)) : null;

export async function requireUser(req: HttpRequest): Promise<{ sub: string; email?: string }> {
  const auth = req.headers.get("authorization") || "";
  const token = auth.startsWith("Bearer ") ? auth.slice(7) : "";
  if (!token || !JWKS) throw new Error("NO_AUTH");

  const { payload } = await jwtVerify(token, JWKS, {
    audience: process.env.AUTH_AUDIENCE,
    issuer: process.env.AUTH_ISSUER
  });

  const sub = String(payload.sub ?? "");
  if (!sub) throw new Error("NO_SUB");

  return { sub, email: payload.preferred_username as string | undefined };
}
________________________________________
2.2 Cosmos client
src/shared/cosmosClient.ts
import { CosmosClient, Container } from "@azure/cosmos";

const endpoint = process.env.COSMOS_ENDPOINT!;
const key = process.env.COSMOS_KEY!;
const dbId = process.env.COSMOS_DB!;

const client = new CosmosClient({ endpoint, key });

export function getContainer(containerId: string): Container {
  if (!endpoint || !key || !dbId || !containerId) throw new Error("COSMOS_NOT_CONFIGURED");
  return client.database(dbId).container(containerId);
}
________________________________________
2.3 Rate limit (fix-window cu TTL in Cosmos)
src/shared/rateLimit.ts
import { getContainer } from "./cosmosClient.js";

const RL_CONTAINER = process.env.COSMOS_CONTAINER_CHAT_RL!;

// Ajusteaza cum vrei:
const LIMIT_PER_MIN = 20;
const LIMIT_PER_DAY = 200;

function dayKey(d = new Date()) { return d.toISOString().slice(0, 10); }      // YYYY-MM-DD
function minuteKey(d = new Date()) { return d.toISOString().slice(0, 16); }  // YYYY-MM-DDTHH:MM

async function bump(key: string, ttlSeconds: number): Promise<number> {
  const c = getContainer(RL_CONTAINER);
  const id = key;

  try {
    const { resource } = await c.item(id, id).read<any>();
    const next = (resource?.count ?? 0) + 1;
    await c.items.upsert({ ...resource, id, pk: id, count: next, ttl: ttlSeconds, updated_at: new Date().toISOString() });
    return next;
  } catch (e: any) {
    // 404 -> create
    await c.items.create({ id, pk: id, count: 1, ttl: ttlSeconds, created_at: new Date().toISOString() });
    return 1;
  }
}

export async function enforceRateLimit(userId: string): Promise<void> {
  const now = new Date();

  const kMin = `rl:min:${userId}:${minuteKey(now)}`;
  const kDay = `rl:day:${userId}:${dayKey(now)}`;

  const minCount = await bump(kMin, 120);
  if (minCount > LIMIT_PER_MIN) throw new Error("RATE_LIMIT_MINUTE");

  const dayCount = await bump(kDay, 2 * 24 * 3600);
  if (dayCount > LIMIT_PER_DAY) throw new Error("RATE_LIMIT_DAY");
}
________________________________________
2.4 Cost control lunar (Cosmos)
src/shared/costControl.ts
import { getContainer } from "./cosmosClient.js";

const USAGE_CONTAINER = process.env.COSMOS_CONTAINER_CHAT_USAGE!;
const BUDGET_USD_MONTH = Number(process.env.CHAT_BUDGET_USD_MONTH ?? "150");

function monthKey(d = new Date()) { return d.toISOString().slice(0, 7); } // YYYY-MM

export async function enforceMonthlyBudget(): Promise<void> {
  const id = `budget:${monthKey()}`;
  const c = getContainer(USAGE_CONTAINER);

  try {
    const { resource } = await c.item(id, id).read<any>();
    const spent = Number(resource?.usd_spent ?? 0);
    if (spent >= BUDGET_USD_MONTH) throw new Error("BUDGET_EXCEEDED");
  } catch (e: any) {
    // daca nu exista doc, e ok
    return;
  }
}

export async function addUsage(usdDelta: number, meta?: any): Promise<void> {
  const id = `budget:${monthKey()}`;
  const c = getContainer(USAGE_CONTAINER);

  try {
    const { resource } = await c.item(id, id).read<any>();
    const next = {
      ...resource,
      id,
      pk: id,
      usd_spent: Number(resource?.usd_spent ?? 0) + usdDelta,
      updated_at: new Date().toISOString(),
      meta_last: meta ?? null,
      ttl: 400 * 24 * 3600
    };
    await c.items.upsert(next);
  } catch {
    await c.items.create({
      id,
      pk: id,
      usd_spent: usdDelta,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      meta_last: meta ?? null,
      ttl: 400 * 24 * 3600
    });
  }
}
________________________________________
2.5 Filtru extra: NU lasa nume banci (scrub)
src/shared/bankFilter.ts
const BANK_TERMS = [
  // recomand: muta lista in config/admin
  "ing", "brd", "bcr", "raiffeisen", "unicredit", "cec", "bt", "banca transilvania",
  "garanti", "alpha", "otp", "intesa", "libra", "tbi"
];

export function scrubBankNames(text: string): { text: string; flagged: boolean } {
  let flagged = false;
  let out = text;

  for (const term of BANK_TERMS) {
    const re = new RegExp(`\\b${escapeRegExp(term)}\\b`, "gi");
    if (re.test(out)) {
      flagged = true;
      out = out.replace(re, "o institutie financiara");
    }
  }
  return { text: out, flagged };
}

function escapeRegExp(s: string) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
________________________________________
2.6 /chat handler cu fallback (RO fara diacritice)
src/functions/chat.ts
import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";
import OpenAI from "openai";
import { z } from "zod";
import { requireUser } from "../shared/userAuth.js";
import { enforceRateLimit } from "../shared/rateLimit.js";
import { enforceMonthlyBudget, addUsage } from "../shared/costControl.js";
import { scrubBankNames } from "../shared/bankFilter.js";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

const ReqSchema = z.object({
  message: z.string().min(1).max(2000),
  conversation_id: z.string().optional(),
  context: z.record(z.any()).optional()
});

const PRIMARY_MODEL = process.env.OPENAI_MODEL_PRIMARY || "gpt-3.5-turbo";
const FALLBACK_MODEL = process.env.OPENAI_MODEL_FALLBACK || "gpt-4o-mini";
const MAX_OUT = Number(process.env.CHAT_MAX_OUTPUT_TOKENS ?? "350");

const SYSTEM_PROMPT = process.env.SYSTEM_PROMPT_MONEYSHOP || "Esti Asistentul Virtual MoneyShop...";

const INSTRUCT_JSON = `
Returneaza DOAR JSON valid, fara alte texte, in format:
{
  "raspuns": "string",
  "necesita_upgrade": boolean,
  "incredere": number,
  "motiv": "string"
}
Reguli:
- "necesita_upgrade" = true daca intrebarea e complexa/ambigua sau nu esti sigur.
- "incredere" intre 0 si 1. Daca < 0.65, pune necesita_upgrade=true.
- Nu mentiona nume de banci/IFN/branduri.
- Raspunsul in romana fara diacritice.
`;

function json(status: number, body: any): HttpResponseInit {
  return { status, jsonBody: body, headers: { "content-type": "application/json" } };
}

export async function handler(req: HttpRequest, ctx: InvocationContext): Promise<HttpResponseInit> {
  try {
    const user = await requireUser(req);

    await enforceRateLimit(user.sub);
    await enforceMonthlyBudget();

    const body = await req.json();
    const parsed = ReqSchema.safeParse(body);
    if (!parsed.success) return json(400, { error: "cerere_invalida", detalii: parsed.error.flatten() });

    const { message, context } = parsed.data;

    const userMsg = context
      ? `${message}\n\n[Context MoneyShop JSON]\n${JSON.stringify(context)}`
      : message;

    // 1) model ieftin: cere raspuns in JSON + decide daca face upgrade
    const r1 = await openai.responses.create({
      model: PRIMARY_MODEL,
      input: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "system", content: INSTRUCT_JSON },
        { role: "user", content: userMsg }
      ],
      max_output_tokens: MAX_OUT
    });

    const t1 = extractText(r1);
    const j1 = safeJson(t1);

    if (!j1) {
      // daca nu respecta JSON, facem fallback ca sa nu stricam UX
      await addUsage(estimateUsd(PRIMARY_MODEL, r1.usage), { model: PRIMARY_MODEL, user: user.sub, not_json: true });
      return await runFallback(userMsg, ctx, { motiv: "primary_not_json" });
    }

    const raspuns1 = String(j1.raspuns ?? "");
    const cleaned1 = scrubBankNames(raspuns1);

    const incredere = Number(j1.incredere ?? 0);
    const necesita = Boolean(j1.necesita_upgrade) || incredere < 0.65 || cleaned1.flagged;

    await addUsage(estimateUsd(PRIMARY_MODEL, r1.usage), {
      model: PRIMARY_MODEL, user: user.sub, necesita_upgrade: necesita, incredere
    });

    if (!necesita) {
      return json(200, {
        raspuns: cleaned1.text,
        model_folosit: PRIMARY_MODEL,
        upgraded: false,
        incredere,
        siguranta: { bank_name_scrubbed: cleaned1.flagged },
        nota: "Rezultatele sunt estimative; aprobarea finala apartine creditorului."
      });
    }

    return await runFallback(userMsg, ctx, { motiv: String(j1.motiv ?? "complex") });

  } catch (e: any) {
    const code = String(e?.message ?? "UNKNOWN");

    if (code === "NO_AUTH" || code === "NO_SUB") return json(401, { error: "neautorizat" });
    if (code === "RATE_LIMIT_MINUTE") return json(429, { error: "prea_multe_cereri", fereastra: "minut" });
    if (code === "RATE_LIMIT_DAY") return json(429, { error: "prea_multe_cereri", fereastra: "zi" });
    if (code === "BUDGET_EXCEEDED") return json(402, { error: "buget_depasit" });

    ctx.error(e);
    return json(500, { error: "eroare_server", code });
  }
}

async function runFallback(userMsg: string, ctx: InvocationContext, meta: any): Promise<HttpResponseInit> {
  const r2 = await openai.responses.create({
    model: FALLBACK_MODEL,
    input: [
      { role: "system", content: SYSTEM_PROMPT },
      { role: "user", content: userMsg }
    ],
    max_output_tokens: MAX_OUT
  });

  const t2 = extractText(r2);
  const cleaned2 = scrubBankNames(t2);

  await addUsage(estimateUsd(FALLBACK_MODEL, r2.usage), { model: FALLBACK_MODEL, meta });

  return json(200, {
    raspuns: cleaned2.text,
    model_folosit: FALLBACK_MODEL,
    upgraded: true,
    siguranta: { bank_name_scrubbed: cleaned2.flagged },
    meta,
    nota: "Rezultatele sunt estimative; aprobarea finala apartine creditorului."
  });
}

function extractText(resp: any): string {
  const out = resp.output ?? [];
  let text = "";
  for (const item of out) {
    const content = item.content ?? [];
    for (const c of content) {
      if (c.type === "output_text" && typeof c.text === "string") text += c.text;
    }
  }
  return text.trim();
}

function safeJson(s: string): any | null {
  try { return JSON.parse(s); } catch { return null; }
}

function estimateUsd(model: string, usage: any): number {
  // estimator simplu, ajustabil. Pricing oficial: OpenAI pricing. 
  const input = Number(usage?.input_tokens ?? 0);
  const output = Number(usage?.output_tokens ?? 0);

  // valori conservative (USD / 1M tokens). Ajusteaza dupa ce alegi planul exact.
  let inRate = 3.0, outRate = 6.0;          // gpt-3.5-turbo (estimativ)
  if (model.includes("gpt-4o-mini")) { inRate = 0.25; outRate = 1.0; }

  return (input / 1_000_000) * inRate + (output / 1_000_000) * outRate;
}

app.http("chat", {
  methods: ["POST"],
  authLevel: "anonymous",
  route: "chat",
  handler
});
Inregistrare in src/index.ts
import "./functions/chat.js";
________________________________________
3) Fallback logic (cum functioneaza)
•	Modelul primar (gpt-3.5-turbo) trebuie sa returneze JSON cu necesita_upgrade.
•	Daca:
o	e sub incredere 0.65 sau
o	e complex/ambiguu sau
o	apare nume de banca (detectat/scrub)
=> se apeleaza fallback gpt-4o-mini si se returneaza raspunsul lui (tot fara banci).
________________________________________
4) Disclaimer legal chatbot (RO fara diacritice)
Pune-l in UI langa chat (sub input) + in primul mesaj al botului:
Disclaimer:
Asistentul virtual MoneyShop ofera informatii generale si explicatii educationale despre credite si procesul de aplicare. Nu reprezinta consultanta financiara sau juridica personalizata si nu garanteaza aprobarea unui credit sau o dobanda anume. MoneyShop (POPIX BROKERAGE CONSULTING S.R.L.) este broker/intermediar de credite, nu institutie de credit. Pentru o analiza personalizata si recomandari adaptate situatiei tale, te rugam sa discuti cu un broker autorizat.

Nota: Rezultatele afisate in calculator sunt estimative; aprobarea finala apartine creditorului.
(Adaptare rapida pentru conformitate practica: subliniaza ca nu se fac recomandari de banca prin chatbot, ci doar prin consultanta umana.)
________________________________________
5) Extra (recomandat) – mesajul initial al botului (RO fara diacritice)
La deschiderea chatului:
Salut! Sunt Asistentul Virtual MoneyShop. Te pot ajuta cu explicatii despre credite, eligibilitate si documente, precum si cu intelegerea rezultatelor din calculator. Nu pot recomanda sau mentiona nume de banci. Spune-mi, te rog, ce vrei sa afli?
________________________________________
Daca vrei sa fie “beton” pe partea de conformitate, iti mai adaug imediat:
•	un modul de “politica de raspuns” (template) pe tipuri de intrebari (dobanzi, refinantare, restante, IFN etc.)
•	un sistem de “allowed topics” + refuz pentru subiecte sensibile (date personale, fraude, etc.)
Mai jos ai 2 module “ready to build”, RO fara diacritice, care se integreaza direct in /chat:
1.	Politica de raspuns (template-uri pe tipuri de intrebari)
2.	Allowed topics + refuz pentru subiecte sensibile (PII, fraude, bypass, etc.)
________________________________________
1) Modul “Politica de raspuns” (template-uri)
1.1 Tipuri de intrebari (enum)
src/chat/policyTypes.ts
export type TopicType =
  | "DOBANZI"
  | "REFINANTARE"
  | "RESTANTE"
  | "IFN"
  | "GRAD_INDATORARE"
  | "IPOTECAR_LTV_AVANS"
  | "DOCUMENTE"
  | "CALCULATOR_REZULTAT"
  | "BIR0U_CREDIT"
  | "ANAF_VENIT"
  | "GENERAL";
1.2 Clasificare simpla (keyword rules)
src/chat/policyClassifier.ts
import { TopicType } from "./policyTypes.js";

function hasAny(s: string, words: string[]) {
  const t = s.toLowerCase();
  return words.some(w => t.includes(w));
}

export function classifyTopic(userMessage: string): TopicType {
  const m = userMessage.toLowerCase();

  if (hasAny(m, ["dobanda", "ircc", "marja", "fixa", "variabila", "dae", "comision"])) return "DOBANZI";
  if (hasAny(m, ["refinant", "restructur", "consolid", "inchid credite", "preluare"])) return "REFINANTARE";
  if (hasAny(m, ["restant", "intarzier", "dpd", "30 zile", "60 zile", "90 zile", "executare", "poprire"])) return "RESTANTE";
  if (hasAny(m, ["ifn", "nebancar", "credit rapid", "payday", "microcredit"])) return "IFN";
  if (hasAny(m, ["grad de indatorare", "dti", "40%", "50%", "55%", "rata maxima"])) return "GRAD_INDATORARE";
  if (hasAny(m, ["ipotec", "avans", "ltv", "prima casa", "casa", "imobil"])) return "IPOTECAR_LTV_AVANS";
  if (hasAny(m, ["acte", "document", "adeverinta", "fluturas", "contract", "extras", "copie ci"])) return "DOCUMENTE";
  if (hasAny(m, ["calculator", "simulare", "mi-a iesit", "rezultat", "eligibil", "scor", "incadrare"])) return "CALCULATOR_REZULTAT";
  if (hasAny(m, ["biroul de credit", "birou credit", "fico", "scor fico", "interogare", "istoric"])) return "BIR0U_CREDIT";
  if (hasAny(m, ["anaf", "venit", "d112", "salariu mediu", "tichete"])) return "ANAF_VENIT";

  return "GENERAL";
}
1.3 Template-uri de raspuns (stil unitar MoneyShop)
src/chat/policyTemplates.ts
import { TopicType } from "./policyTypes.js";

export function getPolicyTemplate(topic: TopicType): string {
  // Template = instructiuni pentru model ca sa raspunda consecvent.
  // Nu contine nume de banci; doar criterii generale + disclaimer.
  switch (topic) {
    case "DOBANZI":
      return `
Cand intrebarile sunt despre dobanzi/IRCC/marja:
- Explica pe scurt diferenta intre dobanda fixa si variabila.
- Explica formula generala: dobanda variabila = indice (ex: IRCC) + marja.
- Spune ca valorile variaza in functie de profil si politici interne ale creditorului.
- Nu promite dobanzi; ofera intervale "orientative" doar daca user cere.
- Cere clarificari minime: tip credit, suma, perioada, venit net aproximativ.
La final: "Rezultatele sunt estimative; aprobarea finala apartine creditorului."`;

    case "REFINANTARE":
      return `
Cand intrebarile sunt despre refinantare:
- Explica ce inseamna refinantare si cand are sens (dobanda mai mica, rata mai mica, consolidare).
- Mentioneaza costuri posibile: evaluare, notar, comisioane, asigurari, taxe, rambursare anticipata (daca exista).
- Explica pe pasi: analiza venit, verificare obligatii, simulare, oferta, depunere, aprobare.
- Nu recomanda institutii; doar criterii generale.
La final: nota estimativa + aprobare finala.`;

    case "RESTANTE":
      return `
Cand intrebarile sunt despre restante/intarzieri:
- Explica impactul restantelor asupra eligibilitatii (istoric, comportament de plata).
- Daca user mentioneaza intarzieri, cere date nesensibile: cate intarzieri si aproximativ cate zile (30/60/90+), daca sunt active sau inchise.
- Ofera masuri generale: inchiderea restantelor, stabilizarea bugetului, evitarea creditelor noi, negociere/restructurare.
- Nu promite aprobari si nu mentiona banci.
La final: nota estimativa + recomandare consultanta umana.`;

    case "IFN":
      return `
Cand intrebarile sunt despre IFN/credite nebancare:
- Explica diferente generale intre credite bancare si nebancare (costuri, viteza, flexibilitate).
- Avertizeaza asupra costurilor totale si a efectului asupra gradului de indatorare.
- Daca user are multe IFN-uri, recomanda consolidare/plan de reducere a obligatiilor, fara a mentiona institutii.
- Nu oferi metode de "ocolire" a verificarilor.
La final: nota estimativa + recomandare consultanta umana.`;

    case "GRAD_INDATORARE":
      return `
Cand intrebarile sunt despre grad de indatorare:
- Explica ce este DTI/grad de indatorare (rata totala lunara raportata la venit).
- Spune ca pragurile pot varia si depind de venit, stabilitate si politici interne.
- Cere date nesensibile: venit net mediu, obligatii lunare totale, tip credit.
- Daca are tichete/bonuri, mentioneaza ca pot fi tratate diferit in functie de criterii.
La final: nota estimativa + aprobare finala.`;

    case "IPOTECAR_LTV_AVANS":
      return `
Cand intrebarile sunt despre ipotecar/avans/LTV:
- Explica LTV = valoare finantata / valoare imobil si rolul avansului.
- Mentioneaza ca avansul minim depinde de situatie (prima locuinta vs a doua, venituri din strainatate etc.) conform regulilor interne si reglementarilor.
- Nu numi institutii; explica doar principii.
- Cere informatii minime: are/nu are alta locuinta, venit (RO/strainatate), moneda venit, avans disponibil, tip imobil.
La final: nota estimativa + aprobare finala.`;

    case "DOCUMENTE":
      return `
Cand intrebarile sunt despre documente:
- Listeaza documentele uzuale, in termeni generali (CI, adeverinta venit/contract, extras cont, documente imobil etc.).
- Spune ca lista exacta depinde de creditor si de tipul venitului.
- Nu cere si nu solicita upload de documente prin chat; directioneaza catre zona securizata din aplicatie daca exista.
La final: nota estimativa + aprobare finala.`;

    case "CALCULATOR_REZULTAT":
      return `
Cand intrebarile sunt despre rezultatul calculatorului MoneyShop:
- Explica pe baza factorilor: venit luat in calcul, obligatii, perioada, dobanda orientativa, DTI, avans (ipotecar).
- Cere valorile din rezultat (numerice) daca lipsesc: venit considerat, obligatii lunare, perioada, suma dorita.
- Nu promite aprobari si nu mentiona institutii.
La final: nota estimativa + aprobare finala.`;

    case "BIR0U_CREDIT":
      return `
Cand intrebarile sunt despre Biroul de Credit/scor:
- Explica pe scurt ce este raportul si ce influenteaza scorul (istoric, utilizare, intarzieri, numar de credite).
- Nu cere date sensibile; cere doar informatii generale (scor aproximativ, daca exista intarzieri si cate).
- Nu oferi sfaturi de manipulare/inselarciune; doar practici corecte (plati la timp, reducere grad utilizare).
La final: nota estimativa + aprobare finala.`;

    case "ANAF_VENIT":
      return `
Cand intrebarile sunt despre ANAF/venit:
- Explica pe scurt ca venitul luat in calcul este de regula o medie pe mai multe luni, iar stabilitatea conteaza.
- Daca user intreaba despre tichete/bonuri, mentioneaza ca pot fi tratate diferit.
- Nu cere date sensibile; cere doar sume aproximative si perioada.
La final: nota estimativa + aprobare finala.`;

    default:
      return `
Raspunde clar si structurat.
- Nu mentiona nume de banci/IFN/branduri.
- Nu promite aprobari sau dobanzi garantate.
- Pune 1-2 intrebari de clarificare doar daca e necesar.
La final: "Rezultatele sunt estimative; aprobarea finala apartine creditorului."`;
  }
}
________________________________________
2) Sistem “Allowed topics” + refuz pentru subiecte sensibile
2.1 Definim “sensitive topics” + PII patterns
src/chat/topicGuard.ts
export type GuardDecision =
  | { allowed: true; reason: "OK" }
  | { allowed: false; reason: "PII" | "FRAUDA" | "BY_PASS" | "HATE" | "SELF_HARM" | "ILLEGAL" };

function matchAny(reList: RegExp[], s: string) {
  return reList.some(re => re.test(s));
}

// Detectie simpla pentru PII (nu perfecta, dar utila)
const RE_PII: RegExp[] = [
  /\bcnp\b/i,
  /\bserie\b.*\bci\b/i,
  /\bnumar\b.*\bci\b/i,
  /\bcard\b.*\b\d{12,19}\b/i,
  /\biban\b/i,
  /\bparola\b/i,
  /\botp\b/i,
  /\bcod\b.*\bverificare\b/i,
  /\bpin\b/i,
  /\bemail\b.*@/i,
  /\btelefon\b.*\b0\d{9}\b/i
];

// Frauda / bypass / spalare
const RE_FRAUD: RegExp[] = [
  /\b(ocol|evit|pacol|fent)\w*\b.*\b(verific|anaf|birou|scor|fico)\b/i,
  /\b(cum sa mint|cum sa falsific|acte false|adeverinta falsa)\b/i,
  /\b(spalare bani|money laundering)\b/i,
  /\b(furt|phishing|hack)\b/i
];

// Continut ilegal generic (foarte sumar)
const RE_ILLEGAL: RegExp[] = [
  /\b(drog|cocaina|heroina|metamfet)\w*\b/i,
  /\b(vand|cumpar)\b.*\b(buletin|ci|card)\b/i
];

export function topicGuard(userMessage: string): GuardDecision {
  const s = userMessage || "";

  if (matchAny(RE_PII, s)) return { allowed: false, reason: "PII" };
  if (matchAny(RE_FRAUD, s)) return { allowed: false, reason: "FRAUDA" };
  if (matchAny(RE_ILLEGAL, s)) return { allowed: false, reason: "ILLEGAL" };

  // poti extinde cu hate/self-harm daca vrei, acum e focus pe MoneyShop
  return { allowed: true, reason: "OK" };
}

export function refusalMessage(reason: GuardDecision["reason"]): string {
  switch (reason) {
    case "PII":
      return "Nu pot prelua sau procesa date sensibile (de exemplu CNP, serie/numar CI, parole, OTP, numar complet card). Te rog reformuleaza fara astfel de date si spune doar informatii generale (ex: venit aproximativ, obligatii lunare totale).";
    case "FRAUDA":
    case "BY_PASS":
      return "Nu te pot ajuta cu metode de ocolire a verificarilor sau cu recomandari care implica falsificare ori inselaciune. Pot insa sa iti explic pasii corecti si criteriile generale de eligibilitate.";
    case "ILLEGAL":
      return "Nu te pot ajuta cu solicitari care tin de activitati ilegale. Pot oferi informatii generale si legale despre credite si eligibilitate.";
    default:
      return "Nu pot raspunde la aceasta solicitare. Pot oferi informatii generale despre credite si procesul de aplicare.";
  }
}
2.2 Allowed topics (optional strict mode)
Daca vrei “whitelist” pe ce vorbim in chat:
src/chat/allowedTopics.ts
import { TopicType } from "./policyTypes.js";

export const ALLOWED_TOPICS: TopicType[] = [
  "DOBANZI",
  "REFINANTARE",
  "RESTANTE",
  "IFN",
  "GRAD_INDATORARE",
  "IPOTECAR_LTV_AVANS",
  "DOCUMENTE",
  "CALCULATOR_REZULTAT",
  "BIR0U_CREDIT",
  "ANAF_VENIT",
  "GENERAL"
];

// Daca vrei sa blochezi complet subiecte in afara scope-ului (de ex. investitii/crypto/etc.)
// poti implementa un classifier separat. Deocamdata, topicClassifier returneaza doar din lista.
________________________________________
3) Integrarea in /chat (inainte de apel OpenAI)
3.1 Modifici handler-ul: guard + template
In src/functions/chat.ts, adauga importuri:
import { topicGuard, refusalMessage } from "../chat/topicGuard.js";
import { classifyTopic } from "../chat/policyClassifier.js";
import { getPolicyTemplate } from "../chat/policyTemplates.js";
Apoi, imediat dupa validarea body:
// 0) Guard: refuz pentru date sensibile / fraude / bypass
const guard = topicGuard(message);
if (!guard.allowed) {
  return json(200, {
    raspuns: refusalMessage(guard.reason),
    model_folosit: "policy_refusal",
    upgraded: false,
    siguranta: { blocked: true, motiv: guard.reason },
    nota: "Rezultatele sunt estimative; aprobarea finala apartine creditorului."
  });
}

// 0.1) Clasificare topic + template policy
const topic = classifyTopic(message);
const policyTemplate = getPolicyTemplate(topic);
Apoi, in apelul catre OpenAI (PRIMARY si FALLBACK), adauga un mesaj system cu template-ul:
La r1:
const r1 = await openai.responses.create({
  model: PRIMARY_MODEL,
  input: [
    { role: "system", content: SYSTEM_PROMPT },
    { role: "system", content: "Politica de raspuns pentru acest tip de intrebare:\n" + policyTemplate },
    { role: "system", content: INSTRUCT_JSON },
    { role: "user", content: userMsg }
  ],
  max_output_tokens: MAX_OUT
});
La fallback r2:
const r2 = await openai.responses.create({
  model: FALLBACK_MODEL,
  input: [
    { role: "system", content: SYSTEM_PROMPT },
    { role: "system", content: "Politica de raspuns pentru acest tip de intrebare:\n" + policyTemplate },
    { role: "user", content: userMsg }
  ],
  max_output_tokens: MAX_OUT
});
E important: policyTemplate il trimiti si la fallback, ca sa pastrezi stilul uniform.
________________________________________
4) “Refuz soft” pentru intrebari despre banci (extra)
Chiar daca avem regula in prompt, e bine sa avem si un detector simplu:
src/chat/bankIntent.ts
export function asksForBankNames(s: string): boolean {
  const t = (s || "").toLowerCase();
  return (
    t.includes("ce banca") ||
    t.includes("care banca") ||
    t.includes("recomanzi banca") ||
    t.includes("la ce banca") ||
    t.includes("spune-mi banca") ||
    t.includes("unde sa aplic")
  );
}

export function bankRefusal(): string {
  return "Nu pot recomanda sau mentiona nume de banci. Iti pot explica insa criteriile dupa care sa alegi (dobanda totala, costuri, perioada, grad de indatorare, stabilitatea venitului) si te pot ajuta sa intelegi eligibilitatea ta. Daca vrei, spune-mi venitul net aproximativ, obligatiile lunare totale si tipul creditului.";
}
In handler, dupa guard:
import { asksForBankNames, bankRefusal } from "../chat/bankIntent.js";

if (asksForBankNames(message)) {
  return json(200, {
    raspuns: bankRefusal(),
    model_folosit: "policy_bank_refusal",
    upgraded: false,
    siguranta: { blocked: true, motiv: "BANK_NAMES_REQUEST" },
    nota: "Rezultatele sunt estimative; aprobarea finala apartine creditorului."
  });
}
________________________________________
5) Rezultat: comportament consistent
•	User intreaba de dobanzi -> raspuns pe structura DOBANZI
•	User intreaba de restante -> raspuns RESTANTE + masuri generale
•	User cere banca -> refuz + criterii generale
•	User incearca sa ocoleasca ANAF/BC -> refuz “frauda/bypass”
•	User trimite CNP / OTP -> refuz PII + cere info nesensibile
________________________________________
Daca vrei, urmatorul upgrade (foarte util) este:
•	un “FAQ cache” (raspuns local) pentru 20-30 intrebari repetate, ca sa scazi costul cu 30-50% si sa ai raspuns instant.
Mai jos ai upgrade-ul “FAQ cache” ready to build (RO fara diacritice), ca sa raspunzi instant la 20–30 intrebari frecvente si sa reduci costurile.
Iti dau:
1.	schema de date (Cosmos) + TTL
2.	logica de matching (exact + fuzzy light)
3.	integrare in /chat (inainte de OpenAI)
4.	un set initial de 25 FAQ (editabil)
________________________________________
1) Cosmos container pentru FAQ cache
Container: faq_cache
•	Partition key: /pk
•	Document:
{
  "id": "faq_grad_indatorare_01",
  "pk": "faq",
  "q": "ce este gradul de indatorare",
  "aliases": ["ce inseamna gradul de indatorare", "dti ce inseamna", "grad indatorare 40 50"],
  "answer": "Gradul de indatorare (DTI) arata cat din venitul tau lunar poate fi alocat ratelor totale (credite/leasing/IFN) ... Rezultatele sunt estimative; aprobarea finala apartine creditorului.",
  "tags": ["GRAD_INDATORARE"],
  "priority": 10,
  "enabled": true,
  "updated_at": "2026-01-06T00:00:00Z",
  "ttl": 31536000
}
•	ttl optional (ex 1 an). Daca vrei sa nu expire, nu pui ttl si dezactivezi TTL pe container.
ENV:
•	COSMOS_CONTAINER_FAQ=faq_cache
________________________________________
2) FAQ matching (local, fara OpenAI)
2.1 Normalizare text
src/faq/normalize.ts
export function normalizeRoNoDiacritics(s: string): string {
  // userul deja vrea fara diacritice, dar normalizam robust
  const x = (s || "")
    .toLowerCase()
    .replace(/[ăâ]/g, "a")
    .replace(/[î]/g, "i")
    .replace(/[ș]/g, "s")
    .replace(/[ț]/g, "t")
    .replace(/[^a-z0-9\s]/g, " ")
    .replace(/\s+/g, " ")
    .trim();

  return x;
}
2.2 Similaritate simpla (Jaccard pe cuvinte)
src/faq/similarity.ts
export function jaccard(a: string, b: string): number {
  const A = new Set(a.split(" ").filter(Boolean));
  const B = new Set(b.split(" ").filter(Boolean));
  if (!A.size || !B.size) return 0;

  let inter = 0;
  for (const w of A) if (B.has(w)) inter++;

  const union = A.size + B.size - inter;
  return union ? inter / union : 0;
}
2.3 Loader + match
src/faq/faqStore.ts
import { getContainer } from "../shared/cosmosClient.js";
import { normalizeRoNoDiacritics } from "./normalize.js";
import { jaccard } from "./similarity.js";

const FAQ_CONTAINER = process.env.COSMOS_CONTAINER_FAQ!;

export interface FaqItem {
  id: string;
  pk: "faq";
  q: string;
  aliases?: string[];
  answer: string;
  tags?: string[];
  priority?: number;
  enabled: boolean;
  updated_at: string;
}

export async function loadFaqItems(): Promise<FaqItem[]> {
  const c = getContainer(FAQ_CONTAINER);
  const query = {
    query: "SELECT * FROM c WHERE c.pk = 'faq' AND c.enabled = true"
  };
  const { resources } = await c.items.query<FaqItem>(query).fetchAll();
  return resources ?? [];
}

export async function matchFaq(userMessage: string): Promise<{ hit: boolean; item?: FaqItem; score?: number }> {
  const msg = normalizeRoNoDiacritics(userMessage);

  // scurt: daca e prea scurt, nu facem fuzzy (evita match gresit)
  if (msg.length < 8) return { hit: false };

  const items = await loadFaqItems();

  // 1) exact match pe q / alias
  for (const it of items) {
    const q = normalizeRoNoDiacritics(it.q);
    if (msg === q) return { hit: true, item: it, score: 1 };

    for (const a of it.aliases ?? []) {
      if (msg === normalizeRoNoDiacritics(a)) return { hit: true, item: it, score: 1 };
    }
  }

  // 2) fuzzy match (Jaccard) + priority
  let best: { it: FaqItem; score: number } | null = null;

  for (const it of items) {
    const candidates = [it.q, ...(it.aliases ?? [])];
    let localBest = 0;

    for (const c of candidates) {
      const sc = jaccard(msg, normalizeRoNoDiacritics(c));
      if (sc > localBest) localBest = sc;
    }

    // bonus mic pentru priority
    const pr = Number(it.priority ?? 0);
    const boosted = localBest + Math.min(0.08, pr * 0.005);

    if (!best || boosted > best.score) best = { it, score: boosted };
  }

  // prag recomandat (ajustezi dupa loguri)
  if (best && best.score >= 0.55) return { hit: true, item: best.it, score: best.score };

  return { hit: false };
}
________________________________________
3) Integrare in /chat (inainte de OpenAI)
In src/functions/chat.ts, dupa guard si refuz banca, dar inainte de apel OpenAI, adauga:
import { matchFaq } from "../faq/faqStore.js";

// ...

const faq = await matchFaq(message);
if (faq.hit && faq.item) {
  return json(200, {
    raspuns: faq.item.answer,
    model_folosit: "faq_cache",
    upgraded: false,
    siguranta: { cached: true, faq_id: faq.item.id, score: faq.score },
    nota: "Rezultatele sunt estimative; aprobarea finala apartine creditorului."
  });
}
Astfel, intrebarile repetate NU mai ajung la OpenAI -> cost scade mult.
________________________________________
4) Set initial de 25 FAQ (RO fara diacritice)
Poti incarca manual in Cosmos sau printr-un endpoint admin (daca vrei ti-l fac). Mai jos iti dau un set “starter”:
Toate raspunsurile includ deja nota de conformitate si NU mentioneaza banci.
faq_seed.json (exemplu)
[
  {
    "id": "faq_dti_01",
    "pk": "faq",
    "q": "ce este gradul de indatorare",
    "aliases": ["ce inseamna gradul de indatorare", "ce inseamna dti", "grad indatorare 40 50"],
    "answer": "Gradul de indatorare (DTI) arata cat din venitul tau lunar poate fi alocat ratelor totale (credite, leasing, IFN). In practica, creditorii folosesc praguri diferite in functie de venit, stabilitate si politici interne. Daca vrei, spune-mi venitul net aproximativ si obligatiile lunare totale ca sa iti explic cum se interpreteaza. Rezultatele sunt estimative; aprobarea finala apartine creditorului.",
    "tags": ["GRAD_INDATORARE"],
    "priority": 10,
    "enabled": true,
    "updated_at": "2026-01-06T00:00:00Z",
    "ttl": 31536000
  },
  {
    "id": "faq_ircc_01",
    "pk": "faq",
    "q": "ce este ircc",
    "aliases": ["ircc ce inseamna", "cum se calculeaza ircc", "indice ircc"],
    "answer": "IRCC este un indice de referinta folosit in Romania pentru anumite credite cu dobanda variabila. In general, dobanda variabila se poate exprima ca: indice (ex. IRCC) + marja. Valoarea finala depinde de conditiile concrete si de politicile creditorului. Rezultatele sunt estimative; aprobarea finala apartine creditorului.",
    "tags": ["DOBANZI"],
    "priority": 9,
    "enabled": true,
    "updated_at": "2026-01-06T00:00:00Z",
    "ttl": 31536000
  },
  {
    "id": "faq_dobanda_fixa_01",
    "pk": "faq",
    "q": "care e diferenta intre dobanda fixa si variabila",
    "aliases": ["dobanda fixa vs variabila", "ce inseamna dobanda fixa", "ce inseamna dobanda variabila"],
    "answer": "Dobanda fixa ramane aceeasi pe perioada fixa stabilita (ex. 3 ani), iar dobanda variabila se modifica in timp in functie de un indice (de exemplu IRCC) plus marja. Dobanda fixa ofera stabilitate, variabila poate scadea sau creste in timp. Rezultatele sunt estimative; aprobarea finala apartine creditorului.",
    "tags": ["DOBANZI"],
    "priority": 9,
    "enabled": true,
    "updated_at": "2026-01-06T00:00:00Z",
    "ttl": 31536000
  },
  {
    "id": "faq_ipotecar_avans_01",
    "pk": "faq",
    "q": "ce avans imi trebuie la credit ipotecar",
    "aliases": ["avans credit ipotecar cat", "ltv ce inseamna", "avans prima locuinta"],
    "answer": "Avansul la ipotecar depinde de situatie (de exemplu daca este prima locuinta pe numele tau, daca ai mai avut o locuinta, si de tipul venitului). In general, cu cat avansul este mai mare, cu atat finantarea este mai usoara. Spune-mi te rog: ai mai avut o locuinta pe numele tau si venitul este din Romania sau din strainatate? Rezultatele sunt estimative; aprobarea finala apartine creditorului.",
    "tags": ["IPOTECAR_LTV_AVANS"],
    "priority": 10,
    "enabled": true,
    "updated_at": "2026-01-06T00:00:00Z",
    "ttl": 31536000
  },
  {
    "id": "faq_restante_01",
    "pk": "faq",
    "q": "am avut restante mai pot lua credit",
    "aliases": ["intarzieri la plata mai pot face credit", "restante 30 zile", "restante 60 zile"],
    "answer": "Restantele pot influenta eligibilitatea, in special daca sunt recente, repetate sau de durata mare. Conteaza cate intarzieri au fost, cate zile aproximativ (30/60/90+), daca sunt active sau inchise si cum arata istoricul recent. Pot sa iti explic pe criterii generale daca imi spui doar aceste informatii (fara date personale). Rezultatele sunt estimative; aprobarea finala apartine creditorului.",
    "tags": ["RESTANTE"],
    "priority": 10,
    "enabled": true,
    "updated_at": "2026-01-06T00:00:00Z",
    "ttl": 31536000
  },
  {
    "id": "faq_ifn_01",
    "pk": "faq",
    "q": "am credite ifn ma afecteaza",
    "aliases": ["ifn imi scade sansele", "nebancare ma incurca", "am multe ifn"],
    "answer": "Creditele nebancare (IFN) pot afecta eligibilitatea prin cresterea obligatiilor lunare si prin istoricul de credit. Important este totalul ratelor, stabilitatea veniturilor si comportamentul de plata. O abordare frecventa este reducerea obligatiilor si stabilizarea bugetului inainte de un credit nou. Rezultatele sunt estimative; aprobarea finala apartine creditorului.",
    "tags": ["IFN"],
    "priority": 9,
    "enabled": true,
    "updated_at": "2026-01-06T00:00:00Z",
    "ttl": 31536000
  },

  { "id":"faq_docs_np_01","pk":"faq","q":"ce acte imi trebuie pentru credit de nevoi personale","aliases":["acte nevoi personale","documente pentru credit de consum"],"answer":"In general, pentru un credit de nevoi personale se cer: act identitate, dovada venitului (in functie de tipul venitului), si uneori extras de cont. Lista exacta poate varia. Evita sa trimiti documente in chat; foloseste doar zonele securizate ale aplicatiei daca exista. Rezultatele sunt estimative; aprobarea finala apartine creditorului.","tags":["DOCUMENTE"],"priority":8,"enabled":true,"updated_at":"2026-01-06T00:00:00Z","ttl":31536000 },

  { "id":"faq_docs_ipotecar_01","pk":"faq","q":"ce acte imi trebuie pentru credit ipotecar","aliases":["documente ipotecar","acte casa ipotecar"],"answer":"Pentru ipotecar, pe langa actele de identitate si dovada venitului, de regula apar documente ale imobilului (acte proprietate, cadastru/intabulare, evaluare) si documente de asigurare. Lista variaza in functie de caz. Rezultatele sunt estimative; aprobarea finala apartine creditorului.","tags":["DOCUMENTE"],"priority":9,"enabled":true,"updated_at":"2026-01-06T00:00:00Z","ttl":31536000 },

  { "id":"faq_refinantare_01","pk":"faq","q":"cand merita refinantarea","aliases":["merita sa refinantez","refinantare rata mai mica"],"answer":"Refinantarea poate merita daca obtii o rata lunara mai mica, o dobanda totala mai buna, sau daca vrei sa consolidezi mai multe obligatii intr-una singura. Ia in calcul si costurile (evaluare/notar/taxe/comisioane). Daca imi spui aproximativ suma ramasa, rata actuala si perioada, iti explic criteriile generale. Rezultatele sunt estimative; aprobarea finala apartine creditorului.","tags":["REFINANTARE"],"priority":8,"enabled":true,"updated_at":"2026-01-06T00:00:00Z","ttl":31536000 },

  { "id":"faq_fico_01","pk":"faq","q":"ce inseamna scor fico","aliases":["fico ce este","scor credit ce inseamna"],"answer":"Scorul (de tip FICO) este un indicator al comportamentului de creditare bazat pe istoricul tau (plati la timp, intarzieri, utilizare, vechime, numar de conturi). Nu este singurul criteriu, dar poate influenta decizia si conditiile. Rezultatele sunt estimative; aprobarea finala apartine creditorului.","tags":["BIR0U_CREDIT"],"priority":8,"enabled":true,"updated_at":"2026-01-06T00:00:00Z","ttl":31536000 },

  { "id":"faq_anaf_01","pk":"faq","q":"de ce se face media venitului pe mai multe luni","aliases":["media venit anaf 6 luni","de ce nu iau ultima luna"],"answer":"Media venitului pe mai multe luni ajuta la evaluarea stabilitatii. Unele situatii (bonusuri, fluctuatii) pot distorsiona o singura luna. De aceea, o medie (de exemplu pe 3-6 luni) ofera o imagine mai realista. Rezultatele sunt estimative; aprobarea finala apartine creditorului.","tags":["ANAF_VENIT"],"priority":7,"enabled":true,"updated_at":"2026-01-06T00:00:00Z","ttl":31536000 },

  { "id":"faq_calc_01","pk":"faq","q":"calculatorul arata mai putin decat ma asteptam de ce","aliases":["de ce imi iese suma mica","de ce nu ma incadrez"],"answer":"Suma poate iesi mai mica din cauza a 3 lucruri principale: (1) venitul luat in calcul (media si tipul venitului), (2) obligatiile lunare existente (rate/IFN/leasing), (3) regulile de incadrare (grad de indatorare, perioada, avans la ipotecar). Daca imi spui venitul net aproximativ si obligatiile lunare totale, iti explic cum se interpreteaza. Rezultatele sunt estimative; aprobarea finala apartine creditorului.","tags":["CALCULATOR_REZULTAT"],"priority":9,"enabled":true,"updated_at":"2026-01-06T00:00:00Z","ttl":31536000 },

  { "id":"faq_spv_anaf_01","pk":"faq","q":"ce este consimtamantul pentru anaf","aliases":["de ce trebuie consimtamant anaf","raport anaf consimtamant"],"answer":"Consimtamantul este folosit pentru a putea obtine si utiliza legal informatii despre venit in scopul evaluarii eligibilitatii, conform regulilor de protectie a datelor si proceselor aplicabile. In aplicatiile digitale, consimtamantul se acorda in mod explicit. Rezultatele sunt estimative; aprobarea finala apartine creditorului.","tags":["ANAF_VENIT"],"priority":7,"enabled":true,"updated_at":"2026-01-06T00:00:00Z","ttl":31536000 },

  { "id":"faq_costuri_ipotecar_01","pk":"faq","q":"ce costuri mai sunt la ipotecar pe langa rata","aliases":["costuri ipotecar notar evaluare","cat costa notarul"],"answer":"La ipotecar pot aparea costuri precum evaluarea imobilului, notar, taxe, asigurari si uneori comisioane. Costurile exacte depind de caz. Daca vrei, iti explic lista tipica si ce influenteaza fiecare cost. Rezultatele sunt estimative; aprobarea finala apartine creditorului.","tags":["IPOTECAR_LTV_AVANS"],"priority":7,"enabled":true,"updated_at":"2026-01-06T00:00:00Z","ttl":31536000 }
]
Recomandare: completezi pana la 25-30 cu intrebari exacte pe care le vezi la tine in TikTok/mesaje (cele mai repetate).
________________________________________
5) Optimizari care iti dau 30-50% reducere reala
•	Prag fuzzy 0.55 (ajustezi dupa loguri). Daca ai match-uri false, urci la 0.60.
•	Pentru intrebari foarte scurte (ex: “ircc?”) folosesti exact-match pe alias.
•	Loghezi faq_id + score ca sa vezi ce prinde.
________________________________________
6) Optional (daca vrei imediat): endpoint admin de seed/update FAQ
Daca vrei, iti scriu rapid:
•	POST /admin/faq/upsert (admin) ca sa bagi/editezi FAQ din panel
•	GET /faq/search (admin) pentru management
Spune-mi daca vrei si partea asta si ti-o pun in acelasi stil (RO fara diacritice).
Da, se poate, dar trebuie facut corect si safe: chatbotul poate cere si colecta nume/prenume, telefon, email doar ca lead/contact, insa:
•	NU le proceseaza in chat in mod liber (nu le repeta inapoi, nu le afiseaza in log-uri)
•	le trimite intr-un formular securizat (sau endpoint dedicat) si in chat ramane doar confirmarea: „Am inregistrat datele.”
•	pentru intrebarea 1: NU ai voie sa ceri “la ce banca” (tu ai cerinta ca botul sa nu mentioneze banci). Inlocuieste cu: “tip creditor (banca/IFN/leasing)” sau “institutie financiara (fara nume)”.
Mai jos iti dau varianta “gata de implementat” (RO fara diacritice) + template de conversatie + validari.
________________________________________
1) Script (text) pe care botul il foloseste ca formular de calificare
Varianta corecta (fara diacritice, fara nume banci)
Ca sa iti pot explica eligibilitatea si pasii urmatori, am nevoie de cateva informatii. Te rog NU trimite CNP, serie/numar CI, date card sau parole/OTP.

1) Nume si prenume:
2) Nr. de telefon:
3) Adresa de email:

Acum, cateva intrebari despre situatie:

4) Ai credite active in prezent? Daca da:
   - aproximativ cat mai ai de rambursat in total (nu rata lunara)?
   - sunt de la o banca / IFN / leasing? (te rog fara nume)

5) Ai avut intarzieri in trecut? Daca da:
   - cate intarzieri aproximativ
   - de cate zile au fost (ex: 30 / 60 / 90+)

6) Care este venitul tau net lunar (cat intra pe card)?
   - ai si bonuri/tichete de masa? daca da, cat aproximativ?

7) Din ce oras esti?

8) In ultimii 5 ani ai avut poprire pe salariu din cauza unui credit sau ai platit la executor / firma de recuperari?
   - Daca raspunsul este DA, te rog spune doar daca situatia este inchisa sau inca activa (fara nume).
   - Important: in astfel de cazuri, sansele de aprobare sunt de regula foarte mici.
Observatie: la punctul 8 nu mai zic “sansa 0”, ca e prea absolut (si poate fi fals). Spun “de regula foarte mici”.
________________________________________
2) Politica “lead capture” (reguli pentru bot)
Adauga asta in SYSTEM_PROMPT_MONEYSHOP (RO fara diacritice):
Reguli pentru colectarea datelor de contact (lead):
- Este permis sa ceri: nume si prenume, telefon, email, oras, si informatii financiare nesensibile (venit net aproximativ, obligatii totale, existenta intarzierilor ca numar si interval de zile).
- Nu cere si nu accepta: CNP, serie/numar CI, poze CI, date card, parole, OTP.
- Daca utilizatorul ofera date sensibile, opreste colectarea, cere sa stearga acea informatie si sa retrimita fara date sensibile.
- Cand utilizatorul trimite nume/telefon/email, nu le repeta complet in raspuns. Confirma generic: "Am inregistrat datele."
- Nu cere numele bancii. Daca utilizatorul intreaba sau ofera banca, nu o repeta si redirectioneaza la "te rog fara nume".
________________________________________
3) Sistem allowed-topics: actualizare (permiti lead data)
In modulul topicGuard.ts pe care ti l-am facut, trebuie ajustat: acum blocheaza “email/telefon” ca PII. Pentru lead capture, e normal sa le accepti.
Solutie: PII “interzis” doar pentru CNP/CI/card/OTP, dar permite email/telefon cand user este in modul “lead”
Implementare: mode: "CHAT" | "LEAD_FORM"
src/chat/topicGuard.ts (patch)
export type GuardMode = "CHAT" | "LEAD_FORM";

export function topicGuard(userMessage: string, mode: GuardMode = "CHAT"): GuardDecision {
  const s = userMessage || "";

  // In LEAD_FORM permitem email/telefon, dar tot blocam CNP/CI/card/OTP
  if (mode === "LEAD_FORM") {
    if (matchAny(RE_STRICT_PII, s)) return { allowed: false, reason: "PII" };
    if (matchAny(RE_FRAUD, s)) return { allowed: false, reason: "FRAUDA" };
    if (matchAny(RE_ILLEGAL, s)) return { allowed: false, reason: "ILLEGAL" };
    return { allowed: true, reason: "OK" };
  }

  // In CHAT mode, blochezi mai agresiv (optional)
  if (matchAny(RE_PII, s)) return { allowed: false, reason: "PII" };
  ...
}
Si definesti RE_STRICT_PII doar pentru CNP/CI/card/OTP:
const RE_STRICT_PII: RegExp[] = [
  /\bcnp\b/i,
  /\bserie\b.*\bci\b/i,
  /\bnumar\b.*\bci\b/i,
  /\botp\b/i,
  /\bpin\b/i,
  /\bcard\b.*\b\d{12,19}\b/i,
  /\biban\b/i,
  /\bparola\b/i
];
________________________________________
4) Endpoint dedicat pentru lead: POST /lead/capture (recomandat)
Ca sa NU amesteci contactele in /chat, e mai curat sa ai un endpoint separat.
Contract
export interface LeadCaptureRequest {
  nume_prenume: string;
  telefon: string;
  email: string;
  oras: string;

  credite_active: boolean;
  sold_total_aprox?: number;           // cat mai are total, lei
  tip_creditor?: "BANCA" | "IFN" | "LEASING" | "MIXT";  // fara nume

  intarzieri: boolean;
  intarzieri_numar_aprox?: number;
  intarzieri_zile_max?: 0 | 30 | 60 | 90 | 120;        // bucket

  venit_net_lunar: number;             // lei
  bonuri_masa_aprox?: number;          // lei

  poprire_sau_executor_ultimii_5_ani: boolean;
  situatie_poprire_inchisa?: boolean;  // doar daca DA
}
In chat, cand user vrea analiza personalizata:
•	botul trimite userul in “mod lead” sau ii afiseaza formularul
•	FE colecteaza datele si trimite la /lead/capture
•	apoi botul spune: “Multumesc, am inregistrat. Un broker te contacteaza.”
________________________________________
5) Daca insisti sa fie TOT in chat (fara endpoint separat)
Se poate, dar cu reguli:
•	botul cere intrebarile pe rand
•	la fiecare raspuns, backend extrage (regex) si salveaza in DB
•	botul nu repeta nume/telefon/email
Exemplu raspuns final al botului (fara diacritice)
Multumesc! Am inregistrat informatiile. Pe baza celor spuse, iti pot explica pe criterii generale ce influenteaza eligibilitatea si ce pasi urmeaza. Daca doresti o analiza personalizata, un broker autorizat te poate contacta.

Nota: Rezultatele sunt estimative; aprobarea finala apartine creditorului.
________________________________________
6) Corectura la intrebarea 1 (ca sa respecti regula “fara banci”)
In loc de:
“la ce banca”
Foloseste:
•	“banca/IFN/leasing (fara nume)”
Altfel, risti ca userul sa scrie banca, iar botul sa o repete.
________________________________________
Daca vrei, iti scriu imediat:
•	endpoint-ul /lead/capture (Azure Functions TS) + validari (zod) + salvare in Cosmos
•	un “conversation state machine” simplu (step 1..8) ca botul sa intrebe pe rand si sa nu primeasca toate raspunsurile amestecate.
Mai jos ai totul ready to build (Azure Functions TS), cu texte doar in romana fara diacritice, exact cum ai cerut:
1.	endpoint public POST /lead/capture + validari Zod + salvare in Cosmos
2.	conversation state machine (step 1..8) care intreaba pe rand si salveaza progresul in Cosmos (cu TTL), ca userul sa nu trimita tot “amestecat”.
Important: in tot flow-ul NU cerem si NU repetam nume de banci. La intrebarea 1 cerem doar tip creditor (banca/IFN/leasing) si sold total aproximativ.
________________________________________
A) Cosmos setup
Containere recomandate
1.	leads (salvezi lead-ul final)
•	Partition key: /pk
•	TTL: optional (ex 365 zile) sau fara
2.	lead_sessions (state machine)
•	Partition key: /pk
•	TTL: activ (ex 7 zile = 604800 sec)
ENV:
•	COSMOS_CONTAINER_LEADS=leads
•	COSMOS_CONTAINER_LEAD_SESSIONS=lead_sessions
•	LEAD_SESSION_TTL_DAYS=7
________________________________________
B) Endpoint POST /lead/capture (Azure Functions TS)
1) Contract + Zod validation
src/lead/contracts.ts
export type TipCreditor = "BANCA" | "IFN" | "LEASING" | "MIXT" | "NU_STIU";

export interface LeadCaptureRequest {
  nume_prenume: string;
  telefon: string;
  email: string;
  oras: string;

  credite_active: boolean;
  sold_total_aprox?: number;      // lei
  tip_creditor?: TipCreditor;     // fara nume

  intarzieri: boolean;
  intarzieri_numar_aprox?: number;
  intarzieri_zile_max?: 0 | 30 | 60 | 90 | 120;

  venit_net_lunar: number;        // lei
  bonuri_masa_aprox?: number;     // lei

  poprire_sau_executor_ultimii_5_ani: boolean;
  situatie_poprire_inchisa?: boolean; // doar daca poprire=true
}

export interface LeadCaptureResponse {
  lead_id: string;
  status: "OK";
  mesaj: string;
}
src/lead/validation.ts
import { z } from "zod";

const phoneRo = z.string().trim().min(8).max(20)
  .regex(/^[0-9+\s-]+$/, "telefon invalid");

const email = z.string().trim().email("email invalid").max(200);

export const LeadCaptureSchema = z.object({
  nume_prenume: z.string().trim().min(3).max(120),
  telefon: phoneRo,
  email: email,
  oras: z.string().trim().min(2).max(80),

  credite_active: z.boolean(),
  sold_total_aprox: z.number().int().min(0).max(50_000_000).optional(),
  tip_creditor: z.enum(["BANCA", "IFN", "LEASING", "MIXT", "NU_STIU"]).optional(),

  intarzieri: z.boolean(),
  intarzieri_numar_aprox: z.number().int().min(0).max(999).optional(),
  intarzieri_zile_max: z.union([z.literal(0), z.literal(30), z.literal(60), z.literal(90), z.literal(120)]).optional(),

  venit_net_lunar: z.number().int().min(0).max(1_000_000),
  bonuri_masa_aprox: z.number().int().min(0).max(200_000).optional(),

  poprire_sau_executor_ultimii_5_ani: z.boolean(),
  situatie_poprire_inchisa: z.boolean().optional()
}).superRefine((val, ctx) => {
  if (val.credite_active) {
    if (val.sold_total_aprox === undefined) {
      ctx.addIssue({ code: z.ZodIssueCode.custom, path: ["sold_total_aprox"], message: "sold_total_aprox este necesar daca ai credite active" });
    }
    if (val.tip_creditor === undefined) {
      ctx.addIssue({ code: z.ZodIssueCode.custom, path: ["tip_creditor"], message: "tip_creditor este necesar daca ai credite active" });
    }
  }
  if (val.intarzieri) {
    if (val.intarzieri_zile_max === undefined) {
      ctx.addIssue({ code: z.ZodIssueCode.custom, path: ["intarzieri_zile_max"], message: "intarzieri_zile_max este necesar daca ai intarzieri" });
    }
  }
  if (val.poprire_sau_executor_ultimii_5_ani) {
    if (val.situatie_poprire_inchisa === undefined) {
      ctx.addIssue({ code: z.ZodIssueCode.custom, path: ["situatie_poprire_inchisa"], message: "situatie_poprire_inchisa este necesar daca ai poprire/executor" });
    }
  }
});
________________________________________
2) Cosmos save helper
src/lead/cosmosLeads.ts
import crypto from "node:crypto";
import { getContainer } from "../shared/cosmosClient.js";
import { LeadCaptureRequest } from "./contracts.js";

const LEADS_CONTAINER = process.env.COSMOS_CONTAINER_LEADS!;

export interface LeadDoc extends LeadCaptureRequest {
  id: string;
  pk: string;              // userId sau anon session id
  created_at: string;
  updated_at: string;
  source: "api" | "chat_state_machine";
}

export async function createLead(userPk: string, payload: LeadCaptureRequest, source: LeadDoc["source"]): Promise<LeadDoc> {
  const c = getContainer(LEADS_CONTAINER);
  const id = `lead_${crypto.randomUUID()}`;
  const now = new Date().toISOString();

  const doc: LeadDoc = {
    ...payload,
    id,
    pk: userPk,
    created_at: now,
    updated_at: now,
    source
  };

  const { resource } = await c.items.create(doc);
  if (!resource) throw new Error("LEAD_SAVE_FAILED");
  return resource;
}
________________________________________
3) Function handler: /lead/capture
src/functions/leadCapture.ts
import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";
import { LeadCaptureSchema } from "../lead/validation.js";
import { createLead } from "../lead/cosmosLeads.js";
import { requireUser } from "../shared/userAuth.js";

function json(status: number, body: any): HttpResponseInit {
  return { status, jsonBody: body, headers: { "content-type": "application/json" } };
}

export async function handler(req: HttpRequest, ctx: InvocationContext): Promise<HttpResponseInit> {
  try {
    // Non-admin, dar cu JWT user auth (recomandat)
    const user = await requireUser(req);

    const body = await req.json();
    const parsed = LeadCaptureSchema.safeParse(body);
    if (!parsed.success) return json(400, { error: "cerere_invalida", detalii: parsed.error.flatten() });

    // NU salvam nume de banca (nici nu exista in schema)
    const lead = await createLead(user.sub, parsed.data, "api");

    return json(200, {
      lead_id: lead.id,
      status: "OK",
      mesaj: "Multumesc! Am inregistrat datele. Un broker autorizat te va contacta pentru pasii urmatori."
    });
  } catch (e: any) {
    const code = String(e?.message ?? "UNKNOWN");
    if (code === "NO_AUTH" || code === "NO_SUB") return json(401, { error: "neautorizat" });

    ctx.error(e);
    return json(500, { error: "eroare_server", code });
  }
}

app.http("leadCapture", {
  methods: ["POST"],
  authLevel: "anonymous",
  route: "lead/capture",
  handler
});
src/index.ts
import "./functions/leadCapture.js";
________________________________________
C) Conversation state machine (step 1..8) cu Cosmos (TTL)
Ideea: userul scrie in chat, iar backend-ul:
•	stie ce pas urmeaza
•	pune intrebarea urmatoare
•	extrage raspunsul (light parsing) si il salveaza in sesiune
•	la final, construieste payload si apeleaza createLead(...)
1) Model sesiune
src/lead/sessionTypes.ts
import { TipCreditor } from "./contracts.js";

export type LeadStep =
  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9; // 9 = DONE

export interface LeadSessionData {
  nume_prenume?: string;
  telefon?: string;
  email?: string;
  oras?: string;

  credite_active?: boolean;
  sold_total_aprox?: number;
  tip_creditor?: TipCreditor;

  intarzieri?: boolean;
  intarzieri_numar_aprox?: number;
  intarzieri_zile_max?: 0 | 30 | 60 | 90 | 120;

  venit_net_lunar?: number;
  bonuri_masa_aprox?: number;

  poprire_sau_executor_ultimii_5_ani?: boolean;
  situatie_poprire_inchisa?: boolean;
}

export interface LeadSessionDoc {
  id: string;         // "lead_session:<userId>:<conversationId>"
  pk: string;
  step: LeadStep;
  data: LeadSessionData;
  created_at: string;
  updated_at: string;
  ttl?: number;
}
2) Cosmos helper pentru sesiune
src/lead/cosmosLeadSessions.ts
import { getContainer } from "../shared/cosmosClient.js";
import { LeadSessionDoc } from "./sessionTypes.js";

const SESS_CONTAINER = process.env.COSMOS_CONTAINER_LEAD_SESSIONS!;
const TTL_DAYS = Number(process.env.LEAD_SESSION_TTL_DAYS ?? "7");
const TTL_SEC = Math.max(1, Math.floor(TTL_DAYS * 24 * 3600));

export async function loadSession(id: string): Promise<LeadSessionDoc | null> {
  const c = getContainer(SESS_CONTAINER);
  try {
    const { resource } = await c.item(id, id).read<LeadSessionDoc>();
    return resource ?? null;
  } catch {
    return null;
  }
}

export async function saveSession(doc: LeadSessionDoc): Promise<LeadSessionDoc> {
  const c = getContainer(SESS_CONTAINER);
  const now = new Date().toISOString();
  const full: LeadSessionDoc = {
    ...doc,
    pk: doc.id,
    updated_at: now,
    ttl: TTL_SEC
  };
  const { resource } = await c.items.upsert(full);
  if (!resource) throw new Error("LEAD_SESSION_SAVE_FAILED");
  return resource;
}

export async function initSession(id: string): Promise<LeadSessionDoc> {
  const now = new Date().toISOString();
  const doc: LeadSessionDoc = {
    id,
    pk: id,
    step: 1,
    data: {},
    created_at: now,
    updated_at: now,
    ttl: TTL_SEC
  };
  return saveSession(doc);
}

export async function clearSession(id: string): Promise<void> {
  const c = getContainer(SESS_CONTAINER);
  try { await c.item(id, id).delete(); } catch {}
}
________________________________________
3) Step prompts (intrebari pe rand)
src/lead/stepPrompts.ts
import { LeadStep } from "./sessionTypes.js";

export function promptForStep(step: LeadStep): string {
  switch (step) {
    case 1:
      return "Pentru a intelege situatia ta, te rog raspunde pe rand. Pasul 1/8: Care este numele si prenumele tau? (fara CNP/CI)";
    case 2:
      return "Pasul 2/8: Care este numarul tau de telefon? (doar numar, fara alte date sensibile)";
    case 3:
      return "Pasul 3/8: Care este adresa ta de email?";
    case 4:
      return "Pasul 4/8: Ai credite active in prezent? Raspunde cu DA sau NU.";
    case 5:
      return "Pasul 5/8: Ai avut intarzieri la plata in trecut? Raspunde cu DA sau NU. Daca DA, spune aproximativ cate zile au fost cele mai mari (30/60/90+).";
    case 6:
      return "Pasul 6/8: Care este venitul tau net lunar (cat intra pe card)? Daca ai bonuri/tichete de masa, scrie si suma aproximativa.";
    case 7:
      return "Pasul 7/8: Din ce oras esti?";
    case 8:
      return "Pasul 8/8: In ultimii 5 ani ai avut poprire pe salariu din cauza unui credit sau ai platit la executor / firma de recuperari? Raspunde cu DA sau NU. Daca DA, spune doar daca situatia este inchisa sau inca activa.";
    default:
      return "Multumesc! Am inregistrat informatiile.";
  }
}
________________________________________
4) Parsare simpla a raspunsurilor (fara AI)
src/lead/stepParse.ts
import { LeadSessionDoc } from "./sessionTypes.js";

function norm(s: string) {
  return (s || "").trim();
}
function normLower(s: string) {
  return norm(s).toLowerCase();
}
function parseYesNo(s: string): boolean | null {
  const t = normLower(s);
  if (["da", "d", "yes"].some(x => t === x || t.startsWith(x + " "))) return true;
  if (["nu", "n", "no"].some(x => t === x || t.startsWith(x + " "))) return false;
  return null;
}
function extractFirstInt(s: string): number | null {
  const m = norm(s).replace(/\./g, "").match(/(\d{1,9})/);
  if (!m) return null;
  return Number(m[1]);
}
function bucketDaysMax(s: string): 0|30|60|90|120|null {
  const t = normLower(s);
  if (t.includes("120") || t.includes("peste 90") || t.includes("90+") || t.includes("100")) return 120;
  if (t.includes("90")) return 90;
  if (t.includes("60")) return 60;
  if (t.includes("30")) return 30;
  return null;
}

export function applyAnswer(session: LeadSessionDoc, answerRaw: string): { session: LeadSessionDoc; error?: string } {
  const ans = norm(answerRaw);

  switch (session.step) {
    case 1: {
      if (ans.length < 3) return { session, error: "Te rog scrie nume si prenume." };
      session.data.nume_prenume = ans;
      session.step = 2;
      return { session };
    }
    case 2: {
      const cleaned = ans.replace(/\s+/g, "");
      if (cleaned.length < 8) return { session, error: "Te rog scrie un numar de telefon valid." };
      session.data.telefon = ans;
      session.step = 3;
      return { session };
    }
    case 3: {
      if (!ans.includes("@") || ans.length < 6) return { session, error: "Te rog scrie un email valid." };
      session.data.email = ans;
      session.step = 4;
      return { session };
    }
    case 4: {
      const yn = parseYesNo(ans);
      if (yn === null) return { session, error: "Te rog raspunde cu DA sau NU." };
      session.data.credite_active = yn;

      // daca DA, cerem clarificare in acelasi pas urmator? Simplu: mergem la 5, iar in 5 putem cere si sold.
      session.step = 5;
      return { session };
    }
    case 5: {
      const yn = parseYesNo(ans);
      if (yn !== null) {
        session.data.intarzieri = yn;
        if (!yn) {
          session.data.intarzieri_zile_max = 0;
        }
        session.step = 6;
        return { session };
      }

      // daca user scrie "DA 60 zile" sau doar "60"
      const days = bucketDaysMax(ans);
      if (days !== null) {
        session.data.intarzieri = true;
        session.data.intarzieri_zile_max = days;
        session.step = 6;
        return { session };
      }

      return { session, error: "Te rog raspunde cu DA sau NU. Daca DA, poti adauga: 30/60/90+." };
    }
    case 6: {
      // ex: "5200" sau "5200 si bonuri 800"
      const first = extractFirstInt(ans);
      if (first === null) return { session, error: "Te rog scrie venitul net lunar ca numar (ex: 5200)." };
      session.data.venit_net_lunar = first;

      // cautam si a doua suma ca bonuri
      const nums = ans.replace(/\./g, "").match(/\d{1,9}/g) ?? [];
      if (nums.length >= 2) {
        const second = Number(nums[1]);
        if (Number.isFinite(second)) session.data.bonuri_masa_aprox = second;
      }
      session.step = 7;
      return { session };
    }
    case 7: {
      if (ans.length < 2) return { session, error: "Te rog scrie orasul." };
      session.data.oras = ans;
      session.step = 8;
      return { session };
    }
    case 8: {
      const yn = parseYesNo(ans);
      if (yn !== null) {
        session.data.poprire_sau_executor_ultimii_5_ani = yn;
        if (!yn) session.data.situatie_poprire_inchisa = undefined;
        session.step = 9;
        return { session };
      }

      // daca user scrie "da inchisa" / "da activa"
      const t = normLower(ans);
      if (t.startsWith("da")) {
        session.data.poprire_sau_executor_ultimii_5_ani = true;
        if (t.includes("inchis") || t.includes("rezolvat")) session.data.situatie_poprire_inchisa = true;
        else if (t.includes("activ") || t.includes("in derulare")) session.data.situatie_poprire_inchisa = false;
        session.step = 9;
        return { session };
      }

      return { session, error: "Te rog raspunde cu DA sau NU. Daca DA, spune si 'inchisa' sau 'activa'." };
    }
    default:
      return { session };
  }
}
________________________________________
5) Convert sesiune -> payload final + salveaza lead
src/lead/sessionFinalize.ts
import { LeadCaptureRequest, TipCreditor } from "./contracts.js";
import { LeadSessionDoc } from "./sessionTypes.js";

export function buildLeadPayloadFromSession(s: LeadSessionDoc): { ok: true; payload: LeadCaptureRequest } | { ok: false; error: string } {
  const d = s.data;

  // campuri obligatorii
  if (!d.nume_prenume || !d.telefon || !d.email || !d.oras) return { ok: false, error: "Lipsesc date de contact." };
  if (d.venit_net_lunar === undefined) return { ok: false, error: "Lipseste venitul net." };
  if (d.credite_active === undefined) return { ok: false, error: "Lipseste raspunsul despre credite active." };
  if (d.intarzieri === undefined) return { ok: false, error: "Lipseste raspunsul despre intarzieri." };
  if (d.poprire_sau_executor_ultimii_5_ani === undefined) return { ok: false, error: "Lipseste raspunsul despre poprire/executor." };

  // pentru simplificare: daca are credite active, dar n-am colectat sold/tip creditor in pasi,
  // poti cere intr-un pas extra. Pentru MVP, setam default:
  const tip: TipCreditor | undefined = d.credite_active ? (d.tip_creditor ?? "NU_STIU") : undefined;

  const payload: LeadCaptureRequest = {
    nume_prenume: d.nume_prenume,
    telefon: d.telefon,
    email: d.email,
    oras: d.oras,

    credite_active: d.credite_active,
    sold_total_aprox: d.credite_active ? (d.sold_total_aprox ?? 0) : undefined,
    tip_creditor: d.credite_active ? tip : undefined,

    intarzieri: d.intarzieri,
    intarzieri_numar_aprox: d.intarzieri ? (d.intarzieri_numar_aprox ?? 0) : undefined,
    intarzieri_zile_max: d.intarzieri ? (d.intarzieri_zile_max ?? 30) : 0,

    venit_net_lunar: d.venit_net_lunar,
    bonuri_masa_aprox: d.bonuri_masa_aprox ?? 0,

    poprire_sau_executor_ultimii_5_ani: d.poprire_sau_executor_ultimii_5_ani,
    situatie_poprire_inchisa: d.poprire_sau_executor_ultimii_5_ani ? (d.situatie_poprire_inchisa ?? false) : undefined
  };

  return { ok: true, payload };
}
Optional recomandat: daca credite_active=true, mai bagi 1 pas extra “4b” pentru sold_total_aprox si “4c” pentru tip_creditor. Daca vrei, ti-l extind imediat. Acum am pasii exact 1..8 cum ai cerut.
________________________________________
6) Endpoint pentru state machine: POST /lead/next
Acesta gestioneaza pas cu pas: user trimite raspunsul curent, server raspunde cu urmatoarea intrebare.
src/functions/leadNext.ts
import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";
import { requireUser } from "../shared/userAuth.js";
import { loadSession, initSession, saveSession, clearSession } from "../lead/cosmosLeadSessions.js";
import { applyAnswer } from "../lead/stepParse.js";
import { promptForStep } from "../lead/stepPrompts.js";
import { buildLeadPayloadFromSession } from "../lead/sessionFinalize.js";
import { createLead } from "../lead/cosmosLeads.js";
import { LeadCaptureSchema } from "../lead/validation.js";

function json(status: number, body: any): HttpResponseInit {
  return { status, jsonBody: body, headers: { "content-type": "application/json" } };
}

function sessionId(userId: string, conversationId?: string) {
  return `lead_session:${userId}:${conversationId || "default"}`;
}

export async function handler(req: HttpRequest, ctx: InvocationContext): Promise<HttpResponseInit> {
  try {
    const user = await requireUser(req);

    const body = await req.json().catch(() => ({}));
    const conversation_id = String(body.conversation_id || "default");
    const action = String(body.action || "answer"); // "start" | "answer" | "reset"
    const answer = String(body.answer || "");

    const sid = sessionId(user.sub, conversation_id);
    let sess = await loadSession(sid);

    if (action === "reset") {
      await clearSession(sid);
      sess = null;
    }

    if (!sess) {
      sess = await initSession(sid);
    }

    if (action === "start") {
      return json(200, {
        done: false,
        step: sess.step,
        mesaj: promptForStep(sess.step)
      });
    }

    // answer flow
    const applied = applyAnswer(sess, answer);
    if (applied.error) {
      await saveSession(applied.session);
      return json(200, {
        done: false,
        step: applied.session.step,
        mesaj: applied.error + " " + promptForStep(applied.session.step)
      });
    }

    sess = await saveSession(applied.session);

    if (sess.step !== 9) {
      return json(200, {
        done: false,
        step: sess.step,
        mesaj: promptForStep(sess.step)
      });
    }

    // DONE -> construim payload + validam strict cu Zod + salvam lead
    const built = buildLeadPayloadFromSession(sess);
    if (!built.ok) {
      return json(200, {
        done: false,
        step: 1,
        mesaj: "Nu am putut finaliza formularul: " + built.error + " Hai sa o luam de la inceput. Pasul 1/8: Care este numele si prenumele tau?"
      });
    }

    const strict = LeadCaptureSchema.safeParse(built.payload);
    if (!strict.success) {
      return json(200, {
        done: false,
        step: 1,
        mesaj: "Datele nu sunt complete sau valide. Hai sa o luam de la inceput. Pasul 1/8: Care este numele si prenumele tau?"
      });
    }

    const lead = await createLead(user.sub, strict.data, "chat_state_machine");
    await clearSession(sid);

    return json(200, {
      done: true,
      step: 9,
      lead_id: lead.id,
      mesaj: "Multumesc! Am inregistrat informatiile. Un broker autorizat te va contacta pentru pasii urmatori. Nota: Rezultatele sunt estimative; aprobarea finala apartine creditorului."
    });

  } catch (e: any) {
    const code = String(e?.message ?? "UNKNOWN");
    if (code === "NO_AUTH" || code === "NO_SUB") return json(401, { error: "neautorizat" });

    ctx.error(e);
    return json(500, { error: "eroare_server", code });
  }
}

app.http("leadNext", {
  methods: ["POST"],
  authLevel: "anonymous",
  route: "lead/next",
  handler
});
src/index.ts (adaugi)
import "./functions/leadNext.js";
________________________________________
D) Cum foloseste FE (flow cap-coada)
Varianta 1: direct in chat (pas cu pas)
1.	Cand user apasa “Vreau analiza personalizata”:
•	POST /lead/next cu { action: "start", conversation_id: "abc" }
2.	FE afiseaza mesajul primit (Pasul 1/8...)
3.	User raspunde, FE trimite:
•	POST /lead/next cu { action: "answer", conversation_id:"abc", answer:"..." }
4.	Repeta pana la done=true si primesti lead_id.
Varianta 2: formular clasic + submit
•	FE colecteaza toate campurile si trimite:
o	POST /lead/capture
________________________________________
E) Nota importanta (banci)
In niciunul din endpoint-uri nu acceptam camp “banca”. Daca user scrie nume de banca in raspuns, tu in UI poti afisa un mesaj: “Te rog fara nume de banci” (optional), dar backend-ul nu il salveaza.
________________________________________
Daca vrei, iti fac imediat o extensie mica, foarte utila:
•	daca la pasul 4 user raspunde “DA”, sa intre automat in 2 sub-pasi: 4a sold total si 4b tip creditor (banca/IFN/leasing), fara sa depasim 10 pasi total.


