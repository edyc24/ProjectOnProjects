Perfect, procedăm „product spec → config → formule → reguli → output”, ca să îi dai IT-istului exact ce implementează.
Mai jos ai varianta READY TO BUILD (calculator simplu + calculator avansat KYC/ANAF/BC), cu structură de date, formule, reguli, pseudocod, și ce câmpuri se citesc din rapoarte (din PDF-urile tale).
________________________________________
0) Cum procedăm ca să iasă corect din prima
1.	Facem un “Rules + Rates Config” (JSON în DB) – nimic hardcodat în cod.
2.	Implementăm 2 motoare:
o	SimpleEligibilityEngine (fără cont, fără ANAF/BC)
o	VerifiedEligibilityEngine (KYC + ANAF + BC)
3.	Ambele motoare returnează aceeași structură de output (ca UI-ul să fie simplu).
________________________________________
1) Calculator simplu (fără cont / fără ANAF / fără BC)
Input (UI)
•	salary_net_user (ex: 3200)
•	meal_tickets_user (ex: 840) – bonuri
•	loan_type: NP (nevoi personale) / IPOTECAR
•	Pentru NP: desired_amount (opțional), term_months (default 60, max 60)
•	Pentru ipotecar: property_value (opțional), has_owned_home_before (Da/Nu), income_source (RO / STRAINATATE)
Normalizare venit (simplu)
În simplu, n-ai ANAF, deci:
•	net_income = salary_net_user
•	meal_income = meal_tickets_user * meal_ticket_weight_simple
•	eligible_income = net_income + meal_income
meal_ticket_weight_simple îl faci setare (ex. 0.0 / 0.5 / 1.0). Mulți îl vor 100% „ca orientare”, dar în practică diferă, deci îl lași configurabil.
Reguli DTI (grad îndatorare) – simplu
NP (RON)
•	dacă eligible_income >= 5500 ⇒ DTI = 0.50
•	altfel ⇒ DTI = 0.40
IPOTECAR
•	regulă generală: DTI = 0.40
•	dacă eligible_income >= 6500 ⇒ DTI = 0.55 (conform cerinței tale)
Avans ipotecar – simplu (orientativ)
•	dacă income_source = RO:
o	dacă has_owned_home_before = NO ⇒ avans 15%
o	dacă has_owned_home_before = YES ⇒ avans 25%
•	dacă income_source = STRAINATATE:
o	condiție minim: eligible_income_eur >= 2000 (echivalent)
o	avans 25% – 40% (îl pui slider sau select: 25 / 30 / 35 / 40)
Notă de piață: avansurile reale variază; ex. BT comunică avans minim 15% pe lei și mai mare pe valută. (Banca Transilvania)
Raiffeisen menționează uzual 15%–25% în funcție de profil. (Raiffeisen Bank)
Dobânzi afișate (simplu)
NP: interval informativ 7.49% – 15.99%, max 60 luni (cum ai spus).
Ipotecar promo: 4.79% – 5.99% fix 3 ani (cum ai spus).
Încadrare ipotecar „pe marjă + IRCC”
Pentru calcule interne (eligibilitate), folosești:
•	stress_rate = bank_margin + IRCC_current
Tu ai dat exemplu: marjă 2.49% + IRCC. IRCC acum e 5.68% (valoare oficială curentă publicată, aplicabilă de la 1 ianuarie 2026). (Curs BNR)
IMPORTANT: în config ai:
•	IRCC_current (auto / manual)
•	IRCC_next (opțional)
•	bank_margin_default (ex. 2.49) + posibil margini per bancă
________________________________________
2) Calculator avansat (KYC + ANAF + Biroul de Credit)
Aici ai 3 mari pași: Venit real (ANAF) → risc (BC) → ofertare (DTI + rate + routing).
2.1 Citire ANAF (media minim 6 luni)
În raportul tău ANAF se vede clar D112 cu câmpurile:
•	Contravaloare tichete de masa
•	Suma incasata (netul plătit)
Exemple din raport: apare coloana “Contravaloare tichete de masa” și “Suma incasata”.
Regulă venit ANAF:
•	iei ultimele 6 luni consecutive (sau ultimele 6 luni disponibile)
•	avg_net_6m = average(month.suma_incasata)
•	avg_meal_6m = average(month.tichete_masa)
•	eligible_income_anaf = avg_net_6m + avg_meal_6m * meal_ticket_weight_verified
În Verified, meal_ticket_weight_verified îl poți seta mai conservator (ex. 0.5) vs simplu (ex. 1.0).
Fallback:
•	dacă ai < 6 luni ⇒ media pe câte ai, dar marchezi confidence = LOW și „necesită confirmare”.
2.2 Citire Biroul de Credit (BC)
Din raportul atașat se pot citi:
•	FICO score (exemplu: scor 632)
•	sumar conturi + indicatori
•	legendă categorii întârzieri:
o	„Categorie +30 zile”, „+60”, „+90”, „+120”, „+150”, „+180” etc.
Reguli ipotecar (ignoră FICO, dar verifică întârzieri)
Conform cerinței tale:
•	respingi/flag dacă în ultimii 4 ani:
o	întârzieri 30 zile (cat=1) > 4
o	întârzieri 60 zile (cat=2) > 1
o	orice cat >= 3 (90+ zile) ⇒ de regulă blocant (îți recomand să-l marchezi „Manual review”, nu automat reject, ca să ai control)
În raport, categoriile sunt codate prin legendă (1=+30, 2=+60 etc.).
Reguli NP (include FICO + excepții)
•	dacă DTI standard (40%): FICO minim 581
•	dacă FICO < 581 dar >= 500: route către bănci „mai permisive pe FICO” (cum ai spus: Garanti, BRD, ING – în engine le ții ca “fallback lenders”)
•	dacă FICO < 500: status = MANUAL_REVIEW (sau DECLINED dacă vrei strict)
În raportul tău există FICO și explicațiile scorului.
Reguli IFN / Non-Bancari (din cerința ta)
•	dacă în istoric 4 ani:
o	closed_nonbank_accounts > 10 și
o	active_nonbank_accounts > 4
⇒ risk_flag = HIGH_IFN_EXPOSURE și:
o	fie reduci DTI la 35% automat,
o	fie trimiți pe „Manual review / consolidare”.
Notă: în exemplul de „Situația înscrierii” se văd indicatori Bancari vs Non-Bancari și număr conturi etc.
Dar ca să poți calcula exact „active” și „closed în 4 ani”, ideal e să ai raportul BC complet (nu doar situația). Dacă tu vei cumpăra raport complet prin integrare, parsezi evenimentele pe fiecare cont.
________________________________________
3) Reguli DTI (avansat)
NP (avansat)
•	base_dti = 0.40
•	dacă eligible_income_anaf >= 5500 și FICO >= 601 și suntem în fereastra de trimestru (mai jos) ⇒ dti = 0.50
•	altfel:
o	dacă FICO >= 581 ⇒ dti = 0.40
o	dacă 500 <= FICO < 581 ⇒ dti = 0.40 dar doar în pool-ul de bănci fallback
o	dacă FICO < 500 ⇒ manual
„Fereastra de trimestru” pentru DTI 50% (NP)
Tu ai cerut:
•	disponibil doar o dată pe trimestru, în jurul:
o	prima zi lucrătoare din Ian / Apr / Iul / Oct
•	durează 3–4 zile (plafon)
Implementare simplă:
•	în config: high_dti_windows = listă de intervale (date concrete pe an)
•	admin le actualizează anual în 2 minute (cel mai safe)
(Dacă vrei auto 100%, trebuie calendar de sărbători/zi lucrătoare. Eu aș face „admin update” ca să nu greșești legal/comercial.)
Ipotecar (avansat)
•	ignoră FICO în decizie
•	aplică doar:
o	venit ANAF (medie 6 luni)
o	reguli întârzieri
o	avans (15/25/25–40)
o	stres: bank_margin + IRCC
________________________________________
4) Formule financiare (rate / sumă maximă)
4.1 Rata maximă admisă
•	max_monthly_payment = eligible_income * dti - existing_monthly_obligations
În simplu, existing_monthly_obligations e 0 (că nu ai BC).
În avansat, îl iei din BC (sumă lunară programată / estimări).
În raport BC există “Valoare lunară programată” pe cont.
4.2 Anuitate (pentru sumă maximă)
Pentru dobândă anuală APR, dobândă lunară r = APR/12.
Formula sumă maximă (anuitate):
PV = Pmt * (1 - (1 + r)^(-n)) / r
unde:
•	PV = principal (suma maximă)
•	Pmt = rata maximă admisă
•	n = luni
NP: n max 60.
Ipotecar: n = 360 (30 ani) sau din config per bancă.
4.3 Dobânda ipotecară pentru eligibilitate (stres)
•	APR_stress = bank_margin + IRCC_current
IRCC curent: 5.68%. (Curs BNR)
________________________________________
5) „Rates & Rules Config” (ce bagi în DB) – exemplu JSON
{
  "version": "2026-01-05",
  "ircc": {
    "current": 5.68,
    "next": 5.58,
    "source": "manual_or_bnr_scrape",
    "last_updated": "2026-01-05"
  },
  "income": {
    "meal_ticket_weight_simple": 1.0,
    "meal_ticket_weight_verified": 0.5
  },
  "np": {
    "max_term_months": 60,
    "apr_min": 7.49,
    "apr_max": 15.99,
    "dti_standard": 0.40,
    "dti_high": 0.50,
    "income_high_dti_min": 5500,
    "fico_min_standard": 581,
    "fico_min_high_dti": 601,
    "fico_min_fallback": 500,
    "high_dti_windows": [
      { "start": "2026-01-02", "end": "2026-01-06" },
      { "start": "2026-04-01", "end": "2026-04-06" },
      { "start": "2026-07-01", "end": "2026-07-06" },
      { "start": "2026-10-01", "end": "2026-10-06" }
    ],
    "fallback_lenders": ["GARANTI", "BRD", "ING"]
  },
  "mortgage": {
    "promo_fixed_min": 4.79,
    "promo_fixed_max": 5.99,
    "stress_margin_default": 2.49,
    "dti_standard": 0.40,
    "dti_high_income": 0.55,
    "income_dti_high_min": 6500,
    "downpayment": {
      "ro_first_home": 0.15,
      "ro_not_first_home": 0.25,
      "foreign_income_min_eur": 2000,
      "foreign_min": 0.25,
      "foreign_max": 0.40
    },
    "bc_rules": {
      "max_30dpd_last_4y": 4,
      "max_60dpd_last_4y": 1,
      "any_90dpd_last_4y": "manual_review"
    }
  },
  "risk_flags": {
    "ifn_closed_4y_gt": 10,
    "ifn_active_gt": 4,
    "action": "manual_review_or_reduce_dti"
  }
}
________________________________________
6) Pseudocod (motor unificat)
function runEligibility(input, mode, config, parsedANAF?, parsedBC?):
  if mode == "SIMPLE":
    income = input.salary_net + input.meal_tickets * config.income.meal_ticket_weight_simple
  else:
    income = avg6(parsedANAF.suma_incasata) +
             avg6(parsedANAF.tichete_masa) * config.income.meal_ticket_weight_verified

  if input.loan_type == "NP":
    dti = config.np.dti_standard
    lenders_pool = "STANDARD"

    if mode == "VERIFIED":
      fico = parsedBC.fico
      if fico < config.np.fico_min_fallback:
        return MANUAL_REVIEW("FICO_TOO_LOW")

      if fico < config.np.fico_min_standard:
        lenders_pool = "FALLBACK"
      else:
        lenders_pool = "STANDARD"

      if income >= config.np.income_high_dti_min AND
         fico >= config.np.fico_min_high_dti AND
         today in any(config.np.high_dti_windows):
           dti = config.np.dti_high

    else: // SIMPLE
      if income >= config.np.income_high_dti_min:
        dti = config.np.dti_high

    maxPmt = income * dti - obligations(mode, parsedBC)
    aprForCalc = chooseAPR(input.desired_amount, config) // ex bucket
    maxAmount = annuityPV(maxPmt, aprForCalc, input.term_months or 60)

    return OFFER(maxAmount, maxPmt, dti, lenders_pool)

  else if input.loan_type == "IPOTECAR":
    // dti
    dti = config.mortgage.dti_standard
    if income >= config.mortgage.income_dti_high_min:
      dti = config.mortgage.dti_high_income

    // downpayment
    dp = determineDownpayment(input, income, config)

    if mode == "VERIFIED":
      bcCheck = checkMortgageBC(parsedBC, config.mortgage.bc_rules)
      if bcCheck == "BLOCK":
        return MANUAL_REVIEW("BC_DELAY_RULES")

      if checkIFNRisk(parsedBC, config.risk_flags):
        // either reduce dti or manual
        dti = min(dti, 0.35) OR return MANUAL_REVIEW("HIGH_IFN_EXPOSURE")

    maxPmt = income * dti - obligations(mode, parsedBC)

    stressApr = config.mortgage.stress_margin_default + config.ircc.current
    maxAmount = annuityPV(maxPmt, stressApr, 360)

    return OFFER(maxAmount, maxPmt, dti, dp, stressApr)
________________________________________
7) Parsing concret: ce citești din rapoartele tale
Din ANAF (PDF)
Câmpurile utile sunt în D112:
•	Suma incasata (net)
•	Contravaloare tichete de masa
Se văd în raportul tău pe liniile lunare.
Din BC (PDF)
•	FICO Score – apare explicit (ex: 632).
•	Valoare lunara programata pe fiecare cont (obligații).
•	legendă întârzieri (mapare 1=30, 2=60 etc.).
________________________________________
8) Update IRCC: manual vs automat
Cel mai sigur: admin panel cu:
•	IRCC_current, IRCC_next, last_updated, source_link
Dacă vrei automat: cron zilnic care citește pagina IRCC (BNR/aggregator) și face update dacă s-a schimbat.
IRCC curent 5.68% e confirmat public (și apare și că urmează 5.58% de la 1 aprilie 2026). (Curs BNR)
________________________________________
9) Ce îi dai IT-istului ca „task list”
1.	DB table: rates_rules_config (JSON + versioning)
2.	Service:
o	simpleEligibilityEngine.ts
o	verifiedEligibilityEngine.ts
3.	Parsers:
o	anafParser → extrage luni + suma_incasata + tichete_masa
o	bcParser → fico, accounts[] (type, participant, dpd history), monthly_obligations, nonbank_counts
4.	UI:
o	Step 1 (simple) / Step 2 (verified) – aceeași pagină, doar că verified are badge + rezultate mai precise
5.	Admin panel:
o	edit config (IRCC, marje, ferestre trimestru, praguri)
________________________________________
Dacă vrei, îți fac și “Output contract” (exact JSON-ul pe care îl consumă frontendul: sumă max, rată max, DTI, avans, status, motive, bănci recomandate). Și îți adaptez și „bucketizarea dobânzii” la NP (ex: 0–100k, 100–190k, 190–200k) cum ai început să descrii, ca să fie complet.
Mai jos ai Output Contract (JSON) pe care îl consumă frontend-ul, identic pentru SIMPLE și VERIFIED, doar că în VERIFIED apar câmpuri extra (ANAF/BC flags, confidence etc.). E „ready to build” (TypeScript-friendly).
________________________________________
1) Response JSON – EligibilityResponse
{
  "request_id": "uuid",
  "mode": "SIMPLE",
  "loan_type": "NP",
  "currency": "RON",
  "status": "OK",
  "decision": {
    "rating": "B",
    "confidence": "MEDIUM",
    "reasons": [
      {
        "code": "DTI_STANDARD",
        "title": "Grad de îndatorare standard",
        "details": "Încadrarea este calculată la 40% din venit."
      }
    ],
    "risk_flags": []
  },
  "income": {
    "eligible_income_monthly": 4040,
    "salary_net_monthly": 3200,
    "meal_tickets_monthly": 840,
    "meal_ticket_weight_used": 1.0,
    "source": "USER_DECLARED",
    "period_months": null
  },
  "dti": {
    "dti_used": 0.4,
    "dti_cap_reason": "STANDARD_UNDER_5500",
    "existing_monthly_obligations": 0,
    "max_monthly_payment": 1616
  },
  "rates": {
    "np": {
      "apr_min": 7.49,
      "apr_max": 15.99,
      "apr_used_for_calc": 10.99,
      "term_months_used": 60
    },
    "mortgage": null
  },
  "offers": {
    "max_loan_amount_range": {
      "best_case": 79900,
      "worst_case": 68600
    },
    "max_loan_amount_used": 74200,
    "estimated_monthly_payment": null,
    "affordability": {
      "payment_max": 1616,
      "payment_buffer": 0,
      "notes": [
        "Rezultatul este orientativ (fără verificare ANAF/BC)."
      ]
    }
  },
  "routing": {
    "lenders_pool": "STANDARD",
    "recommended_lenders": [],
    "notes": []
  },
  "meta": {
    "config_version": "2026-01-05",
    "calculated_at": "2026-01-05T20:58:10+02:00"
  }
}
________________________________________
2) Enum-uri și reguli (pentru backend + UI)
status
•	OK – poate genera oferte
•	MANUAL_REVIEW – arată rezultat limitat + cere contact
•	DECLINED – arată motive, fără oferte
mode
•	SIMPLE
•	VERIFIED
lenders_pool
•	STANDARD
•	FALLBACK (ex: Garanti/BRD/ING pentru FICO 500–580 la NP)
•	LIMITED (ex: multe IFN)
•	NONE
confidence
•	LOW / MEDIUM / HIGH
o	SIMPLE: de obicei LOW/MEDIUM
o	VERIFIED (ANAF+BC): de obicei HIGH
________________________________________
3) Response pentru ipotecar – exemplu (SIMPLE)
{
  "request_id": "uuid",
  "mode": "SIMPLE",
  "loan_type": "IPOTECAR",
  "currency": "RON",
  "status": "OK",
  "decision": {
    "rating": "A",
    "confidence": "MEDIUM",
    "reasons": [
      {
        "code": "DTI_HIGH_INCOME",
        "title": "Grad de îndatorare extins",
        "details": "Venit ≥ 6500 lei, calculat la 55%."
      }
    ],
    "risk_flags": []
  },
  "income": {
    "eligible_income_monthly": 7000,
    "salary_net_monthly": 6500,
    "meal_tickets_monthly": 500,
    "meal_ticket_weight_used": 1.0,
    "source": "USER_DECLARED",
    "period_months": null
  },
  "dti": {
    "dti_used": 0.55,
    "dti_cap_reason": "INCOME_OVER_6500",
    "existing_monthly_obligations": 0,
    "max_monthly_payment": 3850
  },
  "rates": {
    "np": null,
    "mortgage": {
      "promo_fixed_3y_min": 4.79,
      "promo_fixed_3y_max": 5.99,
      "ircc_current": 5.68,
      "bank_margin_used": 2.49,
      "underwriting_rate_used": 8.17,
      "term_months_used": 360
    }
  },
  "mortgage_rules": {
    "income_source": "RO",
    "has_owned_home_before": false,
    "down_payment_min_percent": 0.15,
    "down_payment_range_percent": [0.15, 0.15]
  },
  "offers": {
    "max_loan_amount_range": null,
    "max_loan_amount_used": 468000,
    "estimated_monthly_payment": null,
    "affordability": {
      "payment_max": 3850,
      "payment_buffer": 0,
      "notes": [
        "Încadrarea este calculată conservator pe marjă + IRCC."
      ]
    }
  },
  "routing": {
    "lenders_pool": "STANDARD",
    "recommended_lenders": [],
    "notes": []
  },
  "meta": {
    "config_version": "2026-01-05",
    "calculated_at": "2026-01-05T20:58:10+02:00"
  }
}
________________________________________
4) Response VERIFIED (KYC + ANAF + BC) – include scor, întârzieri, IFN flags
NP VERIFIED – exemplu (FICO 540 → fallback lenders)
{
  "request_id": "uuid",
  "mode": "VERIFIED",
  "loan_type": "NP",
  "currency": "RON",
  "status": "OK",
  "decision": {
    "rating": "C",
    "confidence": "HIGH",
    "reasons": [
      {
        "code": "FICO_BELOW_STANDARD",
        "title": "FICO sub pragul standard",
        "details": "Încadrare posibilă la bănci tolerante pe FICO."
      }
    ],
    "risk_flags": [
      {
        "code": "FICO_TOLERANT_ROUTING",
        "severity": "MEDIUM",
        "details": "Routing către Garanti/BRD/ING."
      }
    ]
  },
  "income": {
    "eligible_income_monthly": 5200,
    "salary_net_monthly": null,
    "meal_tickets_monthly": null,
    "meal_ticket_weight_used": 0.5,
    "source": "ANAF_D112",
    "period_months": 6,
    "anaf": {
      "avg_net_6m": 5000,
      "avg_meal_6m": 400
    }
  },
  "credit_bureau": {
    "fico_score": 540,
    "dpd_last_4y": {
      "dpd_30_count": 2,
      "dpd_60_count": 0,
      "dpd_90plus_count": 0
    },
    "nonbank": {
      "closed_last_4y": 6,
      "active_now": 2
    }
  },
  "dti": {
    "dti_used": 0.4,
    "dti_cap_reason": "STANDARD",
    "existing_monthly_obligations": 850,
    "max_monthly_payment": 1230
  },
  "rates": {
    "np": {
      "apr_min": 7.49,
      "apr_max": 15.99,
      "apr_used_for_calc": 12.49,
      "term_months_used": 60
    },
    "mortgage": null
  },
  "offers": {
    "max_loan_amount_range": {
      "best_case": 60700,
      "worst_case": 51000
    },
    "max_loan_amount_used": 54800,
    "estimated_monthly_payment": null,
    "affordability": {
      "payment_max": 1230,
      "payment_buffer": 0,
      "notes": []
    }
  },
  "routing": {
    "lenders_pool": "FALLBACK",
    "recommended_lenders": ["GARANTI", "BRD", "ING"],
    "notes": [
      "FICO 500–580: recomandare bănci mai permisive."
    ]
  },
  "meta": {
    "config_version": "2026-01-05",
    "calculated_at": "2026-01-05T20:58:10+02:00"
  }
}
________________________________________
5) VERIFIED – Ipotecar (ignori FICO, dar aplici reguli întârzieri + IFN)
Dacă depășește regulile de întârzieri → MANUAL_REVIEW sau DECLINED
(Conform cerinței tale: max 4 întârzieri de 30 zile / max 1 de 60 zile / 90+ = review)
{
  "request_id": "uuid",
  "mode": "VERIFIED",
  "loan_type": "IPOTECAR",
  "currency": "RON",
  "status": "MANUAL_REVIEW",
  "decision": {
    "rating": "D",
    "confidence": "HIGH",
    "reasons": [
      {
        "code": "BC_DELAY_RULES",
        "title": "Istoric întârzieri peste limitele acceptate",
        "details": "În ultimii 4 ani există prea multe întârzieri sau o întârziere semnificativă."
      }
    ],
    "risk_flags": [
      {
        "code": "DPD_LIMIT_EXCEEDED",
        "severity": "HIGH",
        "details": "dpd_30_count=6 (max 4) / dpd_60_count=2 (max 1)."
      }
    ]
  },
  "income": {
    "eligible_income_monthly": 6100,
    "source": "ANAF_D112",
    "period_months": 6,
    "anaf": {
      "avg_net_6m": 5900,
      "avg_meal_6m": 400
    }
  },
  "credit_bureau": {
    "fico_score": 620,
    "dpd_last_4y": {
      "dpd_30_count": 6,
      "dpd_60_count": 2,
      "dpd_90plus_count": 0
    },
    "nonbank": {
      "closed_last_4y": 12,
      "active_now": 5
    }
  },
  "dti": {
    "dti_used": 0.4,
    "dti_cap_reason": "STANDARD",
    "existing_monthly_obligations": 1200,
    "max_monthly_payment": 1240
  },
  "rates": {
    "np": null,
    "mortgage": {
      "promo_fixed_3y_min": 4.79,
      "promo_fixed_3y_max": 5.99,
      "ircc_current": 5.68,
      "bank_margin_used": 2.49,
      "underwriting_rate_used": 8.17,
      "term_months_used": 360
    }
  },
  "mortgage_rules": {
    "income_source": "RO",
    "has_owned_home_before": true,
    "down_payment_min_percent": 0.25,
    "down_payment_range_percent": [0.25, 0.25]
  },
  "offers": {
    "max_loan_amount_used": null,
    "estimated_monthly_payment": null,
    "affordability": {
      "payment_max": 1240,
      "payment_buffer": 0,
      "notes": [
        "Necesită analiză manuală (întârzieri/expunere IFN)."
      ]
    }
  },
  "routing": {
    "lenders_pool": "LIMITED",
    "recommended_lenders": [],
    "notes": []
  },
  "meta": {
    "config_version": "2026-01-05",
    "calculated_at": "2026-01-05T20:58:10+02:00"
  }
}
________________________________________
6) Obiecte standard: Reason și RiskFlag (contract stabil)
Reason
{
  "code": "STRING_ENUM",
  "title": "Human readable",
  "details": "Explainability text for UI"
}
RiskFlag
{
  "code": "STRING_ENUM",
  "severity": "LOW|MEDIUM|HIGH",
  "details": "Optional extra info"
}
Coduri recomandate (minim):
•	DTI_STANDARD, DTI_HIGH_INCOME, NP_QUARTERLY_DTI50_ACTIVE
•	FICO_BELOW_STANDARD, FICO_TOO_LOW
•	BC_DELAY_RULES, DPD_LIMIT_EXCEEDED
•	HIGH_IFN_EXPOSURE
•	INSUFFICIENT_INCOME_FOREIGN, DOWNPAYMENT_RULE_APPLIED
________________________________________
7) Ce să fie configurabil din Admin (ca să nu schimbi codul)
În output, meta.config_version reflectă config-ul folosit.
Chei critice:
•	ircc.current, ircc.next, ircc.last_updated
•	mortgage.stress_margin_default (+ margini per bancă, dacă vrei)
•	np.apr_min/max și bucket-urile (ex: 100k–190k etc.)
•	ferestrele np.high_dti_windows (trimestrial)
•	praguri DPD/IFN (30/60/90, active/closed)
________________________________________
Dacă vrei, îți dau și TypeScript types (interface-uri) + un exemplu de OpenAPI schema pentru endpoint-uri:
•	POST /calc/simple
•	POST /calc/verified
•	GET /config/rates-rules (admin)
•	PUT /config/rates-rules (admin)
Spune-mi doar dacă IT-ul vostru e pe Node/TS sau .NET, și ți le scriu în formatul lor.
Perfect — mai jos ai TypeScript types (interfaces) + OpenAPI 3.0 schema pentru cele 4 endpoint-uri, gândite să meargă clean pe Azure (Functions / App Service) și ușor de pus în APIM.
________________________________________
1) TypeScript types (interfaces) – contracts.ts
// contracts.ts

export type Mode = "SIMPLE" | "VERIFIED";
export type LoanType = "NP" | "IPOTECAR";
export type Currency = "RON" | "EUR";
export type Status = "OK" | "MANUAL_REVIEW" | "DECLINED";
export type Confidence = "LOW" | "MEDIUM" | "HIGH";

export type LendersPool = "STANDARD" | "FALLBACK" | "LIMITED" | "NONE";

export type Severity = "LOW" | "MEDIUM" | "HIGH";

export interface Reason {
  code:
    | "DTI_STANDARD"
    | "DTI_HIGH_INCOME"
    | "NP_QUARTERLY_DTI50_ACTIVE"
    | "FICO_BELOW_STANDARD"
    | "FICO_TOO_LOW"
    | "BC_DELAY_RULES"
    | "DPD_LIMIT_EXCEEDED"
    | "HIGH_IFN_EXPOSURE"
    | "INSUFFICIENT_INCOME_FOREIGN"
    | "DOWNPAYMENT_RULE_APPLIED"
    | "DTI_EXCEEDED"
    | "INSUFFICIENT_DATA";
  title: string;
  details?: string;
}

export interface RiskFlag {
  code:
    | "FICO_TOLERANT_ROUTING"
    | "DPD_LIMIT_EXCEEDED"
    | "ANY_90DPD"
    | "HIGH_IFN_EXPOSURE"
    | "DATA_PARSE_WARNING";
  severity: Severity;
  details?: string;
}

/** ---------- Requests ---------- **/

export interface CalcSimpleRequest {
  loan_type: LoanType;
  currency?: Currency; // default RON
  salary_net_user: number; // RON
  meal_tickets_user?: number; // RON
  term_months?: number; // NP default 60; max 60
  desired_amount?: number; // optional, if user wants payment estimate
  // Mortgage extras (optional)
  property_value?: number; // RON
  has_owned_home_before?: boolean;
  income_source?: "RO" | "STRAINATATE";
  // if income_source=STRAINATATE (simple), user may provide EUR as well
  foreign_income_net_eur?: number;
  down_payment_percent_selected?: number; // e.g. 0.25 / 0.30 / 0.35 / 0.40
}

export interface CalcVerifiedRequest {
  loan_type: LoanType;
  currency?: Currency; // default RON
  user_id: string; // used for quarterly promo usage tracking
  // optional loan inputs
  term_months?: number;
  desired_amount?: number;
  property_value?: number;
  has_owned_home_before?: boolean;
  income_source?: "RO" | "STRAINATATE";
  foreign_income_net_eur?: number;

  // report references (IDs in your DB / blob)
  anaf_report_id: string;
  bc_report_id: string;

  // optional overrides if you already extracted server-side and want to pass them (usually not from FE)
  extracted?: {
    anaf_income_avg_net_6m?: number;
    anaf_income_avg_meal_6m?: number;
    bc_fico_score?: number | null;
    bc_existing_monthly_obligations?: number; // sum of scheduled payments
    bc_dpd_last_4y?: {
      dpd_30_count: number;
      dpd_60_count: number;
      dpd_90plus_count: number;
    };
    bc_nonbank?: {
      closed_last_4y: number;
      active_now: number;
    };
  };
}

/** ---------- Response ---------- **/

export interface DecisionBlock {
  rating: "A" | "B" | "C" | "D";
  confidence: Confidence;
  reasons: Reason[];
  risk_flags: RiskFlag[];
}

export interface IncomeBlock {
  eligible_income_monthly: number; // RON equivalent used in calc
  salary_net_monthly?: number | null;
  meal_tickets_monthly?: number | null;
  meal_ticket_weight_used?: number | null;
  source: "USER_DECLARED" | "ANAF_D112";
  period_months?: number | null;

  anaf?: {
    avg_net_6m: number;
    avg_meal_6m: number;
  };
}

export interface DtiBlock {
  dti_used: number; // 0.40 / 0.50 / 0.55 etc.
  dti_cap_reason:
    | "STANDARD"
    | "STANDARD_UNDER_5500"
    | "INCOME_OVER_5500"
    | "INCOME_OVER_6500"
    | "NP_QUARTERLY_DTI50"
    | "REDUCED_DUE_TO_RISK";
  existing_monthly_obligations: number;
  max_monthly_payment: number; // eligible_income*dti - obligations
}

export interface RatesNpBlock {
  apr_min: number;
  apr_max: number;
  apr_used_for_calc: number;
  term_months_used: number; // <=60
  // optional buckets (if you implement tiers)
  apr_buckets?: Array<{
    min_amount: number;
    max_amount: number;
    apr: number;
  }>;
}

export interface RatesMortgageBlock {
  promo_fixed_3y_min: number;
  promo_fixed_3y_max: number;
  ircc_current: number;
  bank_margin_used: number;
  underwriting_rate_used: number; // margin + IRCC
  term_months_used: number; // e.g. 360
}

export interface MortgageRulesBlock {
  income_source: "RO" | "STRAINATATE";
  has_owned_home_before: boolean;
  down_payment_min_percent: number;
  down_payment_range_percent: [number, number];
  foreign_income_min_eur?: number;
}

export interface OffersBlock {
  max_loan_amount_range?: {
    best_case: number; // based on lower APR
    worst_case: number; // based on higher APR / stress
  } | null;

  max_loan_amount_used?: number | null; // chosen based on apr_used_for_calc
  estimated_monthly_payment?: number | null; // if desired_amount provided

  affordability: {
    payment_max: number;
    payment_buffer?: number; // optional
    notes: string[];
  };
}

export interface RoutingBlock {
  lenders_pool: LendersPool;
  recommended_lenders: string[]; // e.g. ["GARANTI","BRD","ING"]
  notes: string[];
}

export interface CreditBureauBlock {
  fico_score?: number | null;
  dpd_last_4y?: {
    dpd_30_count: number;
    dpd_60_count: number;
    dpd_90plus_count: number;
  };
  nonbank?: {
    closed_last_4y: number;
    active_now: number;
  };
}

export interface EligibilityResponse {
  request_id: string; // uuid
  mode: Mode;
  loan_type: LoanType;
  currency: Currency;

  status: Status;
  decision: DecisionBlock;

  income: IncomeBlock;
  dti: DtiBlock;

  rates: {
    np: RatesNpBlock | null;
    mortgage: RatesMortgageBlock | null;
  };

  mortgage_rules?: MortgageRulesBlock | null;

  offers: OffersBlock;

  routing: RoutingBlock;

  // present mainly in VERIFIED
  credit_bureau?: CreditBureauBlock;

  meta: {
    config_version: string;
    calculated_at: string; // ISO
  };
}

/** ---------- Config (Admin) ---------- **/

export interface RatesRulesConfig {
  version: string;

  ircc: {
    current: number; // percent, e.g. 5.68
    next?: number | null;
    source: "manual" | "auto";
    last_updated: string; // ISO
  };

  income: {
    meal_ticket_weight_simple: number; // 0..1
    meal_ticket_weight_verified: number; // 0..1
  };

  np: {
    max_term_months: number; // 60
    apr_min: number; // 7.49
    apr_max: number; // 15.99

    // optional tiers for apr_used_for_calc
    apr_buckets?: Array<{
      min_amount: number;
      max_amount: number;
      apr: number;
    }>;

    dti_standard: number; // 0.40
    dti_high: number; // 0.50
    income_high_dti_min: number; // 5500

    fico_min_standard: number; // 581
    fico_min_high_dti: number; // 601
    fico_min_fallback: number; // 500

    // safest: explicit windows per year
    high_dti_windows: Array<{
      start: string; // ISO date
      end: string; // ISO date
    }>;

    fallback_lenders: string[]; // ["GARANTI","BRD","ING"]
  };

  mortgage: {
    promo_fixed_min: number; // 4.79
    promo_fixed_max: number; // 5.99

    stress_margin_default: number; // 2.49
    term_months_default: number; // 360

    dti_standard: number; // 0.40
    dti_high_income: number; // 0.55
    income_dti_high_min: number; // 6500

    downpayment: {
      ro_first_home: number; // 0.15
      ro_not_first_home: number; // 0.25
      foreign_income_min_eur: number; // 2000
      foreign_min: number; // 0.25
      foreign_max: number; // 0.40
    };

    bc_rules: {
      max_30dpd_last_4y: number; // 4
      max_60dpd_last_4y: number; // 1
      any_90dpd_last_4y: "manual_review" | "decline";
    };
  };

  risk_flags: {
    ifn_closed_4y_gt: number; // 10
    ifn_active_gt: number; // 4
    action: "manual_review" | "reduce_dti";
    reduced_dti_value?: number; // e.g. 0.35
  };
}
________________________________________
2) OpenAPI 3.0 schema (YAML) – openapi.yaml
openapi: 3.0.3
info:
  title: MoneyShop Eligibility API
  version: "1.0.0"
  description: >
    API pentru calculator simplu (fara cont) si calculator verificat (KYC + ANAF + BC),
    plus administrare configuratii dobânzi/reguli.
servers:
  - url: https://api.moneyshop.ro
    description: Production
  - url: https://api-dev.moneyshop.ro
    description: Development

tags:
  - name: calc
  - name: config

components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

  schemas:
    CalcSimpleRequest:
      type: object
      required: [loan_type, salary_net_user]
      properties:
        loan_type:
          type: string
          enum: [NP, IPOTECAR]
        currency:
          type: string
          enum: [RON, EUR]
          default: RON
        salary_net_user:
          type: number
          minimum: 0
        meal_tickets_user:
          type: number
          minimum: 0
        term_months:
          type: integer
          minimum: 1
          maximum: 60
        desired_amount:
          type: number
          minimum: 0
        property_value:
          type: number
          minimum: 0
        has_owned_home_before:
          type: boolean
        income_source:
          type: string
          enum: [RO, STRAINATATE]
        foreign_income_net_eur:
          type: number
          minimum: 0
        down_payment_percent_selected:
          type: number
          minimum: 0
          maximum: 1

    CalcVerifiedRequest:
      type: object
      required: [loan_type, user_id, anaf_report_id, bc_report_id]
      properties:
        loan_type:
          type: string
          enum: [NP, IPOTECAR]
        currency:
          type: string
          enum: [RON, EUR]
          default: RON
        user_id:
          type: string
        term_months:
          type: integer
          minimum: 1
          maximum: 60
        desired_amount:
          type: number
          minimum: 0
        property_value:
          type: number
          minimum: 0
        has_owned_home_before:
          type: boolean
        income_source:
          type: string
          enum: [RO, STRAINATATE]
        foreign_income_net_eur:
          type: number
          minimum: 0
        anaf_report_id:
          type: string
        bc_report_id:
          type: string
        extracted:
          type: object
          additionalProperties: false
          properties:
            anaf_income_avg_net_6m:
              type: number
            anaf_income_avg_meal_6m:
              type: number
            bc_fico_score:
              type: integer
              nullable: true
            bc_existing_monthly_obligations:
              type: number
            bc_dpd_last_4y:
              type: object
              properties:
                dpd_30_count: { type: integer, minimum: 0 }
                dpd_60_count: { type: integer, minimum: 0 }
                dpd_90plus_count: { type: integer, minimum: 0 }
            bc_nonbank:
              type: object
              properties:
                closed_last_4y: { type: integer, minimum: 0 }
                active_now: { type: integer, minimum: 0 }

    Reason:
      type: object
      required: [code, title]
      properties:
        code:
          type: string
          enum:
            - DTI_STANDARD
            - DTI_HIGH_INCOME
            - NP_QUARTERLY_DTI50_ACTIVE
            - FICO_BELOW_STANDARD
            - FICO_TOO_LOW
            - BC_DELAY_RULES
            - DPD_LIMIT_EXCEEDED
            - HIGH_IFN_EXPOSURE
            - INSUFFICIENT_INCOME_FOREIGN
            - DOWNPAYMENT_RULE_APPLIED
            - DTI_EXCEEDED
            - INSUFFICIENT_DATA
        title:
          type: string
        details:
          type: string

    RiskFlag:
      type: object
      required: [code, severity]
      properties:
        code:
          type: string
          enum:
            - FICO_TOLERANT_ROUTING
            - DPD_LIMIT_EXCEEDED
            - ANY_90DPD
            - HIGH_IFN_EXPOSURE
            - DATA_PARSE_WARNING
        severity:
          type: string
          enum: [LOW, MEDIUM, HIGH]
        details:
          type: string

    EligibilityResponse:
      type: object
      required: [request_id, mode, loan_type, currency, status, decision, income, dti, rates, offers, routing, meta]
      properties:
        request_id: { type: string }
        mode: { type: string, enum: [SIMPLE, VERIFIED] }
        loan_type: { type: string, enum: [NP, IPOTECAR] }
        currency: { type: string, enum: [RON, EUR] }
        status: { type: string, enum: [OK, MANUAL_REVIEW, DECLINED] }

        decision:
          type: object
          required: [rating, confidence, reasons, risk_flags]
          properties:
            rating: { type: string, enum: [A, B, C, D] }
            confidence: { type: string, enum: [LOW, MEDIUM, HIGH] }
            reasons:
              type: array
              items: { $ref: "#/components/schemas/Reason" }
            risk_flags:
              type: array
              items: { $ref: "#/components/schemas/RiskFlag" }

        income:
          type: object
          required: [eligible_income_monthly, source]
          properties:
            eligible_income_monthly: { type: number }
            salary_net_monthly: { type: number, nullable: true }
            meal_tickets_monthly: { type: number, nullable: true }
            meal_ticket_weight_used: { type: number, nullable: true }
            source: { type: string, enum: [USER_DECLARED, ANAF_D112] }
            period_months: { type: integer, nullable: true }
            anaf:
              type: object
              properties:
                avg_net_6m: { type: number }
                avg_meal_6m: { type: number }

        dti:
          type: object
          required: [dti_used, dti_cap_reason, existing_monthly_obligations, max_monthly_payment]
          properties:
            dti_used: { type: number }
            dti_cap_reason:
              type: string
              enum:
                - STANDARD
                - STANDARD_UNDER_5500
                - INCOME_OVER_5500
                - INCOME_OVER_6500
                - NP_QUARTERLY_DTI50
                - REDUCED_DUE_TO_RISK
            existing_monthly_obligations: { type: number }
            max_monthly_payment: { type: number }

        rates:
          type: object
          required: [np, mortgage]
          properties:
            np:
              nullable: true
              oneOf:
                - type: "null"
                - type: object
                  required: [apr_min, apr_max, apr_used_for_calc, term_months_used]
                  properties:
                    apr_min: { type: number }
                    apr_max: { type: number }
                    apr_used_for_calc: { type: number }
                    term_months_used: { type: integer }
                    apr_buckets:
                      type: array
                      items:
                        type: object
                        required: [min_amount, max_amount, apr]
                        properties:
                          min_amount: { type: number }
                          max_amount: { type: number }
                          apr: { type: number }
            mortgage:
              nullable: true
              oneOf:
                - type: "null"
                - type: object
                  required: [promo_fixed_3y_min, promo_fixed_3y_max, ircc_current, bank_margin_used, underwriting_rate_used, term_months_used]
                  properties:
                    promo_fixed_3y_min: { type: number }
                    promo_fixed_3y_max: { type: number }
                    ircc_current: { type: number }
                    bank_margin_used: { type: number }
                    underwriting_rate_used: { type: number }
                    term_months_used: { type: integer }

        mortgage_rules:
          nullable: true
          oneOf:
            - type: "null"
            - type: object
              required: [income_source, has_owned_home_before, down_payment_min_percent, down_payment_range_percent]
              properties:
                income_source: { type: string, enum: [RO, STRAINATATE] }
                has_owned_home_before: { type: boolean }
                down_payment_min_percent: { type: number }
                down_payment_range_percent:
                  type: array
                  minItems: 2
                  maxItems: 2
                  items: { type: number }
                foreign_income_min_eur: { type: number }

        offers:
          type: object
          required: [affordability]
          properties:
            max_loan_amount_range:
              nullable: true
              oneOf:
                - type: "null"
                - type: object
                  required: [best_case, worst_case]
                  properties:
                    best_case: { type: number }
                    worst_case: { type: number }
            max_loan_amount_used: { type: number, nullable: true }
            estimated_monthly_payment: { type: number, nullable: true }
            affordability:
              type: object
              required: [payment_max, notes]
              properties:
                payment_max: { type: number }
                payment_buffer: { type: number }
                notes:
                  type: array
                  items: { type: string }

        routing:
          type: object
          required: [lenders_pool, recommended_lenders, notes]
          properties:
            lenders_pool: { type: string, enum: [STANDARD, FALLBACK, LIMITED, NONE] }
            recommended_lenders:
              type: array
              items: { type: string }
            notes:
              type: array
              items: { type: string }

        credit_bureau:
          nullable: true
          oneOf:
            - type: "null"
            - type: object
              properties:
                fico_score: { type: integer, nullable: true }
                dpd_last_4y:
                  type: object
                  properties:
                    dpd_30_count: { type: integer }
                    dpd_60_count: { type: integer }
                    dpd_90plus_count: { type: integer }
                nonbank:
                  type: object
                  properties:
                    closed_last_4y: { type: integer }
                    active_now: { type: integer }

        meta:
          type: object
          required: [config_version, calculated_at]
          properties:
            config_version: { type: string }
            calculated_at: { type: string, format: date-time }

    RatesRulesConfig:
      type: object
      required: [version, ircc, income, np, mortgage, risk_flags]
      properties:
        version: { type: string }
        ircc:
          type: object
          required: [current, source, last_updated]
          properties:
            current: { type: number }
            next: { type: number, nullable: true }
            source: { type: string, enum: [manual, auto] }
            last_updated: { type: string, format: date-time }
        income:
          type: object
          required: [meal_ticket_weight_simple, meal_ticket_weight_verified]
          properties:
            meal_ticket_weight_simple: { type: number }
            meal_ticket_weight_verified: { type: number }
        np:
          type: object
          required:
            - max_term_months
            - apr_min
            - apr_max
            - dti_standard
            - dti_high
            - income_high_dti_min
            - fico_min_standard
            - fico_min_high_dti
            - fico_min_fallback
            - high_dti_windows
            - fallback_lenders
          properties:
            max_term_months: { type: integer }
            apr_min: { type: number }
            apr_max: { type: number }
            apr_buckets:
              type: array
              items:
                type: object
                required: [min_amount, max_amount, apr]
                properties:
                  min_amount: { type: number }
                  max_amount: { type: number }
                  apr: { type: number }
            dti_standard: { type: number }
            dti_high: { type: number }
            income_high_dti_min: { type: number }
            fico_min_standard: { type: integer }
            fico_min_high_dti: { type: integer }
            fico_min_fallback: { type: integer }
            high_dti_windows:
              type: array
              items:
                type: object
                required: [start, end]
                properties:
                  start: { type: string, format: date }
                  end: { type: string, format: date }
            fallback_lenders:
              type: array
              items: { type: string }
        mortgage:
          type: object
          required:
            - promo_fixed_min
            - promo_fixed_max
            - stress_margin_default
            - term_months_default
            - dti_standard
            - dti_high_income
            - income_dti_high_min
            - downpayment
            - bc_rules
          properties:
            promo_fixed_min: { type: number }
            promo_fixed_max: { type: number }
            stress_margin_default: { type: number }
            term_months_default: { type: integer }
            dti_standard: { type: number }
            dti_high_income: { type: number }
            income_dti_high_min: { type: number }
            downpayment:
              type: object
              required:
                - ro_first_home
                - ro_not_first_home
                - foreign_income_min_eur
                - foreign_min
                - foreign_max
              properties:
                ro_first_home: { type: number }
                ro_not_first_home: { type: number }
                foreign_income_min_eur: { type: number }
                foreign_min: { type: number }
                foreign_max: { type: number }
            bc_rules:
              type: object
              required: [max_30dpd_last_4y, max_60dpd_last_4y, any_90dpd_last_4y]
              properties:
                max_30dpd_last_4y: { type: integer }
                max_60dpd_last_4y: { type: integer }
                any_90dpd_last_4y: { type: string, enum: [manual_review, decline] }
        risk_flags:
          type: object
          required: [ifn_closed_4y_gt, ifn_active_gt, action]
          properties:
            ifn_closed_4y_gt: { type: integer }
            ifn_active_gt: { type: integer }
            action: { type: string, enum: [manual_review, reduce_dti] }
            reduced_dti_value: { type: number }

paths:
  /calc/simple:
    post:
      tags: [calc]
      summary: Calculator simplu (fără cont, fără ANAF/BC)
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/CalcSimpleRequest" }
      responses:
        "200":
          description: Eligibility result
          content:
            application/json:
              schema: { $ref: "#/components/schemas/EligibilityResponse" }

  /calc/verified:
    post:
      tags: [calc]
      summary: Calculator avansat (KYC + ANAF + BC)
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/CalcVerifiedRequest" }
      responses:
        "200":
          description: Eligibility result
          content:
            application/json:
              schema: { $ref: "#/components/schemas/EligibilityResponse" }
        "422":
          description: Unprocessable (missing reports / parse error)
          content:
            application/json:
              schema:
                type: object
                properties:
                  error: { type: string }
                  details: { type: string }

  /config/rates-rules:
    get:
      tags: [config]
      summary: Get current rules & rates config (admin)
      security:
        - BearerAuth: []
      responses:
        "200":
          description: Current config
          content:
            application/json:
              schema: { $ref: "#/components/schemas/RatesRulesConfig" }
        "401":
          description: Unauthorized

    put:
      tags: [config]
      summary: Update rules & rates config (admin)
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/RatesRulesConfig" }
      responses:
        "200":
          description: Updated config
          content:
            application/json:
              schema: { $ref: "#/components/schemas/RatesRulesConfig" }
        "400":
          description: Validation error
          content:
            application/json:
              schema:
                type: object
                properties:
                  error: { type: string }
                  field: { type: string }
                  message: { type: string }
        "401":
          description: Unauthorized
________________________________________
3) Recomandare rapidă pentru Azure (implementare)
•	Azure Functions:
o	HttpTrigger pentru /calc/simple și /calc/verified
o	HttpTrigger cu JWT middleware pentru /config/*
•	Config storage:
o	Cosmos DB container config (partition key: id)
o	id = "rates-rules-current" + version pentru audit
•	IRCC update:
o	TimerTrigger daily → dacă source=auto, face update (altfel rămâne manual)
Dacă vrei, îți scriu și un skeleton de Azure Functions în TypeScript (4 handlers + validare JSON + load/save config + exemplu response).
// package.json (minimal)
// {
//   "name": "moneyshop-eligibility-api",
//   "version": "1.0.0",
//   "type": "module",
//   "scripts": {
//     "build": "tsc -p .",
//     "start": "func start",
//     "test": "node --test"
//   },
//   "dependencies": {
//     "@azure/cosmos": "^4.2.0",
//     "@azure/functions": "^4.6.0",
//     "zod": "^3.23.8",
//     "jose": "^5.9.3"
//   },
//   "devDependencies": {
//     "typescript": "^5.5.4"
//   }
// }
// tsconfig.json (minimal)
// {
//   "compilerOptions": {
//     "target": "ES2022",
//     "module": "ES2022",
//     "moduleResolution": "Bundler",
//     "strict": true,
//     "outDir": "dist",
//     "rootDir": "src",
//     "esModuleInterop": true,
//     "skipLibCheck": true
//   },
//   "include": ["src/**/*.ts"]
// }
// src/shared/contracts.ts
export type Mode = "SIMPLE" | "VERIFIED";
export type LoanType = "NP" | "IPOTECAR";
export type Currency = "RON" | "EUR";
export type Status = "OK" | "MANUAL_REVIEW" | "DECLINED";
export type Confidence = "LOW" | "MEDIUM" | "HIGH";
export type LendersPool = "STANDARD" | "FALLBACK" | "LIMITED" | "NONE";
export type Severity = "LOW" | "MEDIUM" | "HIGH";

export interface Reason {
  code:
    | "DTI_STANDARD"
    | "DTI_HIGH_INCOME"
    | "NP_QUARTERLY_DTI50_ACTIVE"
    | "FICO_BELOW_STANDARD"
    | "FICO_TOO_LOW"
    | "BC_DELAY_RULES"
    | "DPD_LIMIT_EXCEEDED"
    | "HIGH_IFN_EXPOSURE"
    | "INSUFFICIENT_INCOME_FOREIGN"
    | "DOWNPAYMENT_RULE_APPLIED"
    | "DTI_EXCEEDED"
    | "INSUFFICIENT_DATA";
  title: string;
  details?: string;
}

export interface RiskFlag {
  code:
    | "FICO_TOLERANT_ROUTING"
    | "DPD_LIMIT_EXCEEDED"
    | "ANY_90DPD"
    | "HIGH_IFN_EXPOSURE"
    | "DATA_PARSE_WARNING";
  severity: Severity;
  details?: string;
}

export interface CalcSimpleRequest {
  loan_type: LoanType;
  currency?: Currency;
  salary_net_user: number;
  meal_tickets_user?: number;
  term_months?: number; // NP <=60
  desired_amount?: number;

  property_value?: number;
  has_owned_home_before?: boolean;
  income_source?: "RO" | "STRAINATATE";
  foreign_income_net_eur?: number;
  down_payment_percent_selected?: number; // 0.25..0.40
}

export interface CalcVerifiedRequest {
  loan_type: LoanType;
  currency?: Currency;
  user_id: string;

  term_months?: number;
  desired_amount?: number;
  property_value?: number;
  has_owned_home_before?: boolean;
  income_source?: "RO" | "STRAINATATE";
  foreign_income_net_eur?: number;

  anaf_report_id: string;
  bc_report_id: string;

  extracted?: {
    anaf_income_avg_net_6m?: number;
    anaf_income_avg_meal_6m?: number;
    bc_fico_score?: number | null;
    bc_existing_monthly_obligations?: number;
    bc_dpd_last_4y?: {
      dpd_30_count: number;
      dpd_60_count: number;
      dpd_90plus_count: number;
    };
    bc_nonbank?: {
      closed_last_4y: number;
      active_now: number;
    };
  };
}

export interface EligibilityResponse {
  request_id: string;
  mode: Mode;
  loan_type: LoanType;
  currency: Currency;
  status: Status;

  decision: {
    rating: "A" | "B" | "C" | "D";
    confidence: Confidence;
    reasons: Reason[];
    risk_flags: RiskFlag[];
  };

  income: {
    eligible_income_monthly: number;
    salary_net_monthly?: number | null;
    meal_tickets_monthly?: number | null;
    meal_ticket_weight_used?: number | null;
    source: "USER_DECLARED" | "ANAF_D112";
    period_months?: number | null;
    anaf?: { avg_net_6m: number; avg_meal_6m: number };
  };

  dti: {
    dti_used: number;
    dti_cap_reason:
      | "STANDARD"
      | "STANDARD_UNDER_5500"
      | "INCOME_OVER_5500"
      | "INCOME_OVER_6500"
      | "NP_QUARTERLY_DTI50"
      | "REDUCED_DUE_TO_RISK";
    existing_monthly_obligations: number;
    max_monthly_payment: number;
  };

  rates: {
    np: null | {
      apr_min: number;
      apr_max: number;
      apr_used_for_calc: number;
      term_months_used: number;
      apr_buckets?: Array<{ min_amount: number; max_amount: number; apr: number }>;
    };
    mortgage: null | {
      promo_fixed_3y_min: number;
      promo_fixed_3y_max: number;
      ircc_current: number;
      bank_margin_used: number;
      underwriting_rate_used: number;
      term_months_used: number;
    };
  };

  mortgage_rules?: null | {
    income_source: "RO" | "STRAINATATE";
    has_owned_home_before: boolean;
    down_payment_min_percent: number;
    down_payment_range_percent: [number, number];
    foreign_income_min_eur?: number;
  };

  offers: {
    max_loan_amount_range?: null | { best_case: number; worst_case: number };
    max_loan_amount_used?: number | null;
    estimated_monthly_payment?: number | null;
    affordability: { payment_max: number; payment_buffer?: number; notes: string[] };
  };

  routing: { lenders_pool: LendersPool; recommended_lenders: string[]; notes: string[] };

  credit_bureau?: {
    fico_score?: number | null;
    dpd_last_4y?: { dpd_30_count: number; dpd_60_count: number; dpd_90plus_count: number };
    nonbank?: { closed_last_4y: number; active_now: number };
  };

  meta: { config_version: string; calculated_at: string };
}

export interface RatesRulesConfig {
  version: string;

  ircc: {
    current: number; // percent e.g. 5.68
    next?: number | null;
    source: "manual" | "auto";
    last_updated: string; // ISO
  };

  income: {
    meal_ticket_weight_simple: number; // 0..1
    meal_ticket_weight_verified: number; // 0..1
  };

  np: {
    max_term_months: number; // 60
    apr_min: number; // 7.49
    apr_max: number; // 15.99
    apr_buckets?: Array<{ min_amount: number; max_amount: number; apr: number }>;

    dti_standard: number; // 0.40
    dti_high: number; // 0.50
    income_high_dti_min: number; // 5500

    fico_min_standard: number; // 581
    fico_min_high_dti: number; // 601
    fico_min_fallback: number; // 500

    high_dti_windows: Array<{ start: string; end: string }>; // ISO date
    fallback_lenders: string[];
  };

  mortgage: {
    promo_fixed_min: number;
    promo_fixed_max: number;

    stress_margin_default: number; // 2.49
    term_months_default: number; // 360

    dti_standard: number; // 0.40
    dti_high_income: number; // 0.55
    income_dti_high_min: number; // 6500

    downpayment: {
      ro_first_home: number; // 0.15
      ro_not_first_home: number; // 0.25
      foreign_income_min_eur: number; // 2000
      foreign_min: number; // 0.25
      foreign_max: number; // 0.40
    };

    bc_rules: {
      max_30dpd_last_4y: number; // 4
      max_60dpd_last_4y: number; // 1
      any_90dpd_last_4y: "manual_review" | "decline";
    };
  };

  risk_flags: {
    ifn_closed_4y_gt: number; // 10
    ifn_active_gt: number; // 4
    action: "manual_review" | "reduce_dti";
    reduced_dti_value?: number; // e.g. 0.35
  };
}
// src/shared/validation.ts
import { z } from "zod";

export const CalcSimpleRequestSchema = z.object({
  loan_type: z.enum(["NP", "IPOTECAR"]),
  currency: z.enum(["RON", "EUR"]).optional(),
  salary_net_user: z.number().nonnegative(),
  meal_tickets_user: z.number().nonnegative().optional(),
  term_months: z.number().int().min(1).max(60).optional(),
  desired_amount: z.number().nonnegative().optional(),
  property_value: z.number().nonnegative().optional(),
  has_owned_home_before: z.boolean().optional(),
  income_source: z.enum(["RO", "STRAINATATE"]).optional(),
  foreign_income_net_eur: z.number().nonnegative().optional(),
  down_payment_percent_selected: z.number().min(0).max(1).optional()
});

export const CalcVerifiedRequestSchema = z.object({
  loan_type: z.enum(["NP", "IPOTECAR"]),
  currency: z.enum(["RON", "EUR"]).optional(),
  user_id: z.string().min(1),

  term_months: z.number().int().min(1).max(60).optional(),
  desired_amount: z.number().nonnegative().optional(),
  property_value: z.number().nonnegative().optional(),
  has_owned_home_before: z.boolean().optional(),
  income_source: z.enum(["RO", "STRAINATATE"]).optional(),
  foreign_income_net_eur: z.number().nonnegative().optional(),

  anaf_report_id: z.string().min(1),
  bc_report_id: z.string().min(1),

  extracted: z
    .object({
      anaf_income_avg_net_6m: z.number().optional(),
      anaf_income_avg_meal_6m: z.number().optional(),
      bc_fico_score: z.number().int().nullable().optional(),
      bc_existing_monthly_obligations: z.number().optional(),
      bc_dpd_last_4y: z
        .object({
          dpd_30_count: z.number().int().min(0),
          dpd_60_count: z.number().int().min(0),
          dpd_90plus_count: z.number().int().min(0)
        })
        .optional(),
      bc_nonbank: z
        .object({
          closed_last_4y: z.number().int().min(0),
          active_now: z.number().int().min(0)
        })
        .optional()
    })
    .optional()
});

export const RatesRulesConfigSchema = z.object({
  version: z.string().min(1),
  ircc: z.object({
    current: z.number(),
    next: z.number().nullable().optional(),
    source: z.enum(["manual", "auto"]),
    last_updated: z.string().min(1)
  }),
  income: z.object({
    meal_ticket_weight_simple: z.number().min(0).max(1),
    meal_ticket_weight_verified: z.number().min(0).max(1)
  }),
  np: z.object({
    max_term_months: z.number().int().min(1).max(60),
    apr_min: z.number().min(0),
    apr_max: z.number().min(0),
    apr_buckets: z
      .array(
        z.object({
          min_amount: z.number().min(0),
          max_amount: z.number().min(0),
          apr: z.number().min(0)
        })
      )
      .optional(),
    dti_standard: z.number().min(0).max(1),
    dti_high: z.number().min(0).max(1),
    income_high_dti_min: z.number().min(0),
    fico_min_standard: z.number().int().min(0).max(850),
    fico_min_high_dti: z.number().int().min(0).max(850),
    fico_min_fallback: z.number().int().min(0).max(850),
    high_dti_windows: z.array(z.object({ start: z.string().min(1), end: z.string().min(1) })),
    fallback_lenders: z.array(z.string().min(1))
  }),
  mortgage: z.object({
    promo_fixed_min: z.number().min(0),
    promo_fixed_max: z.number().min(0),
    stress_margin_default: z.number().min(0),
    term_months_default: z.number().int().min(1).max(600),
    dti_standard: z.number().min(0).max(1),
    dti_high_income: z.number().min(0).max(1),
    income_dti_high_min: z.number().min(0),
    downpayment: z.object({
      ro_first_home: z.number().min(0).max(1),
      ro_not_first_home: z.number().min(0).max(1),
      foreign_income_min_eur: z.number().min(0),
      foreign_min: z.number().min(0).max(1),
      foreign_max: z.number().min(0).max(1)
    }),
    bc_rules: z.object({
      max_30dpd_last_4y: z.number().int().min(0),
      max_60dpd_last_4y: z.number().int().min(0),
      any_90dpd_last_4y: z.enum(["manual_review", "decline"])
    })
  }),
  risk_flags: z.object({
    ifn_closed_4y_gt: z.number().int().min(0),
    ifn_active_gt: z.number().int().min(0),
    action: z.enum(["manual_review", "reduce_dti"]),
    reduced_dti_value: z.number().min(0).max(1).optional()
  })
});
// src/shared/http.ts
import { HttpRequest, HttpResponseInit } from "@azure/functions";

export async function readJson<T = unknown>(req: HttpRequest): Promise<T> {
  const text = await req.text();
  if (!text) throw new Error("EMPTY_BODY");
  return JSON.parse(text) as T;
}

export function json(status: number, body: unknown, headers?: Record<string, string>): HttpResponseInit {
  return {
    status,
    headers: { "content-type": "application/json; charset=utf-8", ...(headers ?? {}) },
    body: JSON.stringify(body)
  };
}

export function badRequest(message: string, details?: unknown): HttpResponseInit {
  return json(400, { error: "BAD_REQUEST", message, details });
}

export function unauthorized(message = "Unauthorized"): HttpResponseInit {
  return json(401, { error: "UNAUTHORIZED", message });
}

export function unprocessable(message: string, details?: unknown): HttpResponseInit {
  return json(422, { error: "UNPROCESSABLE", message, details });
}
// src/shared/auth.ts
import { HttpRequest } from "@azure/functions";
import { jwtVerify, createRemoteJWKSet } from "jose";

/**
 * Minimal JWT verification.
 * In production, set:
 * - AUTH_JWKS_URL (e.g. from Entra ID / Auth0)
 * - AUTH_AUDIENCE
 * - AUTH_ISSUER
 */
const jwksUrl = process.env.AUTH_JWKS_URL;
const audience = process.env.AUTH_AUDIENCE;
const issuer = process.env.AUTH_ISSUER;

export async function requireAdmin(req: HttpRequest): Promise<{ sub: string }> {
  const auth = req.headers.get("authorization") || "";
  const token = auth.startsWith("Bearer ") ? auth.slice("Bearer ".length) : null;
  if (!token) throw new Error("NO_BEARER");

  if (!jwksUrl || !audience || !issuer) {
    // For dev you can disable by setting AUTH_DEV_BYPASS=true
    if (process.env.AUTH_DEV_BYPASS === "true") return { sub: "dev" };
    throw new Error("AUTH_NOT_CONFIGURED");
  }

  const JWKS = createRemoteJWKSet(new URL(jwksUrl));
  const { payload } = await jwtVerify(token, JWKS, { audience, issuer });

  // Minimal role check: expect "roles" contains "admin"
  const roles = (payload.roles as string[] | undefined) ?? [];
  if (!roles.includes("admin")) throw new Error("NOT_ADMIN");

  return { sub: String(payload.sub ?? "") };
}
// src/shared/cosmos.ts
import { CosmosClient, Container } from "@azure/cosmos";
import type { RatesRulesConfig } from "./contracts.js";

const endpoint = process.env.COSMOS_ENDPOINT!;
const key = process.env.COSMOS_KEY!;
const databaseId = process.env.COSMOS_DB!;
const containerId = process.env.COSMOS_CONTAINER_CONFIG!; // e.g. "config"

let container: Container | null = null;

function getContainer(): Container {
  if (!endpoint || !key || !databaseId || !containerId) {
    throw new Error("COSMOS_NOT_CONFIGURED");
  }
  if (!container) {
    const client = new CosmosClient({ endpoint, key });
    container = client.database(databaseId).container(containerId);
  }
  return container;
}

const CONFIG_ID = "rates-rules-current";

export async function loadConfig(): Promise<RatesRulesConfig> {
  const c = getContainer();
  const { resource } = await c.item(CONFIG_ID, CONFIG_ID).read<RatesRulesConfig>();
  if (!resource) throw new Error("CONFIG_NOT_FOUND");
  return resource;
}

export async function saveConfig(cfg: RatesRulesConfig): Promise<RatesRulesConfig> {
  const c = getContainer();
  const doc = { id: CONFIG_ID, pk: CONFIG_ID, ...cfg };
  const { resource } = await c.items.upsert<RatesRulesConfig & { id: string; pk: string }>(doc);
  if (!resource) throw new Error("CONFIG_SAVE_FAILED");
  // strip internal fields before returning if you want
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const { id, pk, ...rest } = resource as any;
  return rest as RatesRulesConfig;
}
// src/shared/math.ts
export function clamp(x: number, a: number, b: number): number {
  return Math.max(a, Math.min(b, x));
}

/** PV from payment (anuitate): PV = Pmt * (1 - (1+r)^(-n)) / r */
export function annuityPV(payment: number, aprPercent: number, nMonths: number): number {
  const apr = aprPercent / 100;
  const r = apr / 12;
  if (r <= 0) return payment * nMonths;
  const pv = payment * (1 - Math.pow(1 + r, -nMonths)) / r;
  return pv;
}

/** Payment from PV: Pmt = PV * r*(1+r)^n / ((1+r)^n - 1) */
export function annuityPayment(principal: number, aprPercent: number, nMonths: number): number {
  const apr = aprPercent / 100;
  const r = apr / 12;
  if (r <= 0) return principal / nMonths;
  const factor = Math.pow(1 + r, nMonths);
  return principal * (r * factor) / (factor - 1);
}

export function roundMoney(x: number): number {
  return Math.round(x);
}
// src/shared/engine.ts
import crypto from "node:crypto";
import type {
  CalcSimpleRequest,
  CalcVerifiedRequest,
  EligibilityResponse,
  RatesRulesConfig
} from "./contracts.js";
import { annuityPV, annuityPayment, roundMoney } from "./math.js";

function nowIso() {
  return new Date().toISOString();
}

function uuid() {
  return crypto.randomUUID();
}

function isTodayInWindows(windows: Array<{ start: string; end: string }>, today = new Date()): boolean {
  // windows in ISO date (YYYY-MM-DD). Interpret as local date boundaries.
  const yyyyMmDd = today.toISOString().slice(0, 10);
  return windows.some((w) => yyyyMmDd >= w.start && yyyyMmDd <= w.end);
}

function pickNpAprForCalc(cfg: RatesRulesConfig, desiredAmount?: number): number {
  // If you have buckets, use them; else mid-point
  if (desiredAmount != null && cfg.np.apr_buckets?.length) {
    const b = cfg.np.apr_buckets.find((x) => desiredAmount >= x.min_amount && desiredAmount <= x.max_amount);
    if (b) return b.apr;
  }
  // default: middle of range
  return (cfg.np.apr_min + cfg.np.apr_max) / 2;
}

export function calcSimple(input: CalcSimpleRequest, cfg: RatesRulesConfig): EligibilityResponse {
  const currency = input.currency ?? "RON";
  const meal = input.meal_tickets_user ?? 0;

  const eligibleIncome =
    input.salary_net_user + meal * cfg.income.meal_ticket_weight_simple;

  const reasons = [];
  const risk_flags = [];

  let dtiUsed = cfg.mortgage.dti_standard; // default 0.40
  let dtiCapReason: EligibilityResponse["dti"]["dti_cap_reason"] = "STANDARD";

  if (input.loan_type === "NP") {
    dtiUsed = eligibleIncome >= cfg.np.income_high_dti_min ? cfg.np.dti_high : cfg.np.dti_standard;
    dtiCapReason = eligibleIncome >= cfg.np.income_high_dti_min ? "INCOME_OVER_5500" : "STANDARD_UNDER_5500";
    reasons.push({
      code: dtiUsed === cfg.np.dti_high ? "DTI_HIGH_INCOME" : "DTI_STANDARD",
      title: dtiUsed === cfg.np.dti_high ? "Grad de îndatorare 50%" : "Grad de îndatorare standard",
      details: dtiUsed === cfg.np.dti_high ? "Venit ≥ 5500 lei (declarație)." : "Venit sub 5500 lei (declarație)."
    });
  } else {
    // mortgage simple: 55% only if >=6500 else 40%
    dtiUsed = eligibleIncome >= cfg.mortgage.income_dti_high_min ? cfg.mortgage.dti_high_income : cfg.mortgage.dti_standard;
    dtiCapReason = eligibleIncome >= cfg.mortgage.income_dti_high_min ? "INCOME_OVER_6500" : "STANDARD";
    reasons.push({
      code: dtiUsed === cfg.mortgage.dti_high_income ? "DTI_HIGH_INCOME" : "DTI_STANDARD",
      title: dtiUsed === cfg.mortgage.dti_high_income ? "Grad de îndatorare 55%" : "Grad de îndatorare standard",
      details: dtiUsed === cfg.mortgage.dti_high_income ? "Venit ≥ 6500 lei (declarație)." : "Venit sub 6500 lei (declarație)."
    });
  }

  const existingObligations = 0;
  const maxPayment = Math.max(0, eligibleIncome * dtiUsed - existingObligations);

  // Build offers
  let ratesNp: EligibilityResponse["rates"]["np"] = null;
  let ratesMortgage: EligibilityResponse["rates"]["mortgage"] = null;
  let mortgageRules: EligibilityResponse["mortgage_rules"] = null;

  let maxAmountUsed: number | null = null;
  let maxRange: { best_case: number; worst_case: number } | null = null;
  let estPayment: number | null = null;

  if (input.loan_type === "NP") {
    const term = Math.min(input.term_months ?? cfg.np.max_term_months, cfg.np.max_term_months);
    const aprUsed = pickNpAprForCalc(cfg, input.desired_amount);

    ratesNp = {
      apr_min: cfg.np.apr_min,
      apr_max: cfg.np.apr_max,
      apr_used_for_calc: aprUsed,
      term_months_used: term,
      apr_buckets: cfg.np.apr_buckets
    };

    const best = annuityPV(maxPayment, cfg.np.apr_min, term);
    const worst = annuityPV(maxPayment, cfg.np.apr_max, term);
    const used = annuityPV(maxPayment, aprUsed, term);

    maxRange = { best_case: roundMoney(best), worst_case: roundMoney(worst) };
    maxAmountUsed = roundMoney(used);

    if (input.desired_amount != null) {
      estPayment = roundMoney(annuityPayment(input.desired_amount, aprUsed, term));
    }
  } else {
    const term = cfg.mortgage.term_months_default;
    const underwriting = cfg.mortgage.stress_margin_default + cfg.ircc.current;

    ratesMortgage = {
      promo_fixed_3y_min: cfg.mortgage.promo_fixed_min,
      promo_fixed_3y_max: cfg.mortgage.promo_fixed_max,
      ircc_current: cfg.ircc.current,
      bank_margin_used: cfg.mortgage.stress_margin_default,
      underwriting_rate_used: underwriting,
      term_months_used: term
    };

    maxAmountUsed = roundMoney(annuityPV(maxPayment, underwriting, term));

    // downpayment rules (simple)
    const incomeSource = input.income_source ?? "RO";
    const hasOwned = input.has_owned_home_before ?? false;
    if (incomeSource === "RO") {
      const dp = hasOwned ? cfg.mortgage.downpayment.ro_not_first_home : cfg.mortgage.downpayment.ro_first_home;
      mortgageRules = {
        income_source: "RO",
        has_owned_home_before: hasOwned,
        down_payment_min_percent: dp,
        down_payment_range_percent: [dp, dp]
      };
    } else {
      mortgageRules = {
        income_source: "STRAINATATE",
        has_owned_home_before: hasOwned,
        down_payment_min_percent: cfg.mortgage.downpayment.foreign_min,
        down_payment_range_percent: [cfg.mortgage.downpayment.foreign_min, cfg.mortgage.downpayment.foreign_max],
        foreign_income_min_eur: cfg.mortgage.downpayment.foreign_income_min_eur
      };
      // optional: flag if foreign income below min
      if ((input.foreign_income_net_eur ?? 0) < cfg.mortgage.downpayment.foreign_income_min_eur) {
        risk_flags.push({
          code: "DATA_PARSE_WARNING",
          severity: "HIGH",
          details: "Venit din străinătate sub minimul configurat."
        });
      }
    }
  }

  return {
    request_id: uuid(),
    mode: "SIMPLE",
    loan_type: input.loan_type,
    currency,
    status: maxPayment > 0 ? "OK" : "DECLINED",
    decision: {
      rating: maxPayment > 0 ? "B" : "D",
      confidence: "MEDIUM",
      reasons: maxPayment > 0 ? reasons : [{ code: "DTI_EXCEEDED", title: "Nu există spațiu de îndatorare", details: "Rata maximă calculată este 0." }],
      risk_flags
    },
    income: {
      eligible_income_monthly: roundMoney(eligibleIncome),
      salary_net_monthly: input.salary_net_user,
      meal_tickets_monthly: meal,
      meal_ticket_weight_used: cfg.income.meal_ticket_weight_simple,
      source: "USER_DECLARED",
      period_months: null
    },
    dti: {
      dti_used: dtiUsed,
      dti_cap_reason: dtiCapReason,
      existing_monthly_obligations: existingObligations,
      max_monthly_payment: roundMoney(maxPayment)
    },
    rates: {
      np: ratesNp,
      mortgage: ratesMortgage
    },
    mortgage_rules: mortgageRules,
    offers: {
      max_loan_amount_range: maxRange,
      max_loan_amount_used: maxAmountUsed,
      estimated_monthly_payment: estPayment,
      affordability: {
        payment_max: roundMoney(maxPayment),
        notes: input.loan_type === "NP" ? ["Rezultat orientativ (fără ANAF/BC)."] : ["Încadrare conservator pe marjă + IRCC."]
      }
    },
    routing: {
      lenders_pool: "STANDARD",
      recommended_lenders: [],
      notes: []
    },
    meta: {
      config_version: cfg.version,
      calculated_at: nowIso()
    }
  };
}

export function calcVerified(input: CalcVerifiedRequest, cfg: RatesRulesConfig): EligibilityResponse {
  const currency = input.currency ?? "RON";

  // For skeleton: we use extracted values; in production you parse ANAF/BC by report_id.
  const avgNet = input.extracted?.anaf_income_avg_net_6m ?? 0;
  const avgMeal = input.extracted?.anaf_income_avg_meal_6m ?? 0;
  const eligibleIncome = avgNet + avgMeal * cfg.income.meal_ticket_weight_verified;

  const fico = input.extracted?.bc_fico_score ?? null;
  const obligations = input.extracted?.bc_existing_monthly_obligations ?? 0;

  const dpd = input.extracted?.bc_dpd_last_4y ?? { dpd_30_count: 0, dpd_60_count: 0, dpd_90plus_count: 0 };
  const nonbank = input.extracted?.bc_nonbank ?? { closed_last_4y: 0, active_now: 0 };

  const reasons: any[] = [];
  const risk_flags: any[] = [];

  // IFN exposure flag
  const ifnTooHigh = nonbank.closed_last_4y > cfg.risk_flags.ifn_closed_4y_gt && nonbank.active_now > cfg.risk_flags.ifn_active_gt;
  if (ifnTooHigh) {
    risk_flags.push({ code: "HIGH_IFN_EXPOSURE", severity: "HIGH", details: `closed=${nonbank.closed_last_4y}, active=${nonbank.active_now}` });
  }

  // Mortgage BC delay rules (ignore fico)
  if (input.loan_type === "IPOTECAR") {
    const over30 = dpd.dpd_30_count > cfg.mortgage.bc_rules.max_30dpd_last_4y;
    const over60 = dpd.dpd_60_count > cfg.mortgage.bc_rules.max_60dpd_last_4y;
    const any90 = dpd.dpd_90plus_count > 0;

    if (over30 || over60 || any90) {
      risk_flags.push({ code: "DPD_LIMIT_EXCEEDED", severity: "HIGH", details: `30=${dpd.dpd_30_count}, 60=${dpd.dpd_60_count}, 90+=${dpd.dpd_90plus_count}` });
      reasons.push({ code: "BC_DELAY_RULES", title: "Istoric întârzieri peste limite", details: "Necesită analiză manuală." });

      return {
        request_id: uuid(),
        mode: "VERIFIED",
        loan_type: input.loan_type,
        currency,
        status: "MANUAL_REVIEW",
        decision: { rating: "D", confidence: "HIGH", reasons, risk_flags },
        income: {
          eligible_income_monthly: roundMoney(eligibleIncome),
          salary_net_monthly: null,
          meal_tickets_monthly: null,
          meal_ticket_weight_used: cfg.income.meal_ticket_weight_verified,
          source: "ANAF_D112",
          period_months: 6,
          anaf: { avg_net_6m: avgNet, avg_meal_6m: avgMeal }
        },
        dti: {
          dti_used: cfg.mortgage.dti_standard,
          dti_cap_reason: "STANDARD",
          existing_monthly_obligations: obligations,
          max_monthly_payment: roundMoney(Math.max(0, eligibleIncome * cfg.mortgage.dti_standard - obligations))
        },
        rates: { np: null, mortgage: null },
        offers: {
          max_loan_amount_used: null,
          estimated_monthly_payment: null,
          affordability: { payment_max: roundMoney(Math.max(0, eligibleIncome * cfg.mortgage.dti_standard - obligations)), notes: ["Necesită analiză manuală (BC)."] }
        },
        routing: { lenders_pool: "LIMITED", recommended_lenders: [], notes: [] },
        credit_bureau: { fico_score: fico, dpd_last_4y: dpd, nonbank },
        meta: { config_version: cfg.version, calculated_at: nowIso() }
      };
    }
  }

  // Determine DTI
  let dtiUsed = cfg.np.dti_standard;
  let dtiCapReason: EligibilityResponse["dti"]["dti_cap_reason"] = "STANDARD";
  let lendersPool: EligibilityResponse["routing"]["lenders_pool"] = "STANDARD";
  let recommended: string[] = [];

  if (input.loan_type === "NP") {
    if (fico != null && fico < cfg.np.fico_min_fallback) {
      return {
        request_id: uuid(),
        mode: "VERIFIED",
        loan_type: "NP",
        currency,
        status: "MANUAL_REVIEW",
        decision: {
          rating: "D",
          confidence: "HIGH",
          reasons: [{ code: "FICO_TOO_LOW", title: "FICO prea mic", details: `FICO=${fico}` }],
          risk_flags
        },
        income: {
          eligible_income_monthly: roundMoney(eligibleIncome),
          salary_net_monthly: null,
          meal_tickets_monthly: null,
          meal_ticket_weight_used: cfg.income.meal_ticket_weight_verified,
          source: "ANAF_D112",
          period_months: 6,
          anaf: { avg_net_6m: avgNet, avg_meal_6m: avgMeal }
        },
        dti: {
          dti_used: cfg.np.dti_standard,
          dti_cap_reason: "STANDARD",
          existing_monthly_obligations: obligations,
          max_monthly_payment: roundMoney(Math.max(0, eligibleIncome * cfg.np.dti_standard - obligations))
        },
        rates: { np: null, mortgage: null },
        offers: {
          max_loan_amount_used: null,
          estimated_monthly_payment: null,
          affordability: { payment_max: roundMoney(Math.max(0, eligibleIncome * cfg.np.dti_standard - obligations)), notes: ["Necesită analiză manuală (FICO)."] }
        },
        routing: { lenders_pool: "LIMITED", recommended_lenders: [], notes: [] },
        credit_bureau: { fico_score: fico, dpd_last_4y: dpd, nonbank },
        meta: { config_version: cfg.version, calculated_at: nowIso() }
      };
    }

    // Quarterly 50% (NP)
    const eligibleForQuarterly =
      eligibleIncome >= cfg.np.income_high_dti_min &&
      fico != null &&
      fico >= cfg.np.fico_min_high_dti &&
      isTodayInWindows(cfg.np.high_dti_windows);

    if (eligibleForQuarterly) {
      dtiUsed = cfg.np.dti_high;
      dtiCapReason = "NP_QUARTERLY_DTI50";
      reasons.push({ code: "NP_QUARTERLY_DTI50_ACTIVE", title: "Fereastră trimestrială DTI 50%", details: "Se aplică în fereastra configurată." });
    } else {
      dtiUsed = cfg.np.dti_standard;
      dtiCapReason = "STANDARD";

      // FICO routing
      if (fico != null && fico < cfg.np.fico_min_standard) {
        lendersPool = "FALLBACK";
        recommended = cfg.np.fallback_lenders;
        risk_flags.push({ code: "FICO_TOLERANT_ROUTING", severity: "MEDIUM", details: `FICO=${fico}` });
        reasons.push({ code: "FICO_BELOW_STANDARD", title: "FICO sub pragul standard", details: "Încadrare posibilă la bănci tolerante pe FICO." });
      } else {
        reasons.push({ code: "DTI_STANDARD", title: "Grad de îndatorare standard", details: "Încadrarea este calculată la 40%." });
      }
    }
  } else {
    // Mortgage verified: ignore fico, but DTI based on income threshold
    dtiUsed = eligibleIncome >= cfg.mortgage.income_dti_high_min ? cfg.mortgage.dti_high_income : cfg.mortgage.dti_standard;
    dtiCapReason = eligibleIncome >= cfg.mortgage.income_dti_high_min ? "INCOME_OVER_6500" : "STANDARD";
    reasons.push({
      code: dtiUsed === cfg.mortgage.dti_high_income ? "DTI_HIGH_INCOME" : "DTI_STANDARD",
      title: dtiUsed === cfg.mortgage.dti_high_income ? "Grad de îndatorare 55%" : "Grad de îndatorare standard"
    });
  }

  // Optional: reduce DTI if IFN too high
  if (ifnTooHigh && cfg.risk_flags.action === "reduce_dti") {
    const reduced = cfg.risk_flags.reduced_dti_value ?? 0.35;
    dtiUsed = Math.min(dtiUsed, reduced);
    dtiCapReason = "REDUCED_DUE_TO_RISK";
    reasons.push({ code: "HIGH_IFN_EXPOSURE", title: "Expunere IFN ridicată", details: "DTI redus automat conform regulilor." });
  } else if (ifnTooHigh && cfg.risk_flags.action === "manual_review") {
    return {
      request_id: uuid(),
      mode: "VERIFIED",
      loan_type: input.loan_type,
      currency,
      status: "MANUAL_REVIEW",
      decision: {
        rating: "D",
        confidence: "HIGH",
        reasons: [{ code: "HIGH_IFN_EXPOSURE", title: "Expunere IFN ridicată", details: "Necesită analiză manuală." }],
        risk_flags
      },
      income: {
        eligible_income_monthly: roundMoney(eligibleIncome),
        salary_net_monthly: null,
        meal_tickets_monthly: null,
        meal_ticket_weight_used: cfg.income.meal_ticket_weight_verified,
        source: "ANAF_D112",
        period_months: 6,
        anaf: { avg_net_6m: avgNet, avg_meal_6m: avgMeal }
      },
      dti: {
        dti_used: dtiUsed,
        dti_cap_reason,
        existing_monthly_obligations: obligations,
        max_monthly_payment: roundMoney(Math.max(0, eligibleIncome * dtiUsed - obligations))
      },
      rates: { np: null, mortgage: null },
      offers: {
        max_loan_amount_used: null,
        estimated_monthly_payment: null,
        affordability: { payment_max: roundMoney(Math.max(0, eligibleIncome * dtiUsed - obligations)), notes: ["Necesită analiză manuală (IFN)."] }
      },
      routing: { lenders_pool: "LIMITED", recommended_lenders: [], notes: [] },
      credit_bureau: { fico_score: fico, dpd_last_4y: dpd, nonbank },
      meta: { config_version: cfg.version, calculated_at: nowIso() }
    };
  }

  const maxPayment = Math.max(0, eligibleIncome * dtiUsed - obligations);

  // Build rates & offers
  let ratesNp: EligibilityResponse["rates"]["np"] = null;
  let ratesMortgage: EligibilityResponse["rates"]["mortgage"] = null;
  let mortgageRules: EligibilityResponse["mortgage_rules"] = null;

  let maxAmountUsed: number | null = null;
  let maxRange: { best_case: number; worst_case: number } | null = null;
  let estPayment: number | null = null;

  if (input.loan_type === "NP") {
    const term = Math.min(input.term_months ?? cfg.np.max_term_months, cfg.np.max_term_months);
    const aprUsed = pickNpAprForCalc(cfg, input.desired_amount);

    ratesNp = {
      apr_min: cfg.np.apr_min,
      apr_max: cfg.np.apr_max,
      apr_used_for_calc: aprUsed,
      term_months_used: term,
      apr_buckets: cfg.np.apr_buckets
    };

    const best = annuityPV(maxPayment, cfg.np.apr_min, term);
    const worst = annuityPV(maxPayment, cfg.np.apr_max, term);
    const used = annuityPV(maxPayment, aprUsed, term);

    maxRange = { best_case: roundMoney(best), worst_case: roundMoney(worst) };
    maxAmountUsed = roundMoney(used);

    if (input.desired_amount != null) {
      estPayment = roundMoney(annuityPayment(input.desired_amount, aprUsed, term));
    }
  } else {
    const term = cfg.mortgage.term_months_default;
    const underwriting = cfg.mortgage.stress_margin_default + cfg.ircc.current;

    ratesMortgage = {
      promo_fixed_3y_min: cfg.mortgage.promo_fixed_min,
      promo_fixed_3y_max: cfg.mortgage.promo_fixed_max,
      ircc_current: cfg.ircc.current,
      bank_margin_used: cfg.mortgage.stress_margin_default,
      underwriting_rate_used: underwriting,
      term_months_used: term
    };

    maxAmountUsed = roundMoney(annuityPV(maxPayment, underwriting, term));

    const incomeSource = input.income_source ?? "RO";
    const hasOwned = input.has_owned_home_before ?? false;

    if (incomeSource === "RO") {
      const dp = hasOwned ? cfg.mortgage.downpayment.ro_not_first_home : cfg.mortgage.downpayment.ro_first_home;
      mortgageRules = {
        income_source: "RO",
        has_owned_home_before: hasOwned,
        down_payment_min_percent: dp,
        down_payment_range_percent: [dp, dp]
      };
    } else {
      mortgageRules = {
        income_source: "STRAINATATE",
        has_owned_home_before: hasOwned,
        down_payment_min_percent: cfg.mortgage.downpayment.foreign_min,
        down_payment_range_percent: [cfg.mortgage.downpayment.foreign_min, cfg.mortgage.downpayment.foreign_max],
        foreign_income_min_eur: cfg.mortgage.downpayment.foreign_income_min_eur
      };
      if ((input.foreign_income_net_eur ?? 0) < cfg.mortgage.downpayment.foreign_income_min_eur) {
        reasons.push({ code: "INSUFFICIENT_INCOME_FOREIGN", title: "Venit din străinătate sub minim", details: `Min EUR=${cfg.mortgage.downpayment.foreign_income_min_eur}` });
        return {
          request_id: uuid(),
          mode: "VERIFIED",
          loan_type: input.loan_type,
          currency,
          status: "MANUAL_REVIEW",
          decision: { rating: "D", confidence: "HIGH", reasons, risk_flags },
          income: {
            eligible_income_monthly: roundMoney(eligibleIncome),
            salary_net_monthly: null,
            meal_tickets_monthly: null,
            meal_ticket_weight_used: cfg.income.meal_ticket_weight_verified,
            source: "ANAF_D112",
            period_months: 6,
            anaf: { avg_net_6m: avgNet, avg_meal_6m: avgMeal }
          },
          dti: {
            dti_used: dtiUsed,
            dti_cap_reason,
            existing_monthly_obligations: obligations,
            max_monthly_payment: roundMoney(maxPayment)
          },
          rates: { np: null, mortgage: ratesMortgage },
          mortgage_rules: mortgageRules,
          offers: {
            max_loan_amount_used: null,
            estimated_monthly_payment: null,
            affordability: { payment_max: roundMoney(maxPayment), notes: ["Necesită verificare suplimentară (venit străinătate)."] }
          },
          routing: { lenders_pool: "LIMITED", recommended_lenders: [], notes: [] },
          credit_bureau: { fico_score: fico, dpd_last_4y: dpd, nonbank },
          meta: { config_version: cfg.version, calculated_at: nowIso() }
        };
      }
    }
  }

  return {
    request_id: uuid(),
    mode: "VERIFIED",
    loan_type: input.loan_type,
    currency,
    status: maxPayment > 0 ? "OK" : "DECLINED",
    decision: {
      rating: maxPayment > 0 ? "B" : "D",
      confidence: "HIGH",
      reasons: maxPayment > 0 ? reasons : [{ code: "DTI_EXCEEDED", title: "Nu există spațiu de îndatorare", details: "Obligațiile curente consumă plafonul." }],
      risk_flags
    },
    income: {
      eligible_income_monthly: roundMoney(eligibleIncome),
      salary_net_monthly: null,
      meal_tickets_monthly: null,
      meal_ticket_weight_used: cfg.income.meal_ticket_weight_verified,
      source: "ANAF_D112",
      period_months: 6,
      anaf: { avg_net_6m: avgNet, avg_meal_6m: avgMeal }
    },
    dti: {
      dti_used: dtiUsed,
      dti_cap_reason,
      existing_monthly_obligations: obligations,
      max_monthly_payment: roundMoney(maxPayment)
    },
    rates: { np: ratesNp, mortgage: ratesMortgage },
    mortgage_rules: mortgageRules,
    offers: {
      max_loan_amount_range: maxRange,
      max_loan_amount_used: maxAmountUsed,
      estimated_monthly_payment: estPayment,
      affordability: { payment_max: roundMoney(maxPayment), notes: [] }
    },
    routing: {
      lenders_pool: lendersPool,
      recommended_lenders: recommended,
      notes: lendersPool === "FALLBACK" ? ["Routing către bănci tolerante pe FICO."] : []
    },
    credit_bureau: { fico_score: fico, dpd_last_4y: dpd, nonbank },
    meta: { config_version: cfg.version, calculated_at: nowIso() }
  };
}
// src/functions/calcSimple.ts
import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";
import { readJson, badRequest, json } from "../shared/http.js";
import { CalcSimpleRequestSchema } from "../shared/validation.js";
import { loadConfig } from "../shared/cosmos.js";
import { calcSimple } from "../shared/engine.js";

export async function handler(req: HttpRequest, ctx: InvocationContext): Promise<HttpResponseInit> {
  try {
    const body = await readJson(req);
    const parsed = CalcSimpleRequestSchema.safeParse(body);
    if (!parsed.success) return badRequest("Invalid request", parsed.error.flatten());

    const cfg = await loadConfig();
    const result = calcSimple(parsed.data, cfg);
    return json(200, result);
  } catch (e: any) {
    ctx.error(e);
    return badRequest("Failed to process request", { code: e?.message ?? "UNKNOWN" });
  }
}

app.http("calcSimple", {
  methods: ["POST"],
  authLevel: "anonymous",
  route: "calc/simple",
  handler
});
// src/functions/calcVerified.ts
import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";
import { readJson, badRequest, unprocessable, json } from "../shared/http.js";
import { CalcVerifiedRequestSchema } from "../shared/validation.js";
import { loadConfig } from "../shared/cosmos.js";
import { calcVerified } from "../shared/engine.js";

export async function handler(req: HttpRequest, ctx: InvocationContext): Promise<HttpResponseInit> {
  try {
    const body = await readJson(req);
    const parsed = CalcVerifiedRequestSchema.safeParse(body);
    if (!parsed.success) return badRequest("Invalid request", parsed.error.flatten());

    const cfg = await loadConfig();

    // Skeleton behavior: requires extracted.* to exist (until you implement parsers by report_id)
    const hasExtracted = !!parsed.data.extracted;
    if (!hasExtracted) {
      return unprocessable("Reports not parsed yet", {
        hint: "Provide extracted fields for now; later implement ANAF/BC parsers using anaf_report_id/bc_report_id."
      });
    }

    const result = calcVerified(parsed.data, cfg);
    return json(200, result);
  } catch (e: any) {
    ctx.error(e);
    return badRequest("Failed to process request", { code: e?.message ?? "UNKNOWN" });
  }
}

app.http("calcVerified", {
  methods: ["POST"],
  authLevel: "anonymous",
  route: "calc/verified",
  handler
});
// src/functions/getConfig.ts
import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";
import { json, unauthorized, badRequest } from "../shared/http.js";
import { loadConfig } from "../shared/cosmos.js";
import { requireAdmin } from "../shared/auth.js";

export async function handler(req: HttpRequest, ctx: InvocationContext): Promise<HttpResponseInit> {
  try {
    try {
      await requireAdmin(req);
    } catch (e: any) {
      ctx.warn("Admin auth failed", e?.message);
      return unauthorized();
    }

    const cfg = await loadConfig();
    return json(200, cfg);
  } catch (e: any) {
    ctx.error(e);
    return badRequest("Failed to load config", { code: e?.message ?? "UNKNOWN" });
  }
}

app.http("getRatesRulesConfig", {
  methods: ["GET"],
  authLevel: "anonymous",
  route: "config/rates-rules",
  handler
});
// src/functions/putConfig.ts
import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";
import { readJson, badRequest, unauthorized, json } from "../shared/http.js";
import { requireAdmin } from "../shared/auth.js";
import { RatesRulesConfigSchema } from "../shared/validation.js";
import { saveConfig } from "../shared/cosmos.js";

export async function handler(req: HttpRequest, ctx: InvocationContext): Promise<HttpResponseInit> {
  try {
    try {
      await requireAdmin(req);
    } catch (e: any) {
      ctx.warn("Admin auth failed", e?.message);
      return unauthorized();
    }

    const body = await readJson(req);
    const parsed = RatesRulesConfigSchema.safeParse(body);
    if (!parsed.success) return badRequest("Invalid config payload", parsed.error.flatten());

    const saved = await saveConfig(parsed.data);
    return json(200, saved);
  } catch (e: any) {
    ctx.error(e);
    return badRequest("Failed to save config", { code: e?.message ?? "UNKNOWN" });
  }
}

app.http("putRatesRulesConfig", {
  methods: ["PUT"],
  authLevel: "anonymous",
  route: "config/rates-rules",
  handler
});
// src/index.ts
// Azure Functions v4 will load registrations via importing this file as entrypoint.
import "./functions/calcSimple.js";
import "./functions/calcVerified.js";
import "./functions/getConfig.js";
import "./functions/putConfig.js";
# local.settings.json (dev only)
# {
#   "IsEncrypted": false,
#   "Values": {
#     "AzureWebJobsStorage": "UseDevelopmentStorage=true",
#     "FUNCTIONS_WORKER_RUNTIME": "node",
#     "COSMOS_ENDPOINT": "https://<account>.documents.azure.com:443/",
#     "COSMOS_KEY": "<key>",
#     "COSMOS_DB": "moneyshop",
#     "COSMOS_CONTAINER_CONFIG": "config",
#     "AUTH_DEV_BYPASS": "true"
#   }
# }
________________________________________
Ce face skeleton-ul acum (clar pentru IT)
•	/calc/simple → calculează doar pe venit declarat + config (DTI/IRCC/marjă/etc.)
•	/calc/verified → momentan cere extracted în request (până implementați parsarea ANAF/BC pe report_id)
•	/config/rates-rules GET/PUT → config versioned în Cosmos (doc rates-rules-current)
•	Validare strictă cu zod
•	Admin auth: JWT via JWKS (sau bypass în dev)
Dacă vrei, îți dau și:
•	un Dockerfile + pipeline GitHub Actions pentru deploy pe Azure Functions,
•	plus un “parser stub” care citește fișierele din Azure Blob Storage după anaf_report_id/bc_report_id și întoarce extracted.
Mai jos ai tot pachetul: Dockerfile + .dockerignore + GitHub Actions pipeline (build → push în ACR → deploy container pe Azure Function App) + parser stub care citește PDF-urile din Azure Blob Storage după anaf_report_id / bc_report_id și întoarce extracted.
Notă: Parser-ul e stub (MVP) – extrage ce poate din textul PDF. Pentru rapoarte scanate/imagine, va trebui OCR (alt modul). Dar ca “ready to wire” e bun: download → parse text → regex → extracted.
________________________________________
1) Dockerfile (Azure Functions Node 18) + .dockerignore
Dockerfile
# Azure Functions base image (Node 18)
FROM mcr.microsoft.com/azure-functions/node:4-node18

# Functions expects /home/site/wwwroot
ENV AzureWebJobsScriptRoot=/home/site/wwwroot \
    AzureFunctionsJobHost__Logging__Console__IsEnabled=true

WORKDIR /home/site/wwwroot

# Copy package files first for caching
COPY package.json package-lock.json* ./

RUN npm ci --omit=dev

# Copy source
COPY . .

# Build TS -> dist
RUN npm run build

# Azure Functions host looks for function entrypoints; for v4 node, your compiled JS should be referenced
# If you use "main" or "type": "module", ensure dist paths are correct.
.dockerignore
node_modules
dist
.git
.gitignore
README.md
local.settings.json
*.log
coverage
________________________________________
2) GitHub Actions pipeline (ACR → Azure Function App Container)
Cerințe în Azure
•	Function App pe Premium/Elastic Premium sau plan care suportă custom container
•	ACR creat
•	Service Principal / Managed Identity cu drepturi:
o	AcrPush pe ACR
o	Contributor (sau minim necesar) pe Function App / Resource Group
Secrets / Variables în GitHub
Setează în GitHub → Settings → Secrets and variables → Actions:
•	AZURE_CLIENT_ID
•	AZURE_TENANT_ID
•	AZURE_SUBSCRIPTION_ID
•	AZURE_RESOURCE_GROUP
•	AZURE_FUNCTIONAPP_NAME
•	ACR_NAME (ex: moneyshopacr)
•	ACR_LOGIN_SERVER (ex: moneyshopacr.azurecr.io)
.github/workflows/deploy-function-container.yml
name: Deploy Azure Functions (Container)

on:
  push:
    branches: [ "main" ]

permissions:
  id-token: write
  contents: read

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install (dev deps for build)
        run: npm ci

      - name: Build
        run: npm run build

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: ACR Login
        run: az acr login --name "${{ secrets.ACR_NAME }}"

      - name: Build & Push Docker image
        run: |
          IMAGE="${{ secrets.ACR_LOGIN_SERVER }}/${{ secrets.AZURE_FUNCTIONAPP_NAME }}:${{ github.sha }}"
          docker build -t "$IMAGE" .
          docker push "$IMAGE"
          echo "IMAGE=$IMAGE" >> $GITHUB_ENV

      - name: Deploy container to Function App
        run: |
          az functionapp config container set \
            --name "${{ secrets.AZURE_FUNCTIONAPP_NAME }}" \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --docker-custom-image-name "$IMAGE" \
            --docker-registry-server-url "https://${{ secrets.ACR_LOGIN_SERVER }}"

      - name: Restart Function App
        run: |
          az functionapp restart \
            --name "${{ secrets.AZURE_FUNCTIONAPP_NAME }}" \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}"
________________________________________
3) Parser stub: Azure Blob Storage → extracted
Dependențe noi (în package.json)
Adaugă:
•	@azure/storage-blob
•	pdf-parse
{
  "dependencies": {
    "@azure/storage-blob": "^12.25.0",
    "pdf-parse": "^1.1.1"
  }
}
________________________________________
4) Storage helper + Parser stub (MVP)
Varianta recomandată de naming
•	Container: reports
•	Blob name:
o	ANAF: anaf/{anaf_report_id}.pdf
o	BC: bc/{bc_report_id}.pdf
Env vars
•	BLOB_CONNECTION_STRING sau (mai enterprise):
o	BLOB_ACCOUNT_URL (ex: https://<account>.blob.core.windows.net)
o	BLOB_SAS_TOKEN (sau identity via DefaultAzureCredential — putem adăuga ulterior)
•	BLOB_CONTAINER=reports
________________________________________
src/parsers/blobClient.ts
import { BlobServiceClient } from "@azure/storage-blob";

const conn = process.env.BLOB_CONNECTION_STRING;
const accountUrl = process.env.BLOB_ACCOUNT_URL;
const sas = process.env.BLOB_SAS_TOKEN;

export function getBlobServiceClient(): BlobServiceClient {
  if (conn) return BlobServiceClient.fromConnectionString(conn);

  if (accountUrl && sas) {
    const url = `${accountUrl}?${sas}`;
    return new BlobServiceClient(url);
  }

  throw new Error("BLOB_NOT_CONFIGURED");
}

export async function downloadBlobToBuffer(containerName: string, blobName: string): Promise<Buffer> {
  const svc = getBlobServiceClient();
  const container = svc.getContainerClient(containerName);
  const blob = container.getBlobClient(blobName);
  const resp = await blob.download();

  const chunks: Buffer[] = [];
  const stream = resp.readableStreamBody;
  if (!stream) throw new Error("BLOB_EMPTY_STREAM");

  for await (const chunk of stream) {
    chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
  }
  return Buffer.concat(chunks);
}
________________________________________
src/parsers/pdfText.ts
import pdf from "pdf-parse";

export async function pdfToText(buf: Buffer): Promise<string> {
  const data = await pdf(buf);
  // normalize whitespace for regex
  return (data.text || "").replace(/\r/g, "").replace(/[ \t]+/g, " ").trim();
}
________________________________________
src/parsers/extractors.ts
export interface ExtractedPayload {
  anaf_income_avg_net_6m?: number;
  anaf_income_avg_meal_6m?: number;

  bc_fico_score?: number | null;
  bc_existing_monthly_obligations?: number;

  bc_dpd_last_4y?: {
    dpd_30_count: number;
    dpd_60_count: number;
    dpd_90plus_count: number;
  };

  bc_nonbank?: {
    closed_last_4y: number;
    active_now: number;
  };

  warnings?: string[];
}

/**
 * Very lightweight heuristics for ANAF D112.
 * Assumption: the PDF text includes repeated monthly lines with "Suma incasata" and optionally tichete.
 * If PDF is scanned, this will fail (warnings).
 */
export function extractFromAnafText(text: string): ExtractedPayload {
  const warnings: string[] = [];

  // Try to capture net paid amounts (RON). Many ANAF exports show numbers with separators.
  // We'll capture candidates near "Suma incasata" occurrences.
  const netMatches: number[] = [];
  const mealMatches: number[] = [];

  const lines = text.split("\n");
  for (const line of lines) {
    const l = line.toLowerCase();

    if (l.includes("suma incasata")) {
      const nums = pickNumbersFromLine(line);
      // heuristic: last number in that line is often the value
      if (nums.length) netMatches.push(nums[nums.length - 1]);
    }

    if (l.includes("tichete") || l.includes("tichete de masa") || l.includes("contravaloare tichete")) {
      const nums = pickNumbersFromLine(line);
      if (nums.length) mealMatches.push(nums[nums.length - 1]);
    }
  }

  if (netMatches.length < 3) warnings.push("ANAF_PARSE_WEAK: too few net matches");
  const avgNet6 = avgLastN(netMatches, 6);
  const avgMeal6 = avgLastN(mealMatches, 6);

  return {
    anaf_income_avg_net_6m: avgNet6 ?? 0,
    anaf_income_avg_meal_6m: avgMeal6 ?? 0,
    warnings
  };
}

/**
 * Lightweight BC extraction.
 * - tries to find a FICO score as 3-digit number near 'FICO' or 'scor'
 * - tries to find monthly obligations sum (hard in text-only) => returns 0 for stub unless you implement account parsing
 * - tries to find delay category counts via keywords '+30' '+60' '+90'
 */
export function extractFromBcText(text: string): ExtractedPayload {
  const warnings: string[] = [];

  // FICO
  let fico: number | null = null;
  const ficoRe = /fico[^0-9]{0,20}(\d{3})/i;
  const m1 = text.match(ficoRe);
  if (m1) fico = clampInt(parseInt(m1[1], 10), 300, 850);

  if (fico == null) {
    // fallback: "Scor" near 3 digits
    const scoreRe = /scor[^0-9]{0,20}(\d{3})/i;
    const m2 = text.match(scoreRe);
    if (m2) fico = clampInt(parseInt(m2[1], 10), 300, 850);
  }

  if (fico == null) warnings.push("BC_PARSE_WEAK: FICO not found");

  // DPD counts stub:
  // If your BC text includes explicit categories like "Categorie 1" etc. you'll replace this with real parsing.
  const dpd30 = countOccurrences(text, "+30") + countOccurrences(text, "30 zile") + countOccurrences(text, "categorie 1");
  const dpd60 = countOccurrences(text, "+60") + countOccurrences(text, "60 zile") + countOccurrences(text, "categorie 2");
  const dpd90 = countOccurrences(text, "+90") + countOccurrences(text, "90 zile") + countOccurrences(text, "categorie 3");

  // Nonbank counts stub:
  // You should implement real counts from account tables later.
  // For now we attempt a naive capture if text contains "Non-Bancari" and numbers.
  const nonbankActive = findNumberAfter(text, /credite active[^0-9]{0,30}non-bancari/i) ?? 0;
  const nonbankClosed = findNumberAfter(text, /inchise[^0-9]{0,30}non-bancari/i) ?? 0;

  return {
    bc_fico_score: fico,
    bc_existing_monthly_obligations: 0,
    bc_dpd_last_4y: {
      dpd_30_count: dpd30,
      dpd_60_count: dpd60,
      dpd_90plus_count: dpd90
    },
    bc_nonbank: {
      closed_last_4y: nonbankClosed,
      active_now: nonbankActive
    },
    warnings
  };
}

/** ---- helpers ---- **/

function normalizeNumberToken(token: string): number | null {
  // Convert "1.234,56" or "1234.56" or "1 234" -> number
  const t = token.replace(/\s/g, "");
  const hasComma = t.includes(",");
  const hasDot = t.includes(".");

  let normalized = t;

  if (hasComma && hasDot) {
    // assume dot thousands, comma decimals: "1.234,56" -> "1234.56"
    normalized = t.replace(/\./g, "").replace(",", ".");
  } else if (hasComma && !hasDot) {
    // assume comma decimal: "1234,56" -> "1234.56"
    normalized = t.replace(",", ".");
  } else {
    // dot decimal or plain int
    normalized = t;
  }

  const n = Number(normalized);
  if (!Number.isFinite(n)) return null;
  return n;
}

function pickNumbersFromLine(line: string): number[] {
  const raw = line.match(/(\d[\d\s\.,]*)/g) ?? [];
  const nums: number[] = [];
  for (const r of raw) {
    const n = normalizeNumberToken(r);
    if (n != null) nums.push(n);
  }
  return nums;
}

function avgLastN(arr: number[], n: number): number | null {
  if (!arr.length) return null;
  const last = arr.slice(Math.max(0, arr.length - n));
  const sum = last.reduce((a, b) => a + b, 0);
  return sum / last.length;
}

function clampInt(x: number, a: number, b: number): number {
  return Math.max(a, Math.min(b, x));
}

function countOccurrences(text: string, needle: string): number {
  const re = new RegExp(escapeRegExp(needle), "gi");
  return (text.match(re) ?? []).length;
}

function escapeRegExp(s: string) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function findNumberAfter(text: string, re: RegExp): number | null {
  const m = text.match(re);
  if (!m) return null;

  const idx = m.index ?? 0;
  const slice = text.slice(idx, idx + 200);
  const nums = slice.match(/\d{1,3}/g);
  if (!nums?.length) return null;
  return parseInt(nums[0], 10);
}
________________________________________
src/parsers/reportParser.ts
import { downloadBlobToBuffer } from "./blobClient.js";
import { pdfToText } from "./pdfText.js";
import { extractFromAnafText, extractFromBcText, ExtractedPayload } from "./extractors.js";

const containerName = process.env.BLOB_CONTAINER || "reports";

function anafBlobName(anaf_report_id: string) {
  return `anaf/${anaf_report_id}.pdf`;
}
function bcBlobName(bc_report_id: string) {
  return `bc/${bc_report_id}.pdf`;
}

/**
 * Fetch + parse both reports. Returns merged extracted payload.
 * In production: cache results in DB with hash to avoid re-parsing.
 */
export async function parseReports(anaf_report_id: string, bc_report_id: string): Promise<ExtractedPayload> {
  const warnings: string[] = [];

  // ANAF
  const anafBuf = await downloadBlobToBuffer(containerName, anafBlobName(anaf_report_id));
  const anafText = await pdfToText(anafBuf);
  const anafExtracted = extractFromAnafText(anafText);
  if (anafExtracted.warnings?.length) warnings.push(...anafExtracted.warnings.map(w => `ANAF:${w}`));

  // BC
  const bcBuf = await downloadBlobToBuffer(containerName, bcBlobName(bc_report_id));
  const bcText = await pdfToText(bcBuf);
  const bcExtracted = extractFromBcText(bcText);
  if (bcExtracted.warnings?.length) warnings.push(...bcExtracted.warnings.map(w => `BC:${w}`));

  return {
    ...anafExtracted,
    ...bcExtracted,
    warnings
  };
}
________________________________________
5) Modificare mică în /calc/verified ca să folosească parser stub dacă extracted lipsește
src/functions/calcVerified.ts (înlocuiești blocul “requires extracted”)
import { parseReports } from "../parsers/reportParser.js";

// ...

const cfg = await loadConfig();

let reqData = parsed.data;

if (!reqData.extracted) {
  // fetch & parse from blob
  const extracted = await parseReports(reqData.anaf_report_id, reqData.bc_report_id);
  reqData = { ...reqData, extracted };
}

const result = calcVerified(reqData, cfg);
return json(200, result);
Asta face ca FE să trimită doar anaf_report_id / bc_report_id, iar backend-ul își scoate singur datele.
________________________________________
6) “Exemplu response” pentru extracted (ce se întoarce intern)
{
  "anaf_income_avg_net_6m": 5200,
  "anaf_income_avg_meal_6m": 400,
  "bc_fico_score": 632,
  "bc_existing_monthly_obligations": 0,
  "bc_dpd_last_4y": { "dpd_30_count": 2, "dpd_60_count": 0, "dpd_90plus_count": 0 },
  "bc_nonbank": { "closed_last_4y": 6, "active_now": 2 },
  "warnings": ["BC:BC_PARSE_WEAK: monthly obligations not parsed (stub)"]
}
________________________________________
7) Checklist rapid (ca să nu se împotmolească IT-ul)
1.	Function App = Custom container enabled
2.	ACR = push ok
3.	Env vars set în Function App:
o	COSMOS_*
o	BLOB_CONNECTION_STRING + BLOB_CONTAINER
o	AUTH_* (sau bypass dev)
4.	Pipeline merge on main → deploy ok
5.	Parser stub rule: dacă PDF e scanat, warnings + fallback manual review (îl poți lega în engine via DATA_PARSE_WARNING)
________________________________________
Dacă vrei, îți mai adaug imediat:
•	endpoint intern POST /reports/extract (admin) care doar parsează și salvează extracted în DB (cache), ca /calc/verified să fie super rapid.

// Add dependencies (if not already):
// "@azure/cosmos", "@azure/functions", "zod", "@azure/storage-blob", "pdf-parse", "jose"
1) Contract + validation pentru endpoint-ul intern
// src/shared/contracts-reports.ts
export interface ReportsExtractRequest {
  anaf_report_id: string;
  bc_report_id: string;
  // optional: force re-parse even if cached
  force?: boolean;
}

export interface ReportsExtractResponse {
  cache_key: string;
  cached: boolean;      // true if returned from cache without re-parse
  extracted: Record<string, unknown>;
  warnings?: string[];
  meta: {
    parsed_at: string;  // ISO
    version: string;    // parser version
  };
}
// src/shared/validation-reports.ts
import { z } from "zod";

export const ReportsExtractRequestSchema = z.object({
  anaf_report_id: z.string().min(1),
  bc_report_id: z.string().min(1),
  force: z.boolean().optional()
});
________________________________________
2) Cosmos cache container helper
Recomandare: container separat report_cache (Cosmos) cu:
•	id = cache_key
•	pk = cache_key
•	anaf_report_id, bc_report_id
•	extracted, warnings, parser_version, created_at
•	opțional TTL (ex: 30 zile), dacă vrei
// src/shared/cosmosReportCache.ts
import { CosmosClient, Container } from "@azure/cosmos";

const endpoint = process.env.COSMOS_ENDPOINT!;
const key = process.env.COSMOS_KEY!;
const databaseId = process.env.COSMOS_DB!;
const containerId = process.env.COSMOS_CONTAINER_REPORT_CACHE!; // e.g. "report_cache"

let container: Container | null = null;

function getContainer(): Container {
  if (!endpoint || !key || !databaseId || !containerId) {
    throw new Error("COSMOS_REPORT_CACHE_NOT_CONFIGURED");
  }
  if (!container) {
    const client = new CosmosClient({ endpoint, key });
    container = client.database(databaseId).container(containerId);
  }
  return container;
}

export interface ReportCacheDoc {
  id: string;      // cache_key
  pk: string;      // cache_key
  anaf_report_id: string;
  bc_report_id: string;

  extracted: Record<string, unknown>;
  warnings?: string[];

  parser_version: string;
  created_at: string; // ISO
}

export async function loadReportCache(cacheKey: string): Promise<ReportCacheDoc | null> {
  const c = getContainer();
  try {
    const { resource } = await c.item(cacheKey, cacheKey).read<ReportCacheDoc>();
    return resource ?? null;
  } catch (e: any) {
    if (e?.code === 404) return null;
    return null;
  }
}

export async function saveReportCache(doc: Omit<ReportCacheDoc, "id" | "pk"> & { id: string }): Promise<ReportCacheDoc> {
  const c = getContainer();
  const full = { ...doc, pk: doc.id };
  const { resource } = await c.items.upsert<ReportCacheDoc>(full);
  if (!resource) throw new Error("REPORT_CACHE_SAVE_FAILED");
  return resource;
}
________________________________________
3) Cache key + parser version
// src/parsers/cacheKey.ts
import crypto from "node:crypto";

export const PARSER_VERSION = "2026-01-05-stub-v1";

export function makeCacheKey(anaf_report_id: string, bc_report_id: string): string {
  // stable key: sha1("anaf|bc|version")
  const raw = `${anaf_report_id}|${bc_report_id}|${PARSER_VERSION}`;
  return crypto.createHash("sha1").update(raw).digest("hex");
}
________________________________________
4) Endpoint handler: POST /reports/extract (admin)
src/functions/reportsExtract.ts
import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";
import { readJson, badRequest, unauthorized, json } from "../shared/http.js";
import { requireAdmin } from "../shared/auth.js";
import { ReportsExtractRequestSchema } from "../shared/validation-reports.js";
import { parseReports } from "../parsers/reportParser.js";
import { makeCacheKey, PARSER_VERSION } from "../parsers/cacheKey.js";
import { loadReportCache, saveReportCache } from "../shared/cosmosReportCache.js";

function nowIso() {
  return new Date().toISOString();
}

export async function handler(req: HttpRequest, ctx: InvocationContext): Promise<HttpResponseInit> {
  try {
    try {
      await requireAdmin(req);
    } catch (e: any) {
      ctx.warn("Admin auth failed", e?.message);
      return unauthorized();
    }

    const body = await readJson(req);
    const parsed = ReportsExtractRequestSchema.safeParse(body);
    if (!parsed.success) return badRequest("Invalid request", parsed.error.flatten());

    const { anaf_report_id, bc_report_id, force } = parsed.data;
    const cache_key = makeCacheKey(anaf_report_id, bc_report_id);

    if (!force) {
      const cached = await loadReportCache(cache_key);
      if (cached) {
        return json(200, {
          cache_key,
          cached: true,
          extracted: cached.extracted,
          warnings: cached.warnings ?? [],
          meta: { parsed_at: cached.created_at, version: cached.parser_version }
        });
      }
    }

    // Parse PDFs from blob
    const extracted = await parseReports(anaf_report_id, bc_report_id);

    // Save to cache
    const doc = await saveReportCache({
      id: cache_key,
      anaf_report_id,
      bc_report_id,
      extracted: extracted as unknown as Record<string, unknown>,
      warnings: extracted.warnings ?? [],
      parser_version: PARSER_VERSION,
      created_at: nowIso()
    });

    return json(200, {
      cache_key,
      cached: false,
      extracted: doc.extracted,
      warnings: doc.warnings ?? [],
      meta: { parsed_at: doc.created_at, version: doc.parser_version }
    });
  } catch (e: any) {
    ctx.error(e);
    return badRequest("Failed to extract reports", { code: e?.message ?? "UNKNOWN" });
  }
}

app.http("reportsExtract", {
  methods: ["POST"],
  authLevel: "anonymous",
  route: "reports/extract",
  handler
});
________________________________________
5) Leagă cache-ul în /calc/verified (super rapid)
În src/functions/calcVerified.ts, înainte de parse:
import { makeCacheKey } from "../parsers/cacheKey.js";
import { loadReportCache } from "../shared/cosmosReportCache.js";
import { parseReports } from "../parsers/reportParser.js";

// ...
const cfg = await loadConfig();

let reqData = parsed.data;

// If extracted not provided, attempt cache first
if (!reqData.extracted) {
  const cacheKey = makeCacheKey(reqData.anaf_report_id, reqData.bc_report_id);
  const cached = await loadReportCache(cacheKey);

  if (cached) {
    reqData = { ...reqData, extracted: cached.extracted as any };
  } else {
    const extracted = await parseReports(reqData.anaf_report_id, reqData.bc_report_id);
    // Optionally: save cache here too (or rely on /reports/extract)
    reqData = { ...reqData, extracted };
  }
}

const result = calcVerified(reqData, cfg);
return json(200, result);
În practică: voi rulați /reports/extract imediat după upload/achiziție raport → se salvează cache → când clientul intră la calculator, /calc/verified e instant.
________________________________________
6) Update src/index.ts să înregistreze noul endpoint
// src/index.ts
import "./functions/calcSimple.js";
import "./functions/calcVerified.js";
import "./functions/getConfig.js";
import "./functions/putConfig.js";
import "./functions/reportsExtract.js";
________________________________________
7) OpenAPI (extra path) – dacă vrei să-l adaugi în spec
/reports/extract:
  post:
    tags: [reports]
    summary: Parse ANAF+BC PDFs and cache extracted values (admin)
    security:
      - BearerAuth: []
    requestBody:
      required: true
      content:
        application/json:
          schema:
            type: object
            required: [anaf_report_id, bc_report_id]
            properties:
              anaf_report_id: { type: string }
              bc_report_id: { type: string }
              force: { type: boolean }
    responses:
      "200":
        description: Extracted + cached
        content:
          application/json:
            schema:
              type: object
              properties:
                cache_key: { type: string }
                cached: { type: boolean }
                extracted: { type: object }
                warnings:
                  type: array
                  items: { type: string }
                meta:
                  type: object
                  properties:
                    parsed_at: { type: string, format: date-time }
                    version: { type: string }
      "401":
        description: Unauthorized
________________________________________
8) Env vars de adăugat în Azure Function App
•	COSMOS_CONTAINER_REPORT_CACHE=report_cache
•	plus deja existente: COSMOS_*, BLOB_*, AUTH_*
________________________________________
Dacă vrei, îți pun și un TTL pe cache (Cosmos TTL) + un câmp expires_at ca să re-parseze automat după X zile.
Mai jos ai exact ce trebuie: TTL Cosmos pe container + câmp expires_at (ISO) + logică în cod ca să re-parseze automat când a expirat.
________________________________________
1) Cosmos DB: activezi TTL pe container report_cache
În Azure Portal (rapid)
Cosmos DB → Database → Container report_cache → Settings → Time to Live:
•	Enable
•	Default TTL: 2592000 secunde (30 zile) sau cât vrei (ex: 7 zile = 604800)
Dacă pui default TTL pe container, Cosmos va șterge automat documentele după TTL (dacă doc-ul are ttl sau dacă default TTL e setat și doc-ul nu suprascrie).
Eu recomand: default TTL setat, iar noi setăm și câmp ttl per document (ca să controlezi ușor din config).
________________________________________
2) Update contract DB: adăugăm expires_at + ttl (secunde)
src/shared/cosmosReportCache.ts
Înlocuiești ReportCacheDoc cu:
export interface ReportCacheDoc {
  id: string;      // cache_key
  pk: string;      // cache_key
  anaf_report_id: string;
  bc_report_id: string;

  extracted: Record<string, unknown>;
  warnings?: string[];

  parser_version: string;
  created_at: string;  // ISO
  expires_at: string;  // ISO

  // Cosmos TTL field (seconds). When present, overrides container default TTL.
  ttl?: number;
}
________________________________________
3) Setare TTL “per doc” + expires_at
Un helper pentru expirare
Creează:
// src/shared/time.ts
export function addDaysIso(days: number): string {
  const d = new Date();
  d.setUTCDate(d.getUTCDate() + days);
  return d.toISOString();
}

export function nowIso(): string {
  return new Date().toISOString();
}

export function isExpired(expiresAtIso: string): boolean {
  const t = Date.parse(expiresAtIso);
  if (!Number.isFinite(t)) return true;
  return t <= Date.now();
}
________________________________________
4) Config: TTL zile în env (sau în config dacă vrei)
Cel mai simplu pentru MVP:
•	REPORT_CACHE_TTL_DAYS=30
// src/shared/cachePolicy.ts
export function cacheTtlDays(): number {
  const raw = process.env.REPORT_CACHE_TTL_DAYS;
  const n = raw ? Number(raw) : 30;
  return Number.isFinite(n) && n > 0 ? Math.floor(n) : 30;
}

export function cacheTtlSeconds(days: number): number {
  return days * 24 * 60 * 60;
}
________________________________________
5) Update: /reports/extract să salveze expires_at + ttl
src/functions/reportsExtract.ts (patch)
Adaugi importuri:
import { nowIso, addDaysIso, isExpired } from "../shared/time.js";
import { cacheTtlDays, cacheTtlSeconds } from "../shared/cachePolicy.js";
Apoi în handler, în zona de cache read:
const ttlDays = cacheTtlDays();
const ttlSec = cacheTtlSeconds(ttlDays);

if (!force) {
  const cached = await loadReportCache(cache_key);
  if (cached) {
    // If doc exists but expired, treat as miss (we will re-parse and overwrite)
    if (!isExpired(cached.expires_at)) {
      return json(200, {
        cache_key,
        cached: true,
        extracted: cached.extracted,
        warnings: cached.warnings ?? [],
        meta: { parsed_at: cached.created_at, version: cached.parser_version, expires_at: cached.expires_at }
      });
    }
  }
}
La salvare:
const createdAt = nowIso();
const expiresAt = addDaysIso(ttlDays);

const doc = await saveReportCache({
  id: cache_key,
  anaf_report_id,
  bc_report_id,
  extracted: extracted as unknown as Record<string, unknown>,
  warnings: extracted.warnings ?? [],
  parser_version: PARSER_VERSION,
  created_at: createdAt,
  expires_at: expiresAt,
  ttl: ttlSec
});
Și response:
return json(200, {
  cache_key,
  cached: false,
  extracted: doc.extracted,
  warnings: doc.warnings ?? [],
  meta: { parsed_at: doc.created_at, version: doc.parser_version, expires_at: doc.expires_at }
});
________________________________________
6) Update: /calc/verified să respecte expirarea cache-ului
În src/functions/calcVerified.ts, când citești cache:
import { isExpired } from "../shared/time.js";

// ...

if (!reqData.extracted) {
  const cacheKey = makeCacheKey(reqData.anaf_report_id, reqData.bc_report_id);
  const cached = await loadReportCache(cacheKey);

  if (cached && !isExpired(cached.expires_at)) {
    reqData = { ...reqData, extracted: cached.extracted as any };
  } else {
    const extracted = await parseReports(reqData.anaf_report_id, reqData.bc_report_id);
    reqData = { ...reqData, extracted };
    // optional: also write cache here (recommended)
  }
}
Dacă vrei să scrie și cache aici, folosești aceeași funcție saveReportCache(...) cu expires_at și ttl.
________________________________________
7) (Optional) Endpoint GET /reports/cache/{cache_key} (admin debug)
Nu e cerut, dar util pentru verificări. Îți pot pune și ăsta dacă vrei.
________________________________________
8) Env vars de pus în Azure Function App
•	COSMOS_CONTAINER_REPORT_CACHE=report_cache
•	REPORT_CACHE_TTL_DAYS=30
•	(dacă nu ai) BLOB_CONTAINER=reports
________________________________________
Comportament final (exact ce ai cerut)
•	Dacă există cache și nu e expirat → /calc/verified devine instant (doar calc, fără parse).
•	Dacă cache e expirat sau lipsește → parsează din Blob, salvează doc cu expires_at + ttl, apoi calculează.
•	Cosmos șterge automat doc-ul după TTL, deci containerul nu se umple.
Dacă vrei, îți pun și un “cache warming flow” în backend: după upload în Blob → trigger → auto apelează parseReports() și scrie cache (fără să mai aștepte userul).

// NOTE: This adds an Azure Blob Trigger Function that runs on upload,
// detects whether the blob is ANAF or BC, and when BOTH reports exist for a given pair,
// it parses and writes the cache doc (warming).
//
// You need a way to "pair" ANAF + BC for a user/session.
// Below is a practical approach that works well:
//
// 1) When user buys/uploads reports, your app creates a "pairing doc" in Cosmos:
//    report_pairs/{pair_id} containing: anaf_report_id, bc_report_id, status.
// 2) Blobs are stored as:
//    reports/anaf/{anaf_report_id}.pdf
//    reports/bc/{bc_report_id}.pdf
// 3) Blob trigger fires on each upload, looks up pair(s) where this id is referenced.
// 4) If both blobs exist, warm cache: parseReports() + saveReportCache() with TTL.
//
// This avoids guessing pairs from filenames and supports many uploads reliably.
1) Cosmos “pairing” container (minimal)
Create Cosmos container: report_pairs (partition key /id or /pk — simplest: use id + pk same).
Document example:
{
  "id": "pair_7f3c...uuid",
  "pk": "pair_7f3c...uuid",
  "user_id": "u_123",
  "anaf_report_id": "anaf_abc123",
  "bc_report_id": "bc_def456",
  "status": "PENDING",
  "created_at": "2026-01-05T21:10:00Z",
  "updated_at": "2026-01-05T21:10:00Z"
}
Pairing doc îl creezi când clientul finalizează cumpărarea rapoartelor (sau când le uploadează).
Blob trigger doar “observă” upload-ul și încălzește cache-ul.
________________________________________
2) Helper: Cosmos report pairs
src/shared/cosmosReportPairs.ts
import { CosmosClient, Container } from "@azure/cosmos";

const endpoint = process.env.COSMOS_ENDPOINT!;
const key = process.env.COSMOS_KEY!;
const databaseId = process.env.COSMOS_DB!;
const containerId = process.env.COSMOS_CONTAINER_REPORT_PAIRS!; // e.g. "report_pairs"

let container: Container | null = null;

function getContainer(): Container {
  if (!endpoint || !key || !databaseId || !containerId) throw new Error("COSMOS_REPORT_PAIRS_NOT_CONFIGURED");
  if (!container) {
    const client = new CosmosClient({ endpoint, key });
    container = client.database(databaseId).container(containerId);
  }
  return container;
}

export interface ReportPairDoc {
  id: string;
  pk: string;
  user_id: string;
  anaf_report_id: string;
  bc_report_id: string;
  status: "PENDING" | "WARMED" | "FAILED";
  created_at: string;
  updated_at: string;
  last_error?: string;
}

export async function findPairsByReportId(reportId: string): Promise<ReportPairDoc[]> {
  const c = getContainer();
  const query = {
    query: `
      SELECT * FROM c
      WHERE c.anaf_report_id = @rid OR c.bc_report_id = @rid
    `,
    parameters: [{ name: "@rid", value: reportId }]
  };
  const { resources } = await c.items.query<ReportPairDoc>(query).fetchAll();
  return resources ?? [];
}

export async function upsertPair(doc: ReportPairDoc): Promise<ReportPairDoc> {
  const c = getContainer();
  const full = { ...doc, pk: doc.id };
  const { resource } = await c.items.upsert<ReportPairDoc>(full);
  if (!resource) throw new Error("PAIR_SAVE_FAILED");
  return resource;
}
________________________________________
3) Blob existence check helper (so we don’t parse until both exist)
src/parsers/blobExists.ts
import { getBlobServiceClient } from "./blobClient.js";

const containerName = process.env.BLOB_CONTAINER || "reports";

export async function blobExists(blobName: string): Promise<boolean> {
  const svc = getBlobServiceClient();
  const container = svc.getContainerClient(containerName);
  const blob = container.getBlobClient(blobName);
  return blob.exists();
}

export function anafBlobName(anaf_report_id: string): string {
  return `anaf/${anaf_report_id}.pdf`;
}
export function bcBlobName(bc_report_id: string): string {
  return `bc/${bc_report_id}.pdf`;
}
________________________________________
4) Cache warming core function (parse + save with TTL)
src/parsers/warmCache.ts
import { parseReports } from "./reportParser.js";
import { makeCacheKey, PARSER_VERSION } from "./cacheKey.js";
import { loadReportCache, saveReportCache } from "../shared/cosmosReportCache.js";
import { cacheTtlDays, cacheTtlSeconds } from "../shared/cachePolicy.js";
import { nowIso, addDaysIso, isExpired } from "../shared/time.js";

export async function warmReportCache(anaf_report_id: string, bc_report_id: string): Promise<{
  cache_key: string;
  warmed: boolean;  // false if already valid cache exists
  reason?: string;
}> {
  const cache_key = makeCacheKey(anaf_report_id, bc_report_id);
  const cached = await loadReportCache(cache_key);

  if (cached && !isExpired(cached.expires_at)) {
    return { cache_key, warmed: false, reason: "CACHE_ALREADY_VALID" };
  }

  const extracted = await parseReports(anaf_report_id, bc_report_id);

  const ttlDays = cacheTtlDays();
  const ttlSec = cacheTtlSeconds(ttlDays);

  await saveReportCache({
    id: cache_key,
    anaf_report_id,
    bc_report_id,
    extracted: extracted as unknown as Record<string, unknown>,
    warnings: extracted.warnings ?? [],
    parser_version: PARSER_VERSION,
    created_at: nowIso(),
    expires_at: addDaysIso(ttlDays),
    ttl: ttlSec
  });

  return { cache_key, warmed: true };
}
________________________________________
5) Azure Blob Trigger Function: on upload → find pairs → if both blobs exist → warm cache
Important Azure note
Blob triggers on Functions v4 Node are easiest with Storage connection:
•	AzureWebJobsStorage or your custom connection setting (e.g. REPORTS_STORAGE)
•	For container reports, path binding uses reports/{name}.
src/functions/blobReportsWarmingTrigger.ts
import { app, InvocationContext } from "@azure/functions";
import { findPairsByReportId, upsertPair } from "../shared/cosmosReportPairs.js";
import { anafBlobName, bcBlobName, blobExists } from "../parsers/blobExists.js";
import { warmReportCache } from "../parsers/warmCache.js";
import { nowIso } from "../shared/time.js";

function parseReportIdFromBlobName(name: string): { type: "ANAF" | "BC" | "UNKNOWN"; reportId: string | null } {
  // name is like "anaf/<id>.pdf" or "bc/<id>.pdf"
  const lower = name.toLowerCase();
  const m = lower.match(/^(anaf|bc)\/(.+)\.pdf$/);
  if (!m) return { type: "UNKNOWN", reportId: null };

  const type = m[1] === "anaf" ? "ANAF" : "BC";
  const reportId = m[2];
  return { type, reportId };
}

export async function handler(blob: Buffer, context: InvocationContext): Promise<void> {
  // context.triggerMetadata.name contains path relative to container
  const blobName = String((context.triggerMetadata as any)?.name ?? "");
  const meta = parseReportIdFromBlobName(blobName);

  if (!meta.reportId) {
    context.log(`Blob uploaded but not matching pattern: ${blobName}`);
    return;
  }

  context.log(`Blob uploaded: ${blobName} -> reportId=${meta.reportId}`);

  // 1) Find all report pairs referencing this reportId
  const pairs = await findPairsByReportId(meta.reportId);
  if (!pairs.length) {
    context.log(`No pairs referencing reportId=${meta.reportId}`);
    return;
  }

  // 2) For each pair, check both blobs exist, then warm cache
  for (const pair of pairs) {
    try {
      const anafName = anafBlobName(pair.anaf_report_id);
      const bcName = bcBlobName(pair.bc_report_id);

      const hasAnaf = await blobExists(anafName);
      const hasBc = await blobExists(bcName);

      if (!hasAnaf || !hasBc) {
        context.log(`Pair ${pair.id}: waiting for both blobs (ANAF=${hasAnaf}, BC=${hasBc})`);
        // keep status pending
        if (pair.status !== "PENDING") {
          await upsertPair({ ...pair, status: "PENDING", updated_at: nowIso() });
        }
        continue;
      }

      const warmed = await warmReportCache(pair.anaf_report_id, pair.bc_report_id);
      context.log(`Pair ${pair.id}: cache_key=${warmed.cache_key}, warmed=${warmed.warmed}, reason=${warmed.reason ?? ""}`);

      await upsertPair({ ...pair, status: "WARMED", updated_at: nowIso(), last_error: undefined });
    } catch (e: any) {
      context.error(`Pair ${pair.id}: warming failed`, e);
      await upsertPair({
        ...pair,
        status: "FAILED",
        updated_at: nowIso(),
        last_error: String(e?.message ?? "UNKNOWN")
      });
    }
  }
}

// Blob trigger binding
// - "path" must match your container structure: reports/{name}
// - "connection" uses AzureWebJobsStorage by default; you can set a custom connection name.
app.storageBlob("reportsWarmingTrigger", {
  path: "reports/{name}",
  connection: "AzureWebJobsStorage",
  handler
});
________________________________________
6) Înregistrare în src/index.ts
import "./functions/calcSimple.js";
import "./functions/calcVerified.js";
import "./functions/getConfig.js";
import "./functions/putConfig.js";
import "./functions/reportsExtract.js";
import "./functions/blobReportsWarmingTrigger.js";
________________________________________
7) Env vars necesare (Azure Function App)
Pe lângă cele existente:
•	COSMOS_CONTAINER_REPORT_PAIRS=report_pairs
•	COSMOS_CONTAINER_REPORT_CACHE=report_cache
•	REPORT_CACHE_TTL_DAYS=30
•	BLOB_CONTAINER=reports (dacă folosești helper-ul; trigger-ul oricum folosește binding)
•	Storage:
o	AzureWebJobsStorage trebuie să pointeze la storage-ul unde e containerul reports
________________________________________
8) Cum creezi pairing doc (flow recomandat)
Când userul cumpără/încarcă rapoartele:
1.	backend creează doc în report_pairs cu anaf_report_id + bc_report_id + status=PENDING
2.	rapoartele se uploadează în Blob (anaf/<id>.pdf și bc/<id>.pdf)
3.	Trigger rulează de 2 ori (la fiecare upload), dar încălzește cache doar când ambele există.
________________________________________
9) Bonus: “super fast calc/verified”
•	UI call:
1.	upload ANAF/BC
2.	(optional) call /reports/extract (admin) sau aștepți trigger-ul
3.	user call /calc/verified → ia din cache și răspunde instant
________________________________________
Dacă vrei, îți adaug și endpoint public (non-admin) POST /report-pairs/create care creează pairing doc și returnează pair_id, ca FE să aibă un flux complet cap-coadă.

// Adds a PUBLIC endpoint:
// POST /report-pairs/create
// - authLevel: anonymous (you can later require user auth/JWT)
// - creates a pairing doc in Cosmos (report_pairs)
// - returns pair_id + what to upload where
1) Contract + validation
src/shared/contracts-pairs.ts
export interface ReportPairsCreateRequest {
  user_id: string;            // your internal user id (or session id for MVP)
  anaf_report_id: string;     // generated by your system when you issue/upload ANAF PDF
  bc_report_id: string;       // generated by your system when you issue/upload BC PDF
}

export interface ReportPairsCreateResponse {
  pair_id: string;
  status: "PENDING";
  upload: {
    container: string;        // "reports"
    anaf_blob: string;        // "anaf/<id>.pdf"
    bc_blob: string;          // "bc/<id>.pdf"
  };
  meta: {
    created_at: string;       // ISO
  };
}
src/shared/validation-pairs.ts
import { z } from "zod";

export const ReportPairsCreateRequestSchema = z.object({
  user_id: z.string().min(1),
  anaf_report_id: z.string().min(1),
  bc_report_id: z.string().min(1)
});
________________________________________
2) Cosmos helper: create pair
Update src/shared/cosmosReportPairs.ts to add a create function:
import crypto from "node:crypto";
import { ReportPairDoc, upsertPair } from "./cosmosReportPairs.js";

function nowIso() {
  return new Date().toISOString();
}

export async function createPair(user_id: string, anaf_report_id: string, bc_report_id: string): Promise<ReportPairDoc> {
  const id = `pair_${crypto.randomUUID()}`;
  const created_at = nowIso();

  const doc: ReportPairDoc = {
    id,
    pk: id,
    user_id,
    anaf_report_id,
    bc_report_id,
    status: "PENDING",
    created_at,
    updated_at: created_at
  };

  return upsertPair(doc);
}
Dacă ai deja upsertPair în același fișier, poți pune createPair tot acolo (mai simplu).
________________________________________
3) Handler: POST /report-pairs/create (public)
src/functions/reportPairsCreate.ts
import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";
import { readJson, badRequest, json } from "../shared/http.js";
import { ReportPairsCreateRequestSchema } from "../shared/validation-pairs.js";
import { createPair } from "../shared/cosmosReportPairs.js";

const containerName = process.env.BLOB_CONTAINER || "reports";

function nowIso() {
  return new Date().toISOString();
}

export async function handler(req: HttpRequest, ctx: InvocationContext): Promise<HttpResponseInit> {
  try {
    const body = await readJson(req);
    const parsed = ReportPairsCreateRequestSchema.safeParse(body);
    if (!parsed.success) return badRequest("Invalid request", parsed.error.flatten());

    const { user_id, anaf_report_id, bc_report_id } = parsed.data;

    // Create pairing doc (PENDING). Blob trigger will warm cache after upload.
    const pair = await createPair(user_id, anaf_report_id, bc_report_id);

    return json(200, {
      pair_id: pair.id,
      status: "PENDING",
      upload: {
        container: containerName,
        anaf_blob: `anaf/${anaf_report_id}.pdf`,
        bc_blob: `bc/${bc_report_id}.pdf`
      },
      meta: {
        created_at: nowIso()
      }
    });
  } catch (e: any) {
    ctx.error(e);
    return badRequest("Failed to create report pair", { code: e?.message ?? "UNKNOWN" });
  }
}

app.http("reportPairsCreate", {
  methods: ["POST"],
  authLevel: "anonymous",
  route: "report-pairs/create",
  handler
});
________________________________________
4) Înregistrare în src/index.ts
import "./functions/calcSimple.js";
import "./functions/calcVerified.js";
import "./functions/getConfig.js";
import "./functions/putConfig.js";
import "./functions/reportsExtract.js";
import "./functions/blobReportsWarmingTrigger.js";
import "./functions/reportPairsCreate.js";
________________________________________
5) OpenAPI path (dacă vrei în spec)
/report-pairs/create:
  post:
    tags: [reports]
    summary: Create a report pairing (public)
    requestBody:
      required: true
      content:
        application/json:
          schema:
            type: object
            required: [user_id, anaf_report_id, bc_report_id]
            properties:
              user_id: { type: string }
              anaf_report_id: { type: string }
              bc_report_id: { type: string }
    responses:
      "200":
        description: Pair created
        content:
          application/json:
            schema:
              type: object
              properties:
                pair_id: { type: string }
                status: { type: string, enum: [PENDING] }
                upload:
                  type: object
                  properties:
                    container: { type: string }
                    anaf_blob: { type: string }
                    bc_blob: { type: string }
                meta:
                  type: object
                  properties:
                    created_at: { type: string, format: date-time }
________________________________________
6) Flux FE complet (cap-coadă)
1.	FE cere backend: POST /report-pairs/create cu user_id, anaf_report_id, bc_report_id
2.	FE uploadează PDF-uri în Blob:
o	reports/anaf/<anaf_report_id>.pdf
o	reports/bc/<bc_report_id>.pdf
3.	Blob trigger rulează → găsește pair → parsează → scrie cache
4.	FE cheamă POST /calc/verified → ia din cache (instant)
________________________________________
Observație importantă (securitate / producție)
Chiar dacă endpoint-ul e “public”, recomand:
•	să nu accepți user_id liber (altfel cineva poate “asocia” rapoarte străine)
•	ideal: user_id vine din JWT (sub) și îl ignori pe cel din body
Dacă vrei, îți pun și varianta “JWT user auth” (non-admin) în 10 linii, compatibilă Entra ID.

// Goal: JWT user auth (non-admin), Entra ID compatible, ~10 lines usable in handlers.
// Assumes your existing jose-based verification (JWKS) from auth.ts,
// but WITHOUT role check (admin). Uses Entra ID OIDC JWKS + issuer/audience.
// Env needed:
// AUTH_JWKS_URL, AUTH_AUDIENCE, AUTH_ISSUER
1) Add this helper (10-ish lines): src/shared/userAuth.ts
import { HttpRequest } from "@azure/functions";
import { jwtVerify, createRemoteJWKSet } from "jose";

const JWKS = process.env.AUTH_JWKS_URL ? createRemoteJWKSet(new URL(process.env.AUTH_JWKS_URL)) : null;

export async function requireUser(req: HttpRequest): Promise<{ sub: string; email?: string }> {
  const auth = req.headers.get("authorization") || "";
  const token = auth.startsWith("Bearer ") ? auth.slice(7) : "";
  if (!token || !JWKS) throw new Error("NO_AUTH");

  const { payload } = await jwtVerify(token, JWKS, {
    audience: process.env.AUTH_AUDIENCE,
    issuer: process.env.AUTH_ISSUER
  });

  return { sub: String(payload.sub ?? ""), email: (payload.preferred_username as string | undefined) };
}
2) Use it in POST /report-pairs/create (ignore user_id from body)
Patch src/functions/reportPairsCreate.ts:
import { requireUser } from "../shared/userAuth.js";

// ...

// inside handler, after body validation:
const user = await requireUser(req);        // throws if missing/invalid
const user_id = user.sub;                   // authoritative
const { anaf_report_id, bc_report_id } = parsed.data;

const pair = await createPair(user_id, anaf_report_id, bc_report_id);
And change validation schema to remove user_id (recommended):
// src/shared/validation-pairs.ts
export const ReportPairsCreateRequestSchema = z.object({
  anaf_report_id: z.string().min(1),
  bc_report_id: z.string().min(1)
});
3) Return 401 on missing/invalid JWT
In handler, wrap:
try { await requireUser(req); } catch { return unauthorized(); }
________________________________________
Entra ID values (what to set)
•	AUTH_ISSUER: https://login.microsoftonline.com/<TENANT_ID>/v2.0
•	AUTH_AUDIENCE: your API app registration Application (client) ID (or api://<client-id> depending on config)
•	AUTH_JWKS_URL: https://login.microsoftonline.com/<TENANT_ID>/discovery/v2.0/keys
If vrei, îți dau și exemplu de App Registration config (Expose an API + scopes) ca să emită access tokens pentru FE.

Mai jos ai un exemplu complet (și practic) de App Registration config în Entra ID pentru:
•	API (MoneyShop Eligibility API) → expune scope-uri (Expose an API)
•	Frontend (MoneyShop Web / SPA) → cere token (OAuth2) și îl trimite ca Bearer la Functions
________________________________________
A) Creezi App Registration pentru API
1) Entra ID → App registrations → New registration
•	Name: MoneyShop Eligibility API
•	Supported account types: Single tenant (recomandat)
•	Redirect URI: lasă gol (nu e necesar pentru API)
2) Expose an API
Intră în app → Expose an API
Set Application ID URI
•	Click Set la “Application ID URI”
•	Pune: api://<API_CLIENT_ID> (Azure propune automat)
o	Ex: api://11111111-2222-3333-4444-555555555555
Add a scope
•	Scope name: access_as_user
•	Who can consent: Admins and users
•	Admin consent display name: Access MoneyShop Eligibility API
•	Admin consent description: Allows the app to access MoneyShop API on behalf of the signed-in user.
•	User consent display name/description: similar
•	State: Enabled
Scope-ul ăsta e cel pe care FE îl cere ca să primească access token.
3) App roles (opțional, pentru admin endpoints)
Intră la App roles (în API app)
Creează role:
•	Display name: Admin
•	Value: admin
•	Allowed member types: Users/Groups
•	Enabled: Yes
Apoi atribui rolul unor useri (vezi secțiunea D).
4) Manifest / Token claims (opțional)
De obicei nu trebuie, dar util:
•	Lasă token version v2 (default)
•	În token vei avea aud = API client id sau api://... (depinde cum ceri tokenul)
________________________________________
B) Creezi App Registration pentru Frontend (SPA)
1) New registration
•	Name: MoneyShop Web
•	Supported: Single tenant (același tenant)
•	Redirect URI: Single-page application (SPA):
o	https://moneyshop.ro/auth/callback
o	(și dev) http://localhost:3000/auth/callback
2) Authentication
În MoneyShop Web → Authentication
•	Platform: Single-page application
•	Redirect URIs: cele de mai sus
•	Enable:
o	Access tokens (used for implicit flows) = OFF (nu folosi implicit)
o	ID tokens = ON (ok)
•	“Allow public client flows” = No (de obicei)
Pentru SPA modern folosești Authorization Code Flow + PKCE (MSAL face asta).
3) API permissions
În MoneyShop Web → API permissions → Add a permission
•	My APIs → selectezi MoneyShop Eligibility API
•	Delegated permissions → bifezi access_as_user
•	Click Add permissions
Apoi:
•	Click Grant admin consent (recomandat ca să nu apară prompt-uri)
________________________________________
C) Setări pentru Functions (verificare JWT)
Din config-ul pe care l-am folosit noi:
•	AUTH_ISSUER:
o	https://login.microsoftonline.com/<TENANT_ID>/v2.0
•	AUTH_JWKS_URL:
o	https://login.microsoftonline.com/<TENANT_ID>/discovery/v2.0/keys
•	AUTH_AUDIENCE:
o	Ai 2 variante corecte, alege una și rămâi consecvent:
2.	API Client ID (GUID) – simplu
3.	api://<API_CLIENT_ID> – dacă în token apare așa la aud
Cum verifici ce ai în realitate:
•	Decodifici un access token și vezi aud.
•	Setezi AUTH_AUDIENCE identic cu aud.
________________________________________
D) Atribuire role “admin” (ca să meargă endpoints admin)
Dacă ai folosit App roles în API:
1.	Entra ID → Enterprise applications
2.	Caută aplicația MoneyShop Eligibility API
3.	Users and groups → Add user/group
4.	Select role: Admin
În token, roles: ["admin"] va apărea (în access token), iar requireAdmin() din cod funcționează.
________________________________________
E) Exemplu MSAL (Frontend) – cum ceri access token pentru API
Scope-ul cerut trebuie să fie:
•	api://<API_CLIENT_ID>/access_as_user
Exemplu config (orientativ):
const msalConfig = {
  auth: {
    clientId: "<SPA_CLIENT_ID>",
    authority: "https://login.microsoftonline.com/<TENANT_ID>",
    redirectUri: "https://moneyshop.ro/auth/callback"
  }
};

const loginRequest = {
  scopes: ["api://<API_CLIENT_ID>/access_as_user"]
};
Apoi tokenul îl trimiți:
Authorization: Bearer <access_token>
________________________________________
F) CORS (important pentru FE → Functions)
În Azure Function App:
•	CORS: adaugi https://moneyshop.ro și http://localhost:3000
________________________________________
Dacă îmi spui ce folosiți pe FE (React/Next/Vue) îți dau un snippet complet MSAL (login + acquireTokenSilent + call API), exact pe stack-ul vostru.








