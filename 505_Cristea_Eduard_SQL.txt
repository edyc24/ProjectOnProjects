PROIECT SBD - MONEYSHOP
Student: Cristea Eduard
Grupa: 505

REZOLVAREA CERINTEI 7: 15 INTEROGARI SQL COMPLEXE

INTEROGAREA 1: GROUP BY, HAVING, functii agregat
Enunt: Afisati bancile care au procesat mai mult de 5 aplicatii aprobate, impreuna cu numarul total de aplicatii, suma totala aprobata si comisionul mediu

SELECT 
    b.Name AS Banca,
    COUNT(ab.ApplicationId) AS NumarAplicatii,
    SUM(a.SumaAprobata) AS SumaTotalaAprobata,
    AVG(a.Comision) AS ComisionMediu,
    MAX(a.Scoring) AS ScoringMaxim
FROM BANCI b
INNER JOIN APPLICATION_BANKS ab ON b.Id = ab.BankId
INNER JOIN APLICATII a ON ab.ApplicationId = a.Id
WHERE a.Status = 'APROBAT'
GROUP BY b.Name
HAVING COUNT(ab.ApplicationId) > 5
ORDER BY SumaTotalaAprobata DESC;

INTEROGAREA 2: Functii siruri de caractere (LOWER, UPPER, SUBSTR, INSTR)
Enunt: Afisati utilizatorii cu email-ul formatat (numele domeniului in majuscule, restul in minuscule) si primele 3 caractere din nume

SELECT 
    UPPER(SUBSTR(Email, INSTR(Email, '@') + 1)) AS DomeniuMajuscule,
    LOWER(SUBSTR(Email, 1, INSTR(Email, '@') - 1)) AS PrefixMinuscule,
    SUBSTR(Nume, 1, 3) AS PrimeleTreiCaractere,
    Nume || ' ' || Prenume AS NumeComplet
FROM UTILIZATORI
WHERE Email IS NOT NULL
ORDER BY Nume;

INTEROGAREA 3: Functii date (TO_CHAR, TO_DATE, ADD_MONTHS, MONTHS_BETWEEN)
Enunt: Afisati aplicatiile create in ultimele 6 luni, cu data formata si numarul de luni de la creare

SELECT 
    a.Id AS IdAplicatie,
    TO_CHAR(a.CreatedAt, 'DD-MM-YYYY HH24:MI:SS') AS DataFormatata,
    TO_CHAR(a.CreatedAt, 'MONTH YYYY', 'NLS_DATE_LANGUAGE=ROMANIAN') AS LunaAn,
    MONTHS_BETWEEN(SYSDATE, a.CreatedAt) AS LuniDeLaCreare,
    ADD_MONTHS(a.CreatedAt, 6) AS DataExpirareEstimata,
    u.Nume || ' ' || u.Prenume AS Utilizator
FROM APLICATII a
INNER JOIN UTILIZATORI u ON a.UserId = u.IdUtilizator
WHERE a.CreatedAt >= ADD_MONTHS(SYSDATE, -6)
ORDER BY a.CreatedAt DESC;

INTEROGAREA 4: Functii diverse (DECODE, NVL, NULLIF, CASE)
Enunt: Afisati aplicatiile cu statusul tradus in romana, scoring-ul normalizat si tipul de credit cu DECODE si CASE

SELECT 
    a.Id,
    DECODE(a.Status, 
        'INREGISTRAT', 'Inregistrat',
        'IN_PROCESARE', 'In procesare',
        'APROBAT', 'Aprobat',
        'REFUZAT', 'Refuzat',
        'ANULAT', 'Anulat',
        'Necunoscut') AS StatusRomana,
    CASE 
        WHEN a.Scoring IS NULL THEN 'Fara scoring'
        WHEN a.Scoring >= 700 THEN 'Scoring bun'
        WHEN a.Scoring >= 600 THEN 'Scoring mediu'
        ELSE 'Scoring slab'
    END AS CategorieScoring,
    NVL(TO_CHAR(a.SumaAprobata), 'N/A') AS SumaAprobata,
    NULLIF(a.Dti, 0) AS DtiNonZero,
    a.TypeCredit
FROM APLICATII a
ORDER BY a.Id;

INTEROGAREA 5: INNER JOIN cu subinterogare in WHERE
Enunt: Afisati utilizatorii care au aplicatii cu scoring mai mare decat media tuturor aplicatiilor aprobate

SELECT 
    u.IdUtilizator,
    u.Nume || ' ' || u.Prenume AS NumeComplet,
    u.Email,
    a.Scoring,
    a.SumaAprobata
FROM UTILIZATORI u
INNER JOIN APLICATII a ON u.IdUtilizator = a.UserId
WHERE a.Scoring > (
    SELECT AVG(Scoring)
    FROM APLICATII
    WHERE Status = 'APROBAT' AND Scoring IS NOT NULL
)
AND a.Status = 'APROBAT'
ORDER BY a.Scoring DESC;

INTEROGAREA 6: LEFT JOIN cu functii agregat
Enunt: Afisati toti utilizatorii si numarul de aplicatii pentru fiecare, inclusiv cei fara aplicatii

SELECT 
    u.IdUtilizator,
    u.Nume || ' ' || u.Prenume AS NumeComplet,
    COUNT(a.Id) AS NumarAplicatii,
    SUM(NVL(a.SumaAprobata, 0)) AS SumaTotalaAprobata,
    AVG(a.Scoring) AS ScoringMediu
FROM UTILIZATORI u
LEFT JOIN APLICATII a ON u.IdUtilizator = a.UserId
WHERE u.IsDeleted = 0
GROUP BY u.IdUtilizator, u.Nume, u.Prenume
ORDER BY NumarAplicatii DESC;

INTEROGAREA 7: RIGHT JOIN cu GROUP BY si HAVING
Enunt: Afisati toate bancile si numarul de aplicatii asociate, inclusiv bancile fara aplicatii

SELECT 
    b.Name AS Banca,
    b.CommissionPercent AS ComisionProcent,
    COUNT(ab.ApplicationId) AS NumarAplicatii,
    COUNT(CASE WHEN a.Status = 'APROBAT' THEN 1 END) AS AplicatiiAprobate
FROM APPLICATION_BANKS ab
RIGHT JOIN BANCI b ON ab.BankId = b.Id
LEFT JOIN APLICATII a ON ab.ApplicationId = a.Id
GROUP BY b.Name, b.CommissionPercent
HAVING COUNT(ab.ApplicationId) >= 0
ORDER BY NumarAplicatii DESC;

INTEROGAREA 8: FULL JOIN cu subinterogare in SELECT
Enunt: Afisati toate aplicatiile si documentele asociate, inclusiv aplicatiile fara documente si documentele fara aplicatii

SELECT 
    NVL(a.Id, d.ApplicationId) AS IdAplicatie,
    a.Status,
    COUNT(d.Id) AS NumarDocumente,
    (SELECT COUNT(*) FROM DOCUMENTE WHERE ApplicationId = a.Id) AS TotalDocumente
FROM APLICATII a
FULL JOIN DOCUMENTE d ON a.Id = d.ApplicationId
GROUP BY NVL(a.Id, d.ApplicationId), a.Status
ORDER BY NumarDocumente DESC;

INTEROGAREA 9: UNION - operator pe multimi
Enunt: Afisati toate entitatile (utilizatori si banci) care au fost create in ultimele 3 luni

SELECT 
    'UTILIZATOR' AS TipEntitate,
    Nume || ' ' || Prenume AS Denumire,
    TO_CHAR(CreatedAt, 'YYYY-MM-DD') AS DataCreare
FROM UTILIZATORI
WHERE CreatedAt >= ADD_MONTHS(SYSDATE, -3)
UNION
SELECT 
    'BANCA' AS TipEntitate,
    Name AS Denumire,
    TO_CHAR(CreatedAt, 'YYYY-MM-DD') AS DataCreare
FROM BANCI
WHERE CreatedAt >= ADD_MONTHS(SYSDATE, -3)
ORDER BY DataCreare DESC;

INTEROGAREA 10: INTERSECT - operator pe multimi
Enunt: Afisati utilizatorii care au aplicatii aprobate si mandate active

SELECT u.IdUtilizator, u.Nume || ' ' || u.Prenume AS NumeComplet
FROM UTILIZATORI u
INNER JOIN APLICATII a ON u.IdUtilizator = a.UserId
WHERE a.Status = 'APROBAT'
INTERSECT
SELECT u.IdUtilizator, u.Nume || ' ' || u.Prenume AS NumeComplet
FROM UTILIZATORI u
INNER JOIN MANDATE m ON u.IdUtilizator = m.UserId
WHERE m.Status = 'ACTIV';

INTEROGAREA 11: MINUS - operator pe multimi
Enunt: Afisati utilizatorii care au aplicatii dar nu au mandate

SELECT u.IdUtilizator, u.Nume || ' ' || u.Prenume AS NumeComplet
FROM UTILIZATORI u
INNER JOIN APLICATII a ON u.IdUtilizator = a.UserId
MINUS
SELECT u.IdUtilizator, u.Nume || ' ' || u.Prenume AS NumeComplet
FROM UTILIZATORI u
INNER JOIN MANDATE m ON u.IdUtilizator = m.UserId;

INTEROGAREA 12: Subinterogare in FROM (inline view)
Enunt: Afisati top 5 utilizatori dupa suma totala aprobata, cu media scoring-ului pentru fiecare

SELECT 
    u.Nume || ' ' || u.Prenume AS NumeComplet,
    stats.SumaTotala,
    stats.ScoringMediu,
    stats.NumarAplicatii
FROM UTILIZATORI u
INNER JOIN (
    SELECT 
        UserId,
        SUM(SumaAprobata) AS SumaTotala,
        AVG(Scoring) AS ScoringMediu,
        COUNT(*) AS NumarAplicatii
    FROM APLICATII
    WHERE Status = 'APROBAT' AND SumaAprobata IS NOT NULL
    GROUP BY UserId
) stats ON u.IdUtilizator = stats.UserId
WHERE ROWNUM <= 5
ORDER BY stats.SumaTotala DESC;

INTEROGAREA 13: Subinterogare in HAVING
Enunt: Afisati bancile care au un numar de aplicatii mai mare decat media numarului de aplicatii per banca

SELECT 
    b.Name AS Banca,
    COUNT(ab.ApplicationId) AS NumarAplicatii,
    AVG(a.Scoring) AS ScoringMediu
FROM BANCI b
INNER JOIN APPLICATION_BANKS ab ON b.Id = ab.BankId
INNER JOIN APLICATII a ON ab.ApplicationId = a.Id
GROUP BY b.Name
HAVING COUNT(ab.ApplicationId) > (
    SELECT AVG(COUNT(*))
    FROM APPLICATION_BANKS
    GROUP BY BankId
)
ORDER BY NumarAplicatii DESC;

INTEROGAREA 14: START WITH, CONNECT BY (hierarhie)
Enunt: Afisati ierarhia utilizatorilor: brokeri si clientii lor (prin mandate), cu nivelul in ierarhie

SELECT 
    LEVEL AS NivelIerarhie,
    LPAD(' ', 2 * (LEVEL - 1)) || u.Nume || ' ' || u.Prenume AS NumeComplet,
    r.NumeRol AS Rol,
    CASE 
        WHEN LEVEL = 1 THEN 'Broker'
        WHEN LEVEL = 2 THEN 'Client'
        ELSE 'N/A'
    END AS TipNod
FROM UTILIZATORI u
INNER JOIN ROLURI r ON u.IdRol = r.IdRol
LEFT JOIN MANDATE m ON u.IdUtilizator = m.BrokerId
START WITH r.NumeRol = 'BROKER' AND m.Status = 'ACTIV'
CONNECT BY PRIOR m.UserId = m.BrokerId
ORDER SIBLINGS BY u.Nume;

INTEROGAREA 15: OPERATORUL DIVISION
Enunt: Afisati bancile care au procesat aplicatii pentru TOTI utilizatorii care au aplicatii aprobate (operator DIVISION)

SELECT b.Name AS Banca
FROM BANCI b
WHERE NOT EXISTS (
    SELECT u.IdUtilizator
    FROM UTILIZATORI u
    INNER JOIN APLICATII a ON u.IdUtilizator = a.UserId
    WHERE a.Status = 'APROBAT'
    AND NOT EXISTS (
        SELECT 1
        FROM APPLICATION_BANKS ab
        WHERE ab.BankId = b.Id
        AND ab.ApplicationId = a.Id
    )
)
AND EXISTS (
    SELECT 1
    FROM APPLICATION_BANKS ab
    WHERE ab.BankId = b.Id
);
