PROIECT SBD - MONEYSHOP
Student: Cristea Eduard
Grupa: 505

REZOLVAREA CERINTELOR 8, 9 SI 10: PL/SQL

CERINTA 8: SUBPROGRAM CU COLECTII (3 tipuri)

Enunt: Creati un subprogram PL/SQL care utilizeaza 3 tipuri de colectii: VARRAY, Nested Table si Associative Array

SET SERVEROUTPUT ON;
CREATE OR REPLACE TYPE t_varray_nume AS VARRAY(100) OF VARCHAR2(100);
/
CREATE OR REPLACE TYPE t_nested_table_id AS TABLE OF NUMBER;
/
CREATE OR REPLACE PROCEDURE SP_PROCESARE_COLECTII (
p_id_utilizator IN NUMBER,
p_rezultat OUT VARCHAR2
)
IS
v_nume_banci t_varray_nume := t_varray_nume();
v_id_aplicatii t_nested_table_id := t_nested_table_id();
TYPE t_assoc_array IS TABLE OF NUMBER INDEX BY VARCHAR2(50);
v_sume_pe_status t_assoc_array;
v_contor NUMBER := 0;
v_nume_banca VARCHAR2(200);
v_id_aplicatie NUMBER;
v_status VARCHAR2(50);
v_suma NUMBER;
BEGIN
DBMS_OUTPUT.PUT_LINE('========================================');
DBMS_OUTPUT.PUT_LINE('Procesare colecții pentru utilizator: ' || p_id_utilizator);
DBMS_OUTPUT.PUT_LINE('========================================');
DBMS_OUTPUT.PUT_LINE('1. Populare VARRAY cu nume bănci...');
FOR rec IN (
SELECT DISTINCT b.Name
FROM BANCI b
INNER JOIN APPLICATION_BANKS ab ON b.Id = ab.BankId
INNER JOIN APLICATII a ON ab.ApplicationId = a.Id
WHERE a.UserId = p_id_utilizator
AND ROWNUM <= 100
) LOOP
v_nume_banci.EXTEND;
v_nume_banci(v_nume_banci.COUNT) := rec.Name;
DBMS_OUTPUT.PUT_LINE('   Adăugat în VARRAY: ' || rec.Name);
END LOOP;
DBMS_OUTPUT.PUT_LINE('   Total bănci în VARRAY: ' || v_nume_banci.COUNT);
DBMS_OUTPUT.PUT_LINE('2. Populare NESTED TABLE cu ID-uri aplicații...');
FOR rec IN (
SELECT Id
FROM APLICATII
WHERE UserId = p_id_utilizator
) LOOP
v_id_aplicatii.EXTEND;
v_id_aplicatii(v_id_aplicatii.COUNT) := rec.Id;
DBMS_OUTPUT.PUT_LINE('   Adăugat în NESTED TABLE: ' || rec.Id);
END LOOP;
DBMS_OUTPUT.PUT_LINE('   Total aplicații în NESTED TABLE: ' || v_id_aplicatii.COUNT);
DBMS_OUTPUT.PUT_LINE('3. Populare ASSOCIATIVE ARRAY cu sume pe status...');
FOR rec IN (
SELECT Status, SUM(NVL(SumaAprobata, 0)) AS SumaTotala
FROM APLICATII
WHERE UserId = p_id_utilizator
GROUP BY Status
) LOOP
v_sume_pe_status(rec.Status) := rec.SumaTotala;
DBMS_OUTPUT.PUT_LINE('   Adăugat în ASSOCIATIVE ARRAY: ' || rec.Status || ' = ' || rec.SumaTotala);
END LOOP;
DBMS_OUTPUT.PUT_LINE('   Total statusuri în ASSOCIATIVE ARRAY: ' || v_sume_pe_status.COUNT);
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('Procesare VARRAY:');
IF v_nume_banci.COUNT > 0 THEN
FOR i IN 1..v_nume_banci.COUNT LOOP
DBMS_OUTPUT.PUT_LINE('   Banca ' || i || ': ' || v_nume_banci(i));
END LOOP;
ELSE
DBMS_OUTPUT.PUT_LINE('   VARRAY este gol');
END IF;
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('Procesare NESTED TABLE:');
IF v_id_aplicatii.COUNT > 0 THEN
FOR i IN 1..v_id_aplicatii.COUNT LOOP
DBMS_OUTPUT.PUT_LINE('   Aplicație ' || i || ': ID = ' || v_id_aplicatii(i));
END LOOP;
ELSE
DBMS_OUTPUT.PUT_LINE('   NESTED TABLE este gol');
END IF;
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('Procesare ASSOCIATIVE ARRAY:');
IF v_sume_pe_status.COUNT > 0 THEN
v_status := v_sume_pe_status.FIRST;
WHILE v_status IS NOT NULL LOOP
DBMS_OUTPUT.PUT_LINE('   Status: ' || v_status || ' = ' || v_sume_pe_status(v_status));
v_status := v_sume_pe_status.NEXT(v_status);
END LOOP;
ELSE
DBMS_OUTPUT.PUT_LINE('   ASSOCIATIVE ARRAY este gol');
END IF;
p_rezultat := 'VARRAY: ' || v_nume_banci.COUNT || ' bănci, ' ||
'NESTED TABLE: ' || v_id_aplicatii.COUNT || ' aplicații, ' ||
'ASSOCIATIVE ARRAY: ' || v_sume_pe_status.COUNT || ' statusuri';
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('Rezultat: ' || p_rezultat);
DBMS_OUTPUT.PUT_LINE('========================================');
EXCEPTION
WHEN NO_DATA_FOUND THEN
p_rezultat := 'Nu s-au găsit date pentru utilizatorul ' || p_id_utilizator;
DBMS_OUTPUT.PUT_LINE('EROARE: ' || p_rezultat);
WHEN OTHERS THEN
p_rezultat := 'EROARE: ' || SQLERRM;
DBMS_OUTPUT.PUT_LINE('EROARE: ' || p_rezultat);
RAISE;
END;
/
DECLARE
v_rezultat VARCHAR2(500);
BEGIN
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('TESTARE PROCEDURĂ SP_PROCESARE_COLECTII');
DBMS_OUTPUT.PUT_LINE('');
SP_PROCESARE_COLECTII(1, v_rezultat);
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('Rezultat final: ' || v_rezultat);
END;
/

CERINTA 9: SUBPROGRAM CU CURSOARE (2 tipuri)

Enunt: Creati un subprogram PL/SQL care utilizeaza 2 tipuri de cursoare, unul dintre ele fiind dependent de celalalt

SET SERVEROUTPUT ON;
CREATE OR REPLACE PROCEDURE SP_PROCESARE_CURSOARE (
p_id_rol IN NUMBER,
p_rezultat OUT VARCHAR2
)
IS
CURSOR c_utilizatori_rol (p_rol_id NUMBER) IS
SELECT IdUtilizator, Nume, Prenume, Email
FROM UTILIZATORI
WHERE IdRol = p_rol_id
AND IsDeleted = 0
ORDER BY Nume, Prenume;
v_id_utilizator NUMBER;
v_nume VARCHAR2(100);
v_prenume VARCHAR2(100);
v_email VARCHAR2(255);
v_total_utilizatori NUMBER := 0;
v_total_aplicatii NUMBER := 0;
v_aplicatii_aprobate NUMBER := 0;
BEGIN
DBMS_OUTPUT.PUT_LINE('========================================');
DBMS_OUTPUT.PUT_LINE('Procesare cursoare pentru rol: ' || p_id_rol);
DBMS_OUTPUT.PUT_LINE('========================================');
OPEN c_utilizatori_rol(p_id_rol);
LOOP
FETCH c_utilizatori_rol INTO v_id_utilizator, v_nume, v_prenume, v_email;
EXIT WHEN c_utilizatori_rol%NOTFOUND;
v_total_utilizatori := v_total_utilizatori + 1;
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('Utilizator ' || v_total_utilizatori || ': ' ||
v_nume || ' ' || v_prenume || ' (' || v_email || ')');
FOR rec_aplicatie IN (
SELECT
a.Id,
a.Status,
a.TypeCredit,
a.SumaAprobata,
a.Scoring,
a.CreatedAt
FROM APLICATII a
WHERE a.UserId = v_id_utilizator
ORDER BY a.CreatedAt DESC
) LOOP
v_total_aplicatii := v_total_aplicatii + 1;
IF rec_aplicatie.Status = 'APROBAT' THEN
v_aplicatii_aprobate := v_aplicatii_aprobate + 1;
END IF;
DBMS_OUTPUT.PUT_LINE('  → Aplicație ID: ' || rec_aplicatie.Id ||
', Status: ' || rec_aplicatie.Status ||
', Tip: ' || NVL(rec_aplicatie.TypeCredit, 'N/A') ||
', Suma: ' || NVL(TO_CHAR(rec_aplicatie.SumaAprobata), 'N/A') ||
', Scoring: ' || NVL(TO_CHAR(rec_aplicatie.Scoring), 'N/A'));
END LOOP;
IF v_total_aplicatii = 0 THEN
DBMS_OUTPUT.PUT_LINE('  → Nu are aplicații');
END IF;
END LOOP;
CLOSE c_utilizatori_rol;
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('========================================');
DBMS_OUTPUT.PUT_LINE('REZUMAT:');
DBMS_OUTPUT.PUT_LINE('  Total utilizatori procesați: ' || v_total_utilizatori);
DBMS_OUTPUT.PUT_LINE('  Total aplicații găsite: ' || v_total_aplicatii);
DBMS_OUTPUT.PUT_LINE('  Aplicații aprobate: ' || v_aplicatii_aprobate);
DBMS_OUTPUT.PUT_LINE('========================================');
p_rezultat := 'Procesați ' || v_total_utilizatori || ' utilizatori, ' ||
v_total_aplicatii || ' aplicații (' || v_aplicatii_aprobate || ' aprobate)';
EXCEPTION
WHEN OTHERS THEN
IF c_utilizatori_rol%ISOPEN THEN
CLOSE c_utilizatori_rol;
END IF;
p_rezultat := 'EROARE: ' || SQLERRM;
DBMS_OUTPUT.PUT_LINE('EROARE: ' || p_rezultat);
RAISE;
END;
/
DECLARE
v_rezultat VARCHAR2(500);
v_id_rol_client NUMBER;
BEGIN
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('TESTARE PROCEDURĂ SP_PROCESARE_CURSOARE');
DBMS_OUTPUT.PUT_LINE('');
SELECT IdRol INTO v_id_rol_client
FROM ROLURI
WHERE NumeRol = 'CLIENT';
SP_PROCESARE_CURSOARE(v_id_rol_client, v_rezultat);
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('Rezultat final: ' || v_rezultat);
EXCEPTION
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('EROARE: Rolul CLIENT nu a fost găsit!');
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('EROARE: ' || SQLERRM);
END;
/

CERINTA 9: FUNCTIE CU 3 TABELE SI EXCEPTII

Enunt: Creati o functie PL/SQL care utilizeaza 3 tabele si include tratare exceptii proprii

SET SERVEROUTPUT ON;
CREATE OR REPLACE FUNCTION FN_CALCUL_STATISTICI_UTILIZATOR (
p_id_utilizator IN NUMBER
) RETURN VARCHAR2
IS
ex_utilizator_inexistent EXCEPTION;
ex_date_insuficiente EXCEPTION;
PRAGMA EXCEPTION_INIT(ex_utilizator_inexistent, -20001);
PRAGMA EXCEPTION_INIT(ex_date_insuficiente, -20002);
v_nume_complet VARCHAR2(200);
v_numar_aplicatii NUMBER := 0;
v_suma_totala NUMBER := 0;
v_scoring_mediu NUMBER := 0;
v_numar_banci NUMBER := 0;
v_rezultat VARCHAR2(1000);
v_utilizator_exista NUMBER := 0;
v_aplicatii_exista NUMBER := 0;
BEGIN
DBMS_OUTPUT.PUT_LINE('========================================');
DBMS_OUTPUT.PUT_LINE('Calcul statistici pentru utilizator: ' || p_id_utilizator);
DBMS_OUTPUT.PUT_LINE('========================================');
SELECT COUNT(*) INTO v_utilizator_exista
FROM UTILIZATORI
WHERE IdUtilizator = p_id_utilizator
AND IsDeleted = 0;
IF v_utilizator_exista = 0 THEN
RAISE ex_utilizator_inexistent;
END IF;
SELECT
u.Nume || ' ' || u.Prenume AS NumeComplet,
COUNT(DISTINCT a.Id) AS NumarAplicatii,
SUM(NVL(a.SumaAprobata, 0)) AS SumaTotala,
AVG(a.Scoring) AS ScoringMediu,
COUNT(DISTINCT ab.BankId) AS NumarBanci
INTO
v_nume_complet,
v_numar_aplicatii,
v_suma_totala,
v_scoring_mediu,
v_numar_banci
FROM UTILIZATORI u
LEFT JOIN APLICATII a ON u.IdUtilizator = a.UserId
LEFT JOIN APPLICATION_BANKS ab ON a.Id = ab.ApplicationId
WHERE u.IdUtilizator = p_id_utilizator
AND u.IsDeleted = 0
GROUP BY u.IdUtilizator, u.Nume, u.Prenume;
IF v_numar_aplicatii = 0 THEN
RAISE ex_date_insuficiente;
END IF;
v_rezultat := 'Utilizator: ' || v_nume_complet || ' | ' ||
'Aplicații: ' || v_numar_aplicatii || ' | ' ||
'Suma totală: ' || TO_CHAR(v_suma_totala, '999,999,999.00') || ' | ' ||
'Scoring mediu: ' || NVL(TO_CHAR(ROUND(v_scoring_mediu, 2)), 'N/A') || ' | ' ||
'Bănci: ' || v_numar_banci;
DBMS_OUTPUT.PUT_LINE('Rezultat: ' || v_rezultat);
DBMS_OUTPUT.PUT_LINE('========================================');
RETURN v_rezultat;
EXCEPTION
WHEN ex_utilizator_inexistent THEN
DBMS_OUTPUT.PUT_LINE('EROARE: Utilizatorul cu ID ' || p_id_utilizator || ' nu există sau este șters!');
RETURN 'EROARE: Utilizator inexistent (ID: ' || p_id_utilizator || ')';
WHEN ex_date_insuficiente THEN
DBMS_OUTPUT.PUT_LINE('EROARE: Utilizatorul nu are aplicații!');
RETURN 'EROARE: Date insuficiente - utilizatorul nu are aplicații';
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('EROARE: Nu s-au găsit date pentru utilizator!');
RETURN 'EROARE: Date negăsite pentru utilizator (ID: ' || p_id_utilizator || ')';
WHEN TOO_MANY_ROWS THEN
DBMS_OUTPUT.PUT_LINE('EROARE: S-au găsit mai multe înregistrări decât așteptat!');
RETURN 'EROARE: Date duplicate pentru utilizator (ID: ' || p_id_utilizator || ')';
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('EROARE NEAȘTEPTATĂ: ' || SQLCODE || ' - ' || SQLERRM);
RETURN 'EROARE: ' || SQLCODE || ' - ' || SUBSTR(SQLERRM, 1, 200);
END;
/
DECLARE
v_rezultat VARCHAR2(1000);
v_id_utilizator_valid NUMBER;
v_id_utilizator_inexistent NUMBER := 99999;
v_id_utilizator_fara_aplicatii NUMBER;
BEGIN
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('TESTARE FUNCȚIE FN_CALCUL_STATISTICI_UTILIZATOR');
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('TEST 1: Utilizator valid cu aplicații');
BEGIN
SELECT IdUtilizator INTO v_id_utilizator_valid
FROM (
SELECT u.IdUtilizator
FROM UTILIZATORI u
INNER JOIN APLICATII a ON u.IdUtilizator = a.UserId
WHERE u.IsDeleted = 0
AND ROWNUM = 1
);
v_rezultat := FN_CALCUL_STATISTICI_UTILIZATOR(v_id_utilizator_valid);
DBMS_OUTPUT.PUT_LINE('Rezultat: ' || v_rezultat);
EXCEPTION
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('Nu există utilizatori cu aplicații pentru test!');
END;
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('TEST 2: Utilizator inexistent');
v_rezultat := FN_CALCUL_STATISTICI_UTILIZATOR(v_id_utilizator_inexistent);
DBMS_OUTPUT.PUT_LINE('Rezultat: ' || v_rezultat);
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('TEST 3: Utilizator fără aplicații');
BEGIN
SELECT IdUtilizator INTO v_id_utilizator_fara_aplicatii
FROM (
SELECT u.IdUtilizator
FROM UTILIZATORI u
WHERE u.IsDeleted = 0
AND NOT EXISTS (
SELECT 1 FROM APLICATII a WHERE a.UserId = u.IdUtilizator
)
AND ROWNUM = 1
);
v_rezultat := FN_CALCUL_STATISTICI_UTILIZATOR(v_id_utilizator_fara_aplicatii);
DBMS_OUTPUT.PUT_LINE('Rezultat: ' || v_rezultat);
EXCEPTION
WHEN NO_DATA_FOUND THEN
DBMS_OUTPUT.PUT_LINE('Nu există utilizatori fără aplicații pentru test!');
END;
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('Toate testele au fost executate!');
END;
/

CERINTA 9: TRIGGER LDD

Enunt: Creati un trigger LDD (Data Definition Language) care se declanseaza la operatii CREATE, ALTER sau DROP

SET SERVEROUTPUT ON;
CREATE OR REPLACE TRIGGER trg_audit_ddl
AFTER CREATE OR ALTER OR DROP ON SCHEMA
DECLARE
v_event_type VARCHAR2(30);
v_object_type VARCHAR2(30);
v_object_name VARCHAR2(128);
v_object_owner VARCHAR2(128);
v_sql_text ORA_NAME_LIST_T;
v_sql_text_full VARCHAR2(4000) := '';
v_i NUMBER;
BEGIN
IF ORA_SYSEVENT = 'CREATE' THEN
v_event_type := 'CREATE';
ELSIF ORA_SYSEVENT = 'ALTER' THEN
v_event_type := 'ALTER';
ELSIF ORA_SYSEVENT = 'DROP' THEN
v_event_type := 'DROP';
ELSE
v_event_type := ORA_SYSEVENT;
END IF;
v_object_type := ORA_DICT_OBJ_TYPE;
v_object_name := ORA_DICT_OBJ_NAME;
v_object_owner := ORA_DICT_OBJ_OWNER;
v_sql_text := ORA_SQL_TXT;
IF v_sql_text.COUNT > 0 THEN
FOR v_i IN 1..v_sql_text.COUNT LOOP
v_sql_text_full := v_sql_text_full || v_sql_text(v_i);
END LOOP;
END IF;
DBMS_OUTPUT.PUT_LINE('========================================');
DBMS_OUTPUT.PUT_LINE('TRIGGER LDD DECLANSAT');
DBMS_OUTPUT.PUT_LINE('========================================');
DBMS_OUTPUT.PUT_LINE('Eveniment: ' || v_event_type);
DBMS_OUTPUT.PUT_LINE('Tip obiect: ' || v_object_type);
DBMS_OUTPUT.PUT_LINE('Nume obiect: ' || v_object_name);
DBMS_OUTPUT.PUT_LINE('Proprietar: ' || v_object_owner);
DBMS_OUTPUT.PUT_LINE('Utilizator: ' || USER);
DBMS_OUTPUT.PUT_LINE('Data/Ora: ' || TO_CHAR(SYSDATE, 'DD-MM-YYYY HH24:MI:SS'));
IF LENGTH(v_sql_text_full) > 0 THEN
DBMS_OUTPUT.PUT_LINE('SQL: ' || SUBSTR(v_sql_text_full, 1, 200));
END IF;
DBMS_OUTPUT.PUT_LINE('========================================');
BEGIN
INSERT INTO MESAJE (
cod_mesaj,
mesaj,
tip_mesaj,
creat_de,
creat_la
) VALUES (
seq_mesaje.NEXTVAL,
'DDL Event: ' || v_event_type || ' ' || v_object_type || ' ' || v_object_name,
'I',
USER,
SYSDATE
);
COMMIT;
EXCEPTION
WHEN OTHERS THEN
NULL;
END;
EXCEPTION
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('EROARE în trigger LDD: ' || SQLERRM);
END;
/
BEGIN
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('TESTARE TRIGGER LDD');
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('Se va crea un tabel de test pentru a declanșa triggerul...');
END;
/
CREATE TABLE TEST_TRIGGER_LDD (
id NUMBER PRIMARY KEY,
nume VARCHAR2(100)
);
ALTER TABLE TEST_TRIGGER_LDD ADD descriere VARCHAR2(200);
DROP TABLE TEST_TRIGGER_LDD;
BEGIN
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('Testare trigger LDD completată!');
DBMS_OUTPUT.PUT_LINE('Verifică mesajele de mai sus pentru confirmare.');
END;
/

CERINTA 9: PACHET CU TOATE OBJECTELE

Enunt: Creati un pachet PL/SQL care contine toate subprogramele create anterior si care declanseaza triggeri LMD prin instructiuni din subprograme

SET SERVEROUTPUT ON;
CREATE OR REPLACE PACKAGE PKG_MONEYSHOP AS
PROCEDURE SP_PROCESARE_COLECTII (
p_id_utilizator IN NUMBER,
p_rezultat OUT VARCHAR2
);
PROCEDURE SP_PROCESARE_CURSOARE (
p_id_rol IN NUMBER,
p_rezultat OUT VARCHAR2
);
FUNCTION FN_CALCUL_STATISTICI_UTILIZATOR (
p_id_utilizator IN NUMBER
) RETURN VARCHAR2;
PROCEDURE SP_ACTUALIZARE_APLICATIE (
p_id_aplicatie IN NUMBER,
p_nou_status IN VARCHAR2,
p_suma_aprobata IN NUMBER DEFAULT NULL
);
PROCEDURE SP_CREARE_APLICATIE (
p_id_utilizator IN NUMBER,
p_type_credit IN VARCHAR2,
p_tip_operatiune IN VARCHAR2,
p_salariu_net IN NUMBER,
p_id_aplicatie OUT NUMBER
);
FUNCTION FN_INSERARE_MESAJ (
p_mesaj IN VARCHAR2,
p_tip_mesaj IN VARCHAR2 DEFAULT 'I',
p_creat_de IN VARCHAR2 DEFAULT USER
) RETURN NUMBER;
END PKG_MONEYSHOP;
/
CREATE OR REPLACE PACKAGE BODY PKG_MONEYSHOP AS
TYPE t_varray_nume IS VARRAY(100) OF VARCHAR2(100);
TYPE t_nested_table_id IS TABLE OF NUMBER;
TYPE t_assoc_array IS TABLE OF NUMBER INDEX BY VARCHAR2(50);
PROCEDURE SP_PROCESARE_COLECTII (
p_id_utilizator IN NUMBER,
p_rezultat OUT VARCHAR2
)
IS
v_nume_banci t_varray_nume := t_varray_nume();
v_id_aplicatii t_nested_table_id := t_nested_table_id();
v_sume_pe_status t_assoc_array;
v_contor NUMBER := 0;
BEGIN
DBMS_OUTPUT.PUT_LINE('PKG_MONEYSHOP.SP_PROCESARE_COLECTII - Utilizator: ' || p_id_utilizator);
FOR rec IN (
SELECT DISTINCT b.Name
FROM BANCI b
INNER JOIN APPLICATION_BANKS ab ON b.Id = ab.BankId
INNER JOIN APLICATII a ON ab.ApplicationId = a.Id
WHERE a.UserId = p_id_utilizator
AND ROWNUM <= 100
) LOOP
v_nume_banci.EXTEND;
v_nume_banci(v_nume_banci.COUNT) := rec.Name;
END LOOP;
FOR rec IN (
SELECT Id
FROM APLICATII
WHERE UserId = p_id_utilizator
) LOOP
v_id_aplicatii.EXTEND;
v_id_aplicatii(v_id_aplicatii.COUNT) := rec.Id;
END LOOP;
FOR rec IN (
SELECT Status, SUM(NVL(SumaAprobata, 0)) AS SumaTotala
FROM APLICATII
WHERE UserId = p_id_utilizator
GROUP BY Status
) LOOP
v_sume_pe_status(rec.Status) := rec.SumaTotala;
END LOOP;
p_rezultat := 'VARRAY: ' || v_nume_banci.COUNT || ' bănci, ' ||
'NESTED TABLE: ' || v_id_aplicatii.COUNT || ' aplicații, ' ||
'ASSOCIATIVE ARRAY: ' || v_sume_pe_status.COUNT || ' statusuri';
EXCEPTION
WHEN OTHERS THEN
p_rezultat := 'EROARE: ' || SQLERRM;
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('EROARE SP_PROCESARE_COLECTII: ' || SQLERRM, 'E');
END;
RAISE;
END SP_PROCESARE_COLECTII;
PROCEDURE SP_PROCESARE_CURSOARE (
p_id_rol IN NUMBER,
p_rezultat OUT VARCHAR2
)
IS
CURSOR c_utilizatori_rol (p_rol_id NUMBER) IS
SELECT IdUtilizator, Nume, Prenume, Email
FROM UTILIZATORI
WHERE IdRol = p_rol_id
AND IsDeleted = 0
ORDER BY Nume, Prenume;
v_id_utilizator NUMBER;
v_nume VARCHAR2(100);
v_prenume VARCHAR2(100);
v_email VARCHAR2(255);
v_total_utilizatori NUMBER := 0;
v_total_aplicatii NUMBER := 0;
BEGIN
DBMS_OUTPUT.PUT_LINE('PKG_MONEYSHOP.SP_PROCESARE_CURSOARE - Rol: ' || p_id_rol);
OPEN c_utilizatori_rol(p_id_rol);
LOOP
FETCH c_utilizatori_rol INTO v_id_utilizator, v_nume, v_prenume, v_email;
EXIT WHEN c_utilizatori_rol%NOTFOUND;
v_total_utilizatori := v_total_utilizatori + 1;
FOR rec_aplicatie IN (
SELECT Id, Status, SumaAprobata
FROM APLICATII
WHERE UserId = v_id_utilizator
) LOOP
v_total_aplicatii := v_total_aplicatii + 1;
END LOOP;
END LOOP;
CLOSE c_utilizatori_rol;
p_rezultat := 'Procesați ' || v_total_utilizatori || ' utilizatori, ' ||
v_total_aplicatii || ' aplicații';
EXCEPTION
WHEN OTHERS THEN
IF c_utilizatori_rol%ISOPEN THEN
CLOSE c_utilizatori_rol;
END IF;
p_rezultat := 'EROARE: ' || SQLERRM;
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('EROARE SP_PROCESARE_CURSOARE: ' || SQLERRM, 'E');
END;
RAISE;
END SP_PROCESARE_CURSOARE;
FUNCTION FN_CALCUL_STATISTICI_UTILIZATOR (
p_id_utilizator IN NUMBER
) RETURN VARCHAR2
IS
ex_utilizator_inexistent EXCEPTION;
ex_date_insuficiente EXCEPTION;
PRAGMA EXCEPTION_INIT(ex_utilizator_inexistent, -20001);
PRAGMA EXCEPTION_INIT(ex_date_insuficiente, -20002);
v_nume_complet VARCHAR2(200);
v_numar_aplicatii NUMBER := 0;
v_suma_totala NUMBER := 0;
v_scoring_mediu NUMBER := 0;
v_numar_banci NUMBER := 0;
v_rezultat VARCHAR2(1000);
v_utilizator_exista NUMBER := 0;
BEGIN
SELECT COUNT(*) INTO v_utilizator_exista
FROM UTILIZATORI
WHERE IdUtilizator = p_id_utilizator
AND IsDeleted = 0;
IF v_utilizator_exista = 0 THEN
RAISE ex_utilizator_inexistent;
END IF;
SELECT
u.Nume || ' ' || u.Prenume,
COUNT(DISTINCT a.Id),
SUM(NVL(a.SumaAprobata, 0)),
AVG(a.Scoring),
COUNT(DISTINCT ab.BankId)
INTO
v_nume_complet,
v_numar_aplicatii,
v_suma_totala,
v_scoring_mediu,
v_numar_banci
FROM UTILIZATORI u
LEFT JOIN APLICATII a ON u.IdUtilizator = a.UserId
LEFT JOIN APPLICATION_BANKS ab ON a.Id = ab.ApplicationId
WHERE u.IdUtilizator = p_id_utilizator
AND u.IsDeleted = 0
GROUP BY u.IdUtilizator, u.Nume, u.Prenume;
IF v_numar_aplicatii = 0 THEN
RAISE ex_date_insuficiente;
END IF;
v_rezultat := 'Utilizator: ' || v_nume_complet || ' | ' ||
'Aplicații: ' || v_numar_aplicatii || ' | ' ||
'Suma totală: ' || TO_CHAR(v_suma_totala, '999,999,999.00') || ' | ' ||
'Scoring mediu: ' || NVL(TO_CHAR(ROUND(v_scoring_mediu, 2)), 'N/A') || ' | ' ||
'Bănci: ' || v_numar_banci;
RETURN v_rezultat;
EXCEPTION
WHEN ex_utilizator_inexistent THEN
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('Utilizator inexistent: ' || p_id_utilizator, 'E');
END;
RETURN 'EROARE: Utilizator inexistent (ID: ' || p_id_utilizator || ')';
WHEN ex_date_insuficiente THEN
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('Date insuficiente pentru utilizator: ' || p_id_utilizator, 'W');
END;
RETURN 'EROARE: Date insuficiente - utilizatorul nu are aplicații';
WHEN OTHERS THEN
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('EROARE FN_CALCUL_STATISTICI: ' || SQLERRM, 'E');
END;
RETURN 'EROARE: ' || SQLCODE || ' - ' || SUBSTR(SQLERRM, 1, 200);
END FN_CALCUL_STATISTICI_UTILIZATOR;
PROCEDURE SP_ACTUALIZARE_APLICATIE (
p_id_aplicatie IN NUMBER,
p_nou_status IN VARCHAR2,
p_suma_aprobata IN NUMBER DEFAULT NULL
)
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('PKG_MONEYSHOP.SP_ACTUALIZARE_APLICATIE - Aplicație: ' || p_id_aplicatie);
UPDATE APLICATII
SET Status = p_nou_status,
SumaAprobata = NVL(p_suma_aprobata, SumaAprobata),
UpdatedAt = SYSTIMESTAMP
WHERE Id = p_id_aplicatie;
IF SQL%ROWCOUNT = 0 THEN
RAISE_APPLICATION_ERROR(-20010, 'Aplicația cu ID ' || p_id_aplicatie || ' nu există!');
END IF;
COMMIT;
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('Aplicație actualizată: ' || p_id_aplicatie || ' -> Status: ' || p_nou_status, 'I');
END;
EXCEPTION
WHEN OTHERS THEN
ROLLBACK;
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('EROARE SP_ACTUALIZARE_APLICATIE: ' || SQLERRM, 'E');
END;
RAISE;
END SP_ACTUALIZARE_APLICATIE;
PROCEDURE SP_CREARE_APLICATIE (
p_id_utilizator IN NUMBER,
p_type_credit IN VARCHAR2,
p_tip_operatiune IN VARCHAR2,
p_salariu_net IN NUMBER,
p_id_aplicatie OUT NUMBER
)
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('PKG_MONEYSHOP.SP_CREARE_APLICATIE - Utilizator: ' || p_id_utilizator);
INSERT INTO APLICATII (
UserId,
Status,
TypeCredit,
TipOperatiune,
SalariuNet,
CreatedAt,
UpdatedAt
) VALUES (
p_id_utilizator,
'INREGISTRAT',
p_type_credit,
p_tip_operatiune,
p_salariu_net,
SYSTIMESTAMP,
SYSTIMESTAMP
)
RETURNING Id INTO p_id_aplicatie;
COMMIT;
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('Aplicație creată: ' || p_id_aplicatie || ' pentru utilizator: ' || p_id_utilizator, 'I');
END;
EXCEPTION
WHEN OTHERS THEN
ROLLBACK;
DECLARE
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := FN_INSERARE_MESAJ('EROARE SP_CREARE_APLICATIE: ' || SQLERRM, 'E');
END;
RAISE;
END SP_CREARE_APLICATIE;
FUNCTION FN_INSERARE_MESAJ (
p_mesaj IN VARCHAR2,
p_tip_mesaj IN VARCHAR2 DEFAULT 'I',
p_creat_de IN VARCHAR2 DEFAULT USER
) RETURN NUMBER
IS
v_cod_mesaj NUMBER;
BEGIN
v_cod_mesaj := seq_mesaje.NEXTVAL;
INSERT INTO MESAJE (
cod_mesaj,
mesaj,
tip_mesaj,
creat_de,
creat_la
) VALUES (
v_cod_mesaj,
SUBSTR(p_mesaj, 1, 255),
p_tip_mesaj,
p_creat_de,
SYSDATE
);
COMMIT;
RETURN v_cod_mesaj;
EXCEPTION
WHEN OTHERS THEN
RETURN 0;
END FN_INSERARE_MESAJ;
END PKG_MONEYSHOP;
/
BEGIN
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('========================================');
DBMS_OUTPUT.PUT_LINE('TESTARE PACHET PKG_MONEYSHOP');
DBMS_OUTPUT.PUT_LINE('========================================');
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('Pachetul a fost creat cu succes!');
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('Proceduri disponibile:');
DBMS_OUTPUT.PUT_LINE('  - PKG_MONEYSHOP.SP_PROCESARE_COLECTII');
DBMS_OUTPUT.PUT_LINE('  - PKG_MONEYSHOP.SP_PROCESARE_CURSOARE');
DBMS_OUTPUT.PUT_LINE('  - PKG_MONEYSHOP.SP_ACTUALIZARE_APLICATIE');
DBMS_OUTPUT.PUT_LINE('  - PKG_MONEYSHOP.SP_CREARE_APLICATIE');
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('Funcții disponibile:');
DBMS_OUTPUT.PUT_LINE('  - PKG_MONEYSHOP.FN_CALCUL_STATISTICI_UTILIZATOR');
DBMS_OUTPUT.PUT_LINE('  - PKG_MONEYSHOP.FN_INSERARE_MESAJ');
DBMS_OUTPUT.PUT_LINE('========================================');
END;
/

CERINTA 10: TRIGGERI LMD CU INSERARE MESAJE

Enunt: Creati triggeri LMD (Data Manipulation Language) la nivel de comanda si la nivel de linie care insereaza mesaje in tabelul MESAJE

SET SERVEROUTPUT ON;
CREATE OR REPLACE TRIGGER trg_aplicatii_before_insert
BEFORE INSERT ON APLICATII
DECLARE
v_count NUMBER;
BEGIN
SELECT COUNT(*) INTO v_count
FROM UTILIZATORI
WHERE IsDeleted = 0;
IF v_count = 0 THEN
INSERT INTO MESAJE (
cod_mesaj,
mesaj,
tip_mesaj,
creat_de,
creat_la
) VALUES (
seq_mesaje.NEXTVAL,
'ATENȚIONARE: Nu există utilizatori activi în sistem!',
'W',
USER,
SYSDATE
);
COMMIT;
END IF;
EXCEPTION
WHEN OTHERS THEN
NULL;
END;
/
CREATE OR REPLACE TRIGGER trg_aplicatii_before_update
BEFORE UPDATE ON APLICATII
FOR EACH ROW
DECLARE
v_mesaj VARCHAR2(255);
BEGIN
IF :OLD.Status != :NEW.Status THEN
v_mesaj := 'Status aplicație ' || :NEW.Id || ' schimbat de la ' ||
:OLD.Status || ' la ' || :NEW.Status;
INSERT INTO MESAJE (
cod_mesaj,
mesaj,
tip_mesaj,
creat_de,
creat_la
) VALUES (
seq_mesaje.NEXTVAL,
v_mesaj,
'I',
USER,
SYSDATE
);
END IF;
IF :NEW.Scoring IS NOT NULL AND (:NEW.Scoring < 300 OR :NEW.Scoring > 850) THEN
INSERT INTO MESAJE (
cod_mesaj,
mesaj,
tip_mesaj,
creat_de,
creat_la
) VALUES (
seq_mesaje.NEXTVAL,
'EROARE: Scoring invalid pentru aplicația ' || :NEW.Id ||
' (valoare: ' || :NEW.Scoring || ', trebuie între 300-850)',
'E',
USER,
SYSDATE
);
RAISE_APPLICATION_ERROR(-20020, 'Scoring invalid! Trebuie să fie între 300 și 850.');
END IF;
EXCEPTION
WHEN OTHERS THEN
RAISE;
END;
/
CREATE OR REPLACE TRIGGER trg_aplicatii_after_insert
AFTER INSERT ON APLICATII
FOR EACH ROW
BEGIN
INSERT INTO MESAJE (
cod_mesaj,
mesaj,
tip_mesaj,
creat_de,
creat_la
) VALUES (
seq_mesaje.NEXTVAL,
'Aplicație nouă creată: ID=' || :NEW.Id ||
', Utilizator=' || :NEW.UserId ||
', Status=' || :NEW.Status,
'I',
USER,
SYSDATE
);
EXCEPTION
WHEN OTHERS THEN
NULL;
END;
/
CREATE OR REPLACE TRIGGER trg_aplicatii_after_delete
AFTER DELETE ON APLICATII
FOR EACH ROW
BEGIN
INSERT INTO MESAJE (
cod_mesaj,
mesaj,
tip_mesaj,
creat_de,
creat_la
) VALUES (
seq_mesaje.NEXTVAL,
'Aplicație ștearsă: ID=' || :OLD.Id ||
', Utilizator=' || :OLD.UserId ||
', Status=' || :OLD.Status,
'W',
USER,
SYSDATE
);
EXCEPTION
WHEN OTHERS THEN
NULL;
END;
/
CREATE OR REPLACE TRIGGER trg_utilizatori_varsta_mesaje
BEFORE INSERT OR UPDATE OF DataNastere ON UTILIZATORI
FOR EACH ROW
BEGIN
IF :NEW.DataNastere > ADD_MONTHS(SYSDATE, -216) THEN
INSERT INTO MESAJE (
cod_mesaj,
mesaj,
tip_mesaj,
creat_de,
creat_la
) VALUES (
seq_mesaje.NEXTVAL,
'EROARE: Utilizator ' || :NEW.IdUtilizator ||
' are vârsta mai mică de 18 ani!',
'E',
USER,
SYSDATE
);
COMMIT;
RAISE_APPLICATION_ERROR(-20005, 'Utilizatorul trebuie să aibă minim 18 ani');
END IF;
EXCEPTION
WHEN OTHERS THEN
RAISE;
END;
/
BEGIN
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('========================================');
DBMS_OUTPUT.PUT_LINE('TRIGGERI LMD CU INSERARE ÎN MESAJE');
DBMS_OUTPUT.PUT_LINE('========================================');
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('Triggeri creați:');
DBMS_OUTPUT.PUT_LINE('  ✓ trg_aplicatii_before_insert (nivel comandă)');
DBMS_OUTPUT.PUT_LINE('  ✓ trg_aplicatii_before_update (nivel linie)');
DBMS_OUTPUT.PUT_LINE('  ✓ trg_aplicatii_after_insert (nivel linie)');
DBMS_OUTPUT.PUT_LINE('  ✓ trg_aplicatii_after_delete (nivel linie)');
DBMS_OUTPUT.PUT_LINE('  ✓ trg_utilizatori_varsta_mesaje (nivel linie)');
DBMS_OUTPUT.PUT_LINE('');
DBMS_OUTPUT.PUT_LINE('Toți triggerii inserează mesaje în tabelul MESAJE!');
DBMS_OUTPUT.PUT_LINE('========================================');
END;
/

CERINTA 10: TRATARE EXCEPTII CU INSERARE MESAJE

Enunt: Toate subprogramele si triggerii trebuie sa insereze mesaje in tabelul MESAJE la aparitia exceptiilor, folosind secventa seq_mesaje pentru generarea codurilor de mesaj

Nota: Tratarea exceptiilor cu inserare mesaje este implementata in:
- Pachetul PKG_MONEYSHOP (functia FN_INSERARE_MESAJ)
- Toate subprogramele din pachet care apeleaza FN_INSERARE_MESAJ in blocuri EXCEPTION
- Toate triggerii LMD care insereaza direct in MESAJE
- Triggerul LDD care insereaza in MESAJE

Secventa seq_mesaje este creata in scriptul de creare tabele (03_CREATE_TABLES.sql).

